.comment
.comment
..| when chkline is run on this file, the error "incorrectly paired \b \p or \i \p"
..|   error occurs. This is due to the presence of \\<FILENAME> in the file
..|   due to the environment variable $ASMEX being equal to \MASM61\SAMPLES.
..| Technically, the error shouldn't occur. Never could figure out why it does.
..|    a-abird
.comment
.comment
.context AAA
.context @AAA
.topic AAA Instruction
.freeze 3
..index AAA instruction, ASCII Adjust after Addition
 \i\p\aDetail\v@AAA.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@BCDInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    ASCII Adjust after Addition           \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   AAA                                          ?       ? ? ñ ? ñ

  \bSee also:\p AAS, AAM, AAD, DAA, DAS

  \bDescription:\p

     Adjusts the result of an addition to a decimal digit (0-9). The
     previous addition instruction should place its 8-bit sum in AL. If
     the sum is greater than 9h, AH is incremented and the carry and
     auxiliary carry flags are set. Otherwise, the carry and auxiliary
     carry flags are cleared.
.context @AAA.des
.freeze 3
.topic AAA Instruction
 \i\p\aSummary\v@AAA\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@BCDInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00110111
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 AAA          ³ aaa                        ³ 88/86 8
              ³                            ³   286 3
              ³                            ³   386 4
              ³                            ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context AAD
.context @AAD
.topic AAD Instruction
.freeze 3
..index AAD instruction, ASCII Adjust before Division
 \i\p\aDetail\v@AAD.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@BCDInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    ASCII Adjust before Division          \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   AAD                                          ?       ñ ñ ? ñ ?

  \bSee also:\p AAA, AAS, AAM, DAA, DAS

  \bDescription:\p

     Converts unpacked BCD digits in AH (most significant digit) and AL
     (least significant digit) to a binary number in AX.

     Use this instruction to prepare an unpacked BCD number in AX for
     division by an unpacked BCD digit in an 8-bit register.
.context @AAD.des
.freeze 3
.topic AAD Instruction
 \i\p\aSummary\v@AAD\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@BCDInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11010101     00001010
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 AAD          ³ aad                        ³ 88/86 60
              ³                            ³   286 14
              ³                            ³   386 19
              ³                            ³   486 14
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context AAM
.context @AAM
.topic AAM Instruction
.freeze 3
..index AAM instruction, ASCII Adjust after Multiply
 \i\p\aDetail\v@AAM.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@IntToAsc.asx\v\i\p                    \i\p\aUp\v@BCDInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    ASCII Adjust after Multiply           \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   AAM                                          ?       ñ ñ ? ñ ?

  \bSee also:\p AAA, AAS, AAD, DAA, DAS

  \bDescription:\p

     Converts an 8-bit binary number (less than 100 decimal) in AL to an
     unpacked BCD number in AX. The most significant digit goes in AH
     and the least significant in AL.

     Use this instruction to adjust the product after a MUL instruction
     that multiplies unpacked BCD digits in AH and AL. You can also use
     AAM to adjust the quotient after a DIV instruction that divides a
     binary number less than 100 decimal in AX by an unpacked BCD
     number.
.context @AAM.des
.freeze 3
.topic AAM Instruction
 \i\p\aSummary\v@AAM\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@IntToAsc.asx\v\i\p                    \i\p\aUp\v@BCDInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11010100     00001010
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 AAM              ³ aam                    ³ 88/86 83
                  ³                        ³   286 16
                  ³                        ³   386 17
                  ³                        ³   486 15
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context AAS
.context @AAS
.topic AAS Instruction
.freeze 3
..index AAS instruction, ASCII Adjust after Subtraction
 \i\p\aDetail\v@AAS.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                     \i\p\aUp\v@BCDInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    ASCII Adjust after Subtraction        \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   AAS                                          ?       ? ? ñ ? ñ

  \bSee also:\p AAA, AAM, AAD, DAA, DAS

  \bDescription:\p

     Adjusts the result of a subtraction to a decimal digit (0-9). The
     previous subtraction instruction should place its 8-bit result in
     AL. If the result is greater than 9h, AH is decremented and the
     carry and auxiliary carry flags are set. Otherwise, the carry and
     auxiliary carry flags are cleared.
.context @AAS.des
.freeze 3
.topic AAS Instruction
 \i\p\aSummary\v@AAS\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@BCDInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00111111
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 AAS              ³ aas                    ³ 88/86 8
                  ³                        ³   286 3
                  ³                        ³   386 4
                  ³                        ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context ADC
.context @ADC
.topic ADC Instruction
.freeze 3
..index ADC instruction, Add with Carry
 \i\p\aDetail\v@ADC.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@AddLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Add with Carry                        \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   ADC dest,src                                 ñ       ñ ñ ñ ñ ñ

  \bSee also:\p ADD, SUB, SBB

  \bDescription:\p

     Adds the source operand, the destination operand, and the value of
     the carry flag. The result is assigned to the destination operand.

     Use this instruction to add the more significant words that must
     be added in multiple steps. Use the ADD instruction to add the
     least significant words.
.context @ADC.des
.freeze 3
.topic ADC Instruction
 \i\p\aSummary\v@ADC\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@AddLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 000100dw    mod,reg,r/m    disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ADC  reg,reg      ³ adc   dx,cx               ³ 88/86 3
                   ³                           ³   286 2
                   ³                           ³   386 2
                   ³                           ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ADC  mem,reg      ³ adc   WORD PTR m32[2],dx  ³ 88/86 16+EA (W88=24+EA)
                   ³                           ³   286 7
                   ³                           ³   386 7
                   ³                           ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ADC  reg,mem      ³ adc   dx,WORD PTR m32[2]  ³ 88/86 9+EA (W88=13+EA)
                   ³                           ³   286 7
                   ³                           ³   386 6
                   ³                           ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 100000sw    mod,010,r/m    disp (0, 1, or 2)     data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ADC  reg,immed    ³ adc   dx,12               ³ 88/86 4
                   ³                           ³   286 3
                   ³                           ³   386 2
                   ³                           ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ADC  mem,immed    ³ adc   WORD PTR m32[2],16  ³ 88/86 17+EA (W88=23+EA)
                   ³                           ³   286 7
                   ³                           ³   386 7
                   ³                           ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 0001010w    data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ADC  accum,immed  ³ adc   ax,5                ³ 88/86 4
                   ³                           ³   286 3
                   ³                           ³   386 2
                   ³                           ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context ADD
.context @ADD
.topic ADD Instruction
.freeze 3
..index ADD instruction, Add
 \i\p\aDetail\v@ADD.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@AddLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Add                                   \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   ADD dest,src                                 ñ       ñ ñ ñ ñ ñ

  \bSee also:\p INC, ADC, SUB, XADD

  \bDescription:\p

     Adds the source and destination operands and puts the sum in the
     destination operand.
.context @ADD.des
.freeze 3
.topic ADD Instruction
 \i\p\aSummary\v@ADD\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@AddLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 000000dw     mod,reg,r/m       disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ADD  reg,reg      ³ add   ax,bx               ³ 88/86 3
                   ³                           ³   286 2
                   ³                           ³   386 2
                   ³                           ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ADD  mem,reg      ³ add   total,cx            ³ 88/86 16+EA (W88=24+EA)
                   ³ add   array[bx+di],dx     ³   286 7
                   ³                           ³   386 7
                   ³                           ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ADD  reg,mem      ³ add   cx,incr             ³ 88/86 9+EA (W88=13+EA)
                   ³ add   dx,[bp+6]           ³   286 7
                   ³                           ³   386 6
                   ³                           ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 100000sw     mod,000,r/m       disp (0, 1, or 2)     data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ADD  reg,immed    ³ add   bx,6                ³ 88/86 4
                   ³                           ³   286 3
                   ³                           ³   386 2
                   ³                           ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ADD  mem,immed    ³ add   amount,27           ³ 88/86 17+EA (W88=23+EA)
                   ³ add   pointers[bx][si],6  ³   286 7
                   ³                           ³   386 7
                   ³                           ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 0000010w     data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ADD  accum,immed  ³ add   ax,10               ³ 88/86 4
                   ³                           ³   286 3
                   ³                           ³   386 2
                   ³                           ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context AND
.context @AND
.topic AND Instruction
.freeze 3
..index AND instruction, Logical AND
 \i\p\aDetail\v@AND.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@Colors.asx\v\i\p                    \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Logical AND                           \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   AND dest,src                                 0       ñ ñ ? ñ 0

  \bSee also:\p \aAND Operator\v@LogShiftOp\v, \a&&\v@ccompare\v, OR, XOR, NOT, SHL, SHR, TEST,
            OPTION NOSIGNEXTEND

  \bDescription:\p

     Performs a bitwise AND operation on the source and destination
     operands and stores the result in the destination operand.

     For each bit position in the operands, if both bits are set,
     the corresponding bit of the result is set. Otherwise, the
     corresponding bit of the result is cleared.
.context @AND.des
.freeze 3
.topic AND Instruction
 \i\p\aSummary\v@AND\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@Colors.asx\v\i\p                    \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 001000dw     mod,reg,r/m       disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 AND  reg,reg      ³ and   dx,bx             ³ 88/86 3
                   ³                         ³   286 2
                   ³                         ³   386 2
                   ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 AND  mem,reg      ³ and   bitmask,bx        ³ 88/86 16+EA (W88=24+EA)
                   ³ and   [bp+2],dx         ³   286 7
                   ³                         ³   386 7
                   ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 AND  reg,mem      ³ and   bx,masker         ³ 88/86 9+EA (W88=13+EA)
                   ³ and   dx,marray[bx+di]  ³   286 7
                   ³                         ³   386 6
                   ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 100000sw     mod,100,r/m       disp (0, 1, or 2)     data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 AND  reg,immed    ³ and   dx,0F7h           ³ 88/86 4
                   ³                         ³   286 3
                   ³                         ³   386 2
                   ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 AND  mem,immed    ³ and   masker,1001b      ³ 88/86 17+EA (W88=23+EA)
                   ³                         ³   286 7
                   ³                         ³   386 7
                   ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 0010010w     data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 AND  accum,immed  ³ and   ax,0B6h           ³ 88/86 4
                   ³                         ³   286 3
                   ³                         ³   386 2
                   ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context ARPL
.context @ARPL
.topic ARPL Instruction
.freeze 3
..index ARPL instruction, Adjust Requested Privilege Level
 \i\p\aDetail\v@ARPL.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Adjust Requested Privilege Level      \bFlags:\p O D I T S Z A P C
            80286-80486 Protected Only                   ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                                     ñ
  \bSyntax:\p   ARPL dest,src

  \bSee also:\p .286

  \bDescription:\p

     Verifies that the destination Requested Privilege Level (RPL)
     field (bits 0 and 1 of a selector value) is less than the source
     RPL field. If it is not, ARPL adjusts the destination RPL up to
     match the source RPL.

     The destination operand should be a 16-bit memory or register
     operand containing the value of a selector. The source operand
     should be a 16-bit register containing the test value. The zero
     flag is set if the destination is adjusted; otherwise, the flag is
     cleared.

     Use ARPL only in 80286-80486 protected mode. See Intel
     documentation for details on selectors and privilege levels.
.context @ARPL.des
.freeze 3
.topic ARPL Instruction
 \i\p\aSummary\v@ARPL\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 01100011     mod,reg,r/m       disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ARPL  reg,reg   ³ arpl  ax,cx             ³ 88/86 ÄÄ
                 ³                         ³   286 10
                 ³                         ³   386 20
                 ³                         ³   486  9
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ARPL  mem,reg   ³ arpl  selector,dx       ³ 88/86 ÄÄ
                 ³                         ³   286 11
                 ³                         ³   386 21
                 ³                         ³   486  9
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context BOUND
.context @BOUND
.topic BOUND Instruction
.freeze 3
..index BOUND instruction, Check Array Bounds
 \i\p\aDetail\v@BOUND.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Check Array Bounds                    \bFlags:\p O D I T S Z A P C
            80186-80486 Only                             ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                              -none-
  \bSyntax:\p   BOUND dest,src

  \bSee also:\p \aInt 05h\v@5h\v, IRET, .186

  \bDescription:\p

     Verifies that a signed index value is within the bounds of an
     array. The destination operand can be any 16-bit register
     containing the index to be checked. The source operand must then
     be a 32-bit memory operand in which the low and high words contain
     the starting and ending values, respectively, of the array.

     On the 80386/486 processors, the destination operand can be a
     32-bit register; in this case, the source operand must be a 64-bit
     operand made up of 32-bit bounds.

     If the source operand is less than the first bound or greater than
     the last bound, an interrupt 05h is generated. The instruction
     pointer pushed by the interrupt (and returned by IRET) points to
     the BOUND instruction rather than to the next instruction.
.context @BOUND.des
.freeze 3
.topic BOUND Instruction
 \i\p\aSummary\v@BOUND\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 01100010     mod,reg,r/m      disp (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 BOUND  reg16,mem32    ³ bound di,base-4     ³ 88/86 ÄÄ
 BOUND  reg32,mem64*   ³                     ³ 286   noj=13 
                       ³                     ³ 386   noj=10 
                       ³                     ³ 486   noj=7
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 80386/486 only.

    See the INT instruction for timings if Int 05h is called.
.context BSF
.context @BSF
.context BSR
.context @BSR
.topic BSF/BSR Instruction
.freeze 3
..index BSF instruction, Bit Scan Forward
..index BSR instruction, Bit Scan Reverse
 \i\p\aDetail\v@bsf.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Bit Scan                              \bFlags:\p O D I T S Z A P C
            80386/486 Only                               ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                                   ñ
  \bSyntax:\p   BSF dest,src
            BSR dest,src

  \bSee also:\p .386

  \bDescription:\p

     Scans an operand to find the first set bit. If a set bit is found,
     the zero flag is cleared and the destination operand is loaded
     with the bit index of the first set bit encountered. If no set bit is
     found, the zero flag is set.

     BSF (Bit Scan Forward) scans from bit 0 to the most significant
     bit. BSR (Bit Scan Reverse) scans from the most significant bit of
     an operand to bit 0.

.context @bsf.des
.freeze 3
.topic BSF/BSR Instruction
 \i\p\aSummary\v@BSF\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     10111100     mod,reg,r/m       disp (0, 1, 2, or 4)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 BSF  reg16,reg16  ³ bsf   cx,bx             ³ 88/86 ÄÄ
 BSF  reg32,reg32  ³                         ³   286 ÄÄ
                   ³                         ³   386 10+3n 
                   ³                         ³   486 6-42*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 BSF  reg16,mem16  ³ bsf   ecx,bitmask       ³ 88/86 ÄÄ
 BSF  reg32,mem32  ³                         ³   286 ÄÄ
                   ³                         ³   386 10+3n 
                   ³                         ³   486 7-43 
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     10111101     mod,reg,r/m       disp (0, 1, 2, or 4)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 BSR  reg16,reg16  ³  bsr   cx,dx            ³ 88/86 ÄÄ
 BSR  reg32,reg32  ³                         ³   286 ÄÄ
                   ³                         ³   386 10+3n 
                   ³                         ³   486 103-3n#
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 BSR  reg16,mem16  ³  bsr   eax,bitmask      ³ 88/86 ÄÄ
 BSR  reg32,mem32  ³                         ³   286 ÄÄ
                   ³                         ³   386 10+3n 
                   ³                         ³   486 104-3n#
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * Clocks = 8 +
             4 for each byte scanned +
             3 for each nibble scanned in last byte +
             3 for each bit scanned in last nibble
          or 6 if second operand equals 0

    Same as footnote above, but add 1 clock.

    n = Bit position from 0 to 31
    Clocks = 6 if second operand equals 0

  # n = Bit position from 0 to 31
    Clocks = 7 if second operand equals 0

.context BSWAP
.context @BSWAP
.topic BSWAP Instruction
.freeze 3
..index BSWAP instruction, Byte Swap
 \i\p\aDetail\v@BSWAP.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 
  \bTitle:\p    Byte Swap                             \bFlags:\p O D I T S Z A P C
            80486 Only                                   ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                              -none-
  \bSyntax:\p   BSWAP register

  \bSee also:\p .486

  \bDescription:\p

     Takes a single 32-bit register as operand and exchanges the first
     byte with the fourth and the second byte with the third.

     This instruction does not alter any bit values within the bytes.
     Use BSWAP to translate quickly between 8086-family byte storage
     and storage schemes in which the high byte is stored first.

.context @BSWAP.des
.topic BSWAP Instruction
.freeze 3
 \i\p\aSummary\v@BSWAP\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     11001reg
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 BSWAP reg32           ³ bswap  eax                ³ 88/86 ÄÄ
                       ³ bswap  ebx                ³ 286   ÄÄ
                       ³                           ³ 386   ÄÄ
                       ³                           ³ 486   1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

.context BT
.context @BT
.context BTC
.context @BTC
.context BTR
.context @BTR
.context BTS
.context @BTS
.topic BT Instruction
.freeze 3
..index BT instruction, Bit Test
..index BTC instruction, Bit Test (Complement)
..index BTR instruction, Bit Test (Reset)
..index BTS instruction, Bit Test (Set)
 \i\p\aDetail\v@BT.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Bit Tests                             \bFlags:\p O D I T S Z A P C
            80386/486 Only                               ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                                         ñ
  \bSyntax:\p   BT dest,src
            BTC dest,src
            BTR dest,src
            BTS dest,src

  \bSee also:\p .386

  \bDescription:\p

     Copies the value of a specified bit into the carry flag, where it
     can be tested by a JC or JNC instruction. The destination operand
     specifies the value in which the bit is located; the source
     operand specifies the bit position.

     BT copies the bit to the flag. BTC copies the bit and complements
     (toggles) it in the destination. BTR copies the bit and resets
     (clears) it in the destination. BTS copies the bit and sets it in
     the destination.

.context @BT.des
.freeze 3
.topic BT Instruction
 \i\p\aSummary\v@BT\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    10111010    mod,BBB*,r/m   disp (0, 1, 2, or 4)   data (1)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 BT   reg16,immed8  ³ bt   ax,4               ³ 88/86 ÄÄ
                    ³                         ³   286 ÄÄ
                    ³                         ³   386 3
                    ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 BTC  reg16,immed8  ³ bts  ax,4               ³ 88/86 ÄÄ
 BTR  reg16,immed8  ³ btr  bx,17              ³   286 ÄÄ
 BTS  reg16,immed8  ³ btc  edi,4              ³   386 6
                    ³                         ³   486 6
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 BT   mem16,immed8  ³ btr  DWORD PTR [si],27  ³ 88/86 ÄÄ
                    ³ btc  color[di],4        ³   286 ÄÄ
                    ³                         ³   386 6
                    ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 BTC  mem16,immed8  ³ btc  DWORD PTR [bx],27  ³ 88/86 ÄÄ
 BTR  mem16,immed8  ³ btc  maskit,4           ³   286 ÄÄ
 BTS  mem16,immed8  ³ btr  color[di],4        ³   386 8
                    ³                         ³   486 8
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    10BBB011*   mod,reg,r/m    disp (0, 1, 2, or 4)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 BT   reg16,reg16   ³ bt   ax,bx              ³ 88/86 ÄÄ
                    ³                         ³   286 ÄÄ
                    ³                         ³   386 3
                    ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 BTC  reg16,reg16   ³ btc  eax,ebx            ³ 88/86 ÄÄ
 BTR  reg16,reg16   ³ bts  bx,ax              ³   286 ÄÄ
 BTS  reg16,reg16   ³ btr  cx,di              ³   386 6
                    ³                         ³   486 6
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 BT   mem16,reg16   ³ bt   [bx],dx            ³ 88/86 ÄÄ
                    ³                         ³   286 ÄÄ
                    ³                         ³   386 12
                    ³                         ³   486 8
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 BTC  mem16,reg16   ³ bts  flags[bx],cx       ³ 88/86 ÄÄ
 BTR  mem16,reg16   ³ btr  rotate,cx          ³   286 ÄÄ
 BTS  mem16,reg16   ³ btc  [bp+8],si          ³   386 13
                    ³                         ³   486 13
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * BBB is 100 for BT, 111 for BTC, 110 for BTR, and 101 for BTS.

    Operands can also be 32 bits (reg32 and mem32).

.context CALL
.context @CALL
.topic CALL Instruction
.freeze 3
..index subroutines,, calling
..index jump unconditionally, CALL Instruction
..index CALL instruction, Call Subroutine
 \i\p\aDetail\v@CALL.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@Veriansi.asx\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Call Procedure                        \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   CALL dest                                         -none-

  \bSee also:\p INVOKE, JMP, RET, PROC, PROTO

  \bDescription:\p

     Calls a procedure. This instruction pushes the address of the next
     instruction onto the stack and jumps to the address specified by
     the operand. For NEAR calls, SP is decreased by 2, the offset (IP)
     is pushed, and the new offset is loaded into IP.

     For FAR calls, SP is decreased by 2, the segment (CS) is pushed,
     and the new segment is loaded into CS. Then SP is decreased by 2
     again, the offset (IP) is pushed, and the new offset is loaded
     into IP. A subsequent RET instruction can pop the address so that
     execution continues with the instruction following the call.
.context @CALL.des
.freeze 3
.topic CALL Instruction
 \i\p\aSummary\v@CALL\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@Veriansi.asx\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11101000       disp (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CALL  label     ³ call  upcase            ³ 88/86 19 (88=23)
                 ³                         ³   286 7+m
                 ³                         ³   386 7+m
                 ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 10011010       disp (4)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CALL  label     ³ call  FAR PTR job       ³ 88/86 28 (88=36)
                 ³ call  distant           ³   286 13+m,pm=26+m*
                 ³                         ³   386 17+m,pm=34+m*
                 ³                         ³   486 18,pm=20*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11111111       mod,010,r/m      disp (0 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CALL  reg       ³ call  ax                ³ 88/86 16 (88=20)
                 ³                         ³   286 7+m
                 ³                         ³   386 7+m
                 ³                         ³   486 5
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CALL  mem16     ³ call  pointer           ³ 88/86 21+EA (88=29+EA)
 CALL  mem32     ³ call  [bx]              ³   286 11+m
                 ³                         ³   386 10+m
                 ³                         ³   486 5
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11111111       mod,011,r/m      disp (4)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CALL  mem32     ³ call  far_table[di]     ³ 88/86 37+EA (88=53+EA)
 CALL  mem48     ³ call  DWORD PTR [bx]    ³   286 16+m,pm=29+m*
                 ³                         ³   386 22+m,pm=38+m*
                 ³                         ³   486 17,pm=20*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * Timings for calls through call and task gates are not shown, since
    they are used primarily in operating systems.

    80386/486 32-bit addressing mode only.
.context CBW
.context @CBW
.context CWD
.context CWDE
.context CDQ
.topic CBW/CWD Instruction
..index CBW instruction, Convert Byte to Word
..index CWD instruction, Convert Word to Doubleword
..index CWDE instruction, Convert Word to Doubleword (EAX)
..index CDQ instruction, Convert Doubleword to Quadword
 \i\p\aDetail\v@CBW.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@GetCurDr.asx\v\i\p                    \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Convert Data                          \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   CBW                                               -none-
            CWD
            CWDE (80386/486 Only)
            CDQ  (80386/486 Only)

  \bSee also:\p MOVSX, MOVZX

  \bDescription:\p

     CBW converts a signed byte in AL to a signed word in AX by
     extending the sign bit of AL into all bits of AH.

     CWD converts the signed word in AX to a signed word in the DX:AX
     register pair by extending the sign bit of AX into all bits of DX.

     CWDE converts a signed word in AX to a signed doubleword in EAX
     by extending the sign bit of AX into all bits of EAX.

     CDQ converts the signed doubleword in EAX to a signed quadword in
     the EDX:EAX register pair by extending the sign bit of EAX into
     all bits of EDX.

.context @CBW.des
.freeze 3
.topic CBW/CWD Instruction
 \i\p\aSummary\v@CBW\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@GetCurDr.asx\v\i\p                    \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 10011000*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CBW             ³ cbw                     ³ 88/86 2
                 ³                         ³   286 2
                 ³                         ³   386 3
                 ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CWDE            ³ cwde                    ³ 88/86 ÄÄ
                 ³                         ³   286 ÄÄ
                 ³                         ³   386 3
                 ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 10011001*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CWD             ³ cwd                     ³ 88/86 5
                 ³                         ³   286 2
                 ³                         ³   386 2
                 ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CDQ             ³ cdq                     ³ 88/86 ÄÄ
                 ³                         ³   286 ÄÄ
                 ³                         ³   386 2
                 ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * CBW and CWDE have the same encoding, and CWD and CDQ have the
    same encoding. The only difference is that in 32-bit mode CBW and
    CWD are preceded by the operand-size byte (66h), but CWDE and CDQ
    are not.

    In 16-bit mode, CWDE and CDQ are preceded by the operand-size byte,
    but CBW and CWD are not.

.context CLC
.context @CLC
.context STC
.context CMC
.topic CLC/STC/CMC Instruction
.freeze 3
..index CLC instruction, Clear Carry Flag
..index STC instruction, Modify Carry Flag
..index CMC instruction, Complement Carry Flag
 \i\p\aDetail\v@CLC.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@CopyFile.asx\v\i\p                    \i\p\aUp\v@FlagInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Modify Carry Flag                     \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   CLC                                                          ñ
            STC
            CMC

  \bDescription:\p

     CLC clears the carry flag; STC sets it; and CMC complements
     (toggles) it.

.context @CLC.des
.freeze 3
.topic CLC/STC/CMC Instruction
 \i\p\aSummary\v@CLC\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@CopyFile.asx\v\i\p                    \i\p\aUp\v@FlagInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11111000
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CLC             ³ clc                     ³ 88/86 2
                 ³                         ³   286 2
                 ³                         ³   386 2
                 ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11111001
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 STC             ³ stc                     ³ 88/86 2
                 ³                         ³   286 2
                 ³                         ³   386 2
                 ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11110101
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CMC             ³ cmc                     ³ 88/86 2
                 ³                         ³   286 2
                 ³                         ³   386 2
                 ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context CLD
.context @CLD
.context STD
.topic CLD/STD Instruction
.freeze 3
..index CLD instruction, Clear Direction Flag
..index STD instruction, Set Direction Flag
 \i\p\aDetail\v@CLD.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@StrFindC.asx\v\i\p                    \i\p\aUp\v@FlagInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Clear or Set Direction Flag           \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   CLD                                            ñ
            STD

  \bSee also:\p MOVS, CMPS, SCAS, LODS, STOS

  \bDescription:\p

     CLD clears the direction flag. All subsequent string instructions
     will process up (from low addresses to high addresses) by
     increasing the appropriate index registers.

     STD sets the direction flag. All subsequent string instructions
     will process down (from high addresses to low addresses).
.context @CLD.des
.freeze 3
.topic CLD/STD Instruction
 \i\p\aSummary\v@CLD\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@StrFindC.asx\v\i\p                    \i\p\aUp\v@FlagInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11111100
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CLD             ³ cld                      ³ 88/86 2
                 ³                          ³   286 2
                 ³                          ³   386 2
                 ³                          ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11111101
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 STD             ³ std                      ³ 88/86 2
                 ³                          ³   286 2
                 ³                          ³   386 2
                 ³                          ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context CLI
.context @CLI
.context STI
.topic CLI/STI Instruction
.freeze 3
..index interrupts,, enabling, STI Instruction
..index enabling interrupts, SLI Instruction
..index disabling interrupts, CLI Instruction
..index CLI instruction, Clear Interrupt Flag
..index STI instruction, Set Interrupt Flag
 \i\p\aDetail\v@CLI.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@DisableC.asx\v\i\p                    \i\p\aUp\v@FlagInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Clear or Set Interrupt Flag           \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   CLI                                              ñ
            STI

  \bDescription:\p

     CLI clears the interrupt flag; STI sets it. When the interrupt
     flag is cleared, pending maskable interrupts are not recognized
     immediately; they will be executed after the instruction
     following an STI instruction.

     In protected mode, CLI only clears the flag if the current task's
     privilege level is less than or equal to the value of the IOPL
     flag. Otherwise, a general-protection fault occurs.
.context @CLI.des
.freeze 3
.topic CLI/STI Instruction
 \i\p\aSummary\v@CLI\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@DisableC.asx\v\i\p                    \i\p\aUp\v@FlagInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11111010
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CLI             ³ cli                     ³ 88/86 2
                 ³                         ³   286 3
                 ³                         ³   386 3
                 ³                         ³   486 5
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11111011
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 STI             ³ sti                     ³ 88/86 2
                 ³                         ³   286 2
                 ³                         ³   386 3
                 ³                         ³   486 5
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context CLTS
.context @CLTS
.topic CLTS Instruction
.freeze 3
..index CLTS instruction, Clear Task-Switched Flag
 \i\p\aDetail\v@CLTS.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Clear Task-Switched Flag              \bFlags:\p O D I T S Z A P C
            80286-80486 Privileged Only                  ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                              -none-
  \bSyntax:\p   CLTS

  \bSee also:\p .286P

  \bDescription:\p

     Clears the task-switched flag in the Machine Status Word (MSW) of
     the 80286 or the CR0 register of the 80386/486.

     Use this instruction only in systems software executing at
     privilege level 0. See Intel documentation for details on the task-
     switched flag and other privileged-mode concepts.

.context @CLTS.des
.freeze 3
.topic CLTS Instruction
 \i\p\aSummary\v@CLTS\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     00000110
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CLTS            ³ clts                    ³ 88/86 ÄÄ
                 ³                         ³   286 2
                 ³                         ³   386 5
                 ³                         ³   486 7
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

.context CMP
.context @CMP
.topic CMP Instruction
.freeze 3
..index comparing
..index CMP instruction, Compare Two Operands
 \i\p\aDetail\v@CMP.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@SetLineM.asx\v\i\p                     \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Compare Two Operands                  \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   CMP dest,src                                 ñ       ñ ñ ñ ñ ñ

  \bSee also:\p TEST, \aJcond\v@Jcond\v, CMPS, SUB, CMPXCHG

  \bDescription:\p

     Compares two operands as a test for a subsequent conditional jump
     or set instruction. CMP does this by subtracting the source
     operand from the destination operand and setting the flags
     according to the result.

     CMP is the same as the SUB instruction, except that the result is
     not stored.
.context @CMP.des
.freeze 3
.topic CMP Instruction
 \i\p\aSummary\v@CMP\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@SetLineM.asx\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 001110dw    mod,reg,r/m       disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CMP  reg,reg    ³ cmp   di,bx             ³ 88/86 3
                 ³ cmp   dl,cl             ³   286 2
                 ³                         ³   386 2
                 ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CMP  mem,reg    ³ cmp   maximum,dx        ³ 88/86 9+EA (W88=13+EA)
                 ³ cmp   array[si],bl      ³   286 7
                 ³                         ³   386 5
                 ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CMP  reg,mem    ³ cmp   dx,minimum        ³ 88/86 9+EA (W88=13+EA)
                 ³ cmp   bh,array[si]      ³   286 6
                 ³                         ³   386 6
                 ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 100000sw    mod,111,r/m       disp (0, 1, or 2)     data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CMP  reg,immed  ³ cmp   bx,24             ³ 88/86 4
                 ³                         ³   286 3
                 ³                         ³   386 2
                 ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CMP  mem,immed  ³ cmp   WORD PTR [di],4   ³ 88/86 10+EA (W88=14+EA)
                 ³ cmp   tester,4000       ³   286 6
                 ³                         ³   386 5
                 ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 0011110w    data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CMP  accum,immed³ cmp   ax,1000           ³ 88/86 4
                 ³                         ³   286 3
                 ³                         ³   386 2
                 ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context CMPS
.context @CMPS
.context CMPSB
.context @CMPSB
.context CMPSW
.context @CMPSW
.context CMPSD
.context @CMPSD
.topic CMPS Instruction
.freeze 3
..index CMPS instruction, Compare String
..index CMPSB instruction, Compare String (Bytes)
..index CMPSW instruction, Compare String (Words)
..index CMPSD instruction, Compare String (Doublewords)
 \i\p\aDetail\v@CMPS.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@StrCompa.asx\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Compare String                        \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   CMPS dest,src                                ñ       ñ ñ ñ ñ ñ
            CMPSB
            CMPSW
            CMPSD (80386/486 Only)

  \bSee also:\p REPE, SCAS, JCXZ, CLD, CMP

  \bDescription:\p

     Compares two strings. DS:SI must point to the source string and
     ES:DI must point to the destination string (even if operands are
     given). For each comparison, the destination element is subtracted
     from the source element and the flags are updated to reflect the
     result (although the result is not stored).

     DI and SI are adjusted according to the size of the operands and
     the status of the direction flag. They are increased if the
     direction flag has been cleared with CLD, or decreased if the
     direction flag has been set with STD.

     If the CMPS form of the instruction is used, operands must be
     provided to indicate the size of the data elements to be
     processed. A segment override can be given for the source (but not
     for the destination). If CMPSB (bytes), CMPSW (words), or CMPSD
     (doublewords) is used, the instruction determines the size of the
     data elements to be processed.

     CMPS and its variations are normally used with repeat prefixes:
     REPNE (or REPNZ) finds the first match between two strings; REPE
     (or REPZ) finds the first mismatch.

     Before the comparison, CX should contain the maximum number of
     elements to compare. After a REPNE CMPS, the zero flag is
     clear if no match was found. After REPE CMPS, the zero flag
     is set if no mismatch was found. Otherwise, SI and DI will
     point to the element after the first match or nonmatch.

     When the instruction finishes, ES:DI and DS:SI point to the
     element that follows (if the direction flag is clear) or
     precedes (if the direction flag is set) the match or mismatch.
     If CX decrements to 0, ES:DI and DS:SI point to the element
     that follows or precedes the last comparison. The zero flag is
     set or clear according to the result of the last comparison, not
     according to the value of CX.

.context @CMPS.des
.freeze 3
.topic CMPS Instruction
 \i\p\aSummary\v@CMPS\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@StrCompa.asx\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1010011w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CMPS  [segreg:]src,[ES:]dest  ³cmps  source,es:dest³ 88/86 22 (W88=30)
 CMPSB [[segreg:]src,[ES:]dest]³repne cmpsw         ³   286 8
 CMPSW [[segreg:]src,[ES:]dest]³repe  cmpsb         ³   386 10
 CMPSD [[segreg:]src,[ES:]dest]³repne cmpsd         ³   486 8
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context CMPXCHG
.context @CMPXCHG
.topic CMPXCHG Instruction
.freeze 3
..index CMPXCHG instruction, Compare and Exchange
 \i\p\aDetail\v@CMPXCHG.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Compare and Exchange                  \bFlags:\p O D I T S Z A P C
            80486 Only                                   ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                         ñ       ñ ñ ñ ñ ñ
  \bSyntax:\p   CMPXCHG dest,src

  \bSee also:\p .486, CMP, XCHG

  \bDescription:\p
  
     Compares the destination operand to the accumulator (AL, AX, or
     EAX). If equal, the source operand is copied to the destination.
     Otherwise, the destination is copied to the accumulator. The
     instruction sets flags according to the result of the comparison.


.context @CMPXCHG.des
.freeze 3
.topic CMPXCHG Instruction
 \i\p\aSummary\v@CMPXCHG\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     1011000b     mod,reg,r/m     disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CMPXCHG mem,reg        ³ cmpxchg  warr[bx],cx      ³ 88/86 ÄÄ
                        ³ cmpxchg  string,bl        ³   286 ÄÄ
                        ³                           ³   386 ÄÄ
                        ³                           ³   486 7-10
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 CMPXCHG reg,reg        ³ cmpxchg  dl,cl            ³ 88/86 ÄÄ
                        ³ cmpxchg  bx,dx            ³   286 ÄÄ
                        ³                           ³   386 ÄÄ
                        ³                           ³   486 6
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context DAA
.context @DAA
.topic DAA Instruction
.freeze 3
..index DAA instruction, Decimal Adjust after Addition
 \i\p\aDetail\v@DAA.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@BCDInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Decimal Adjust after Addition         \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   DAA                                          ?       ñ ñ ñ ñ ñ

  \bSee also:\p DAS, AAA, AAS, AAM, AAD

  \bDescription:\p

     Adjusts the result of an addition to a packed BCD number (less
     than 100 decimal). The previous addition instruction should place
     its 8-bit binary sum in AL. DAA converts this binary sum to packed
     BCD format with the least significant decimal digit in the lower
     four bits and the most significant digit in the upper four bits.

     If the sum is greater than 99h after adjustment, the carry
     and auxiliary carry flags are set. Otherwise, the carry and
     auxiliary carry flags are cleared.
.context @DAA.des
.freeze 3
.topic DAA Instruction
 \i\p\aSummary\v@DAA\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@BCDInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00100111
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 DAA              ³ daa                     ³ 88/86 4
                  ³                         ³   286 3
                  ³                         ³   386 4
                  ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context DAS
.context @DAS
.topic DAS Instruction
.freeze 3
..index DAS instruction, Decimal Adjust after Subtraction
 \i\p\aDetail\v@DAS.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@BCDInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Decimal Adjust after Subtraction      \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   DAS                                          ?       ñ ñ ñ ñ ñ

  \bSee also:\p DAA, AAA, AAS, AAM, AAD

  \bDescription:\p

     Adjusts the result of an 8-bit subtraction to a packed BCD number
     (less than 100 decimal). DAS converts this result to packed BCD
     format with the least significant decimal digit in the lower four
     bits and the most significant digit in the upper four bits.

     If the sum is greater than 99h after adjustment, the carry
     and auxiliary carry flags are set. Otherwise, the carry and
     auxiliary carry flags are cleared.

.context @DAS.des
.freeze 3
.topic DAS Instruction
 \i\p\aSummary\v@DAS\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@BCDInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00101111
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 DAS              ³ das                     ³ 88/86 4
                  ³                         ³   286 3
                  ³                         ³   386 4
                  ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context DEC
.context @DEC
.topic DEC Instruction
.freeze 3
..index DEC instruction, Decrement
 \i\p\aDetail\v@DEC.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@WriteFil.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Decrement                             \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   DEC dest                                     ñ       ñ ñ ñ ñ

  \bSee also:\p INC, ADD, SUB

  \bDescription:\p

     Subtracts 1 from the destination operand. Because the operand is
     treated as an unsigned integer, the DEC instruction does not
     affect the carry flag. To detect any effects on the carry flag,
     use the SUB instruction.
.context @DEC.des
.freeze 3
.topic DEC Instruction
 \i\p\aSummary\v@DEC\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@Writefil.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1111111w    mod,001,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 DEC  reg8        ³ dec   cl                ³ 88/86 3
                  ³                         ³   286 2
                  ³                         ³   386 2
                  ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 DEC  mem         ³ dec   counter           ³ 88/86 15+EA (W88=23+EA)
                  ³                         ³   286 7
                  ³                         ³   386 6
                  ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 01001reg
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 DEC  reg16       ³ dec   ax                ³ 88/86 3
 DEC  reg32*      ³                         ³   286 2
                  ³                         ³   386 2
                  ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 80386/486 only.
.context DIV
.context @DIV
.topic DIV Instruction
.freeze 3
..index unsigned divide
..index DIV instruction, Unsigned Divide
 \i\p\aDetail\v@DIV.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@DivLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Unsigned Divide                       \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   DIV src                                      ?       ? ? ? ? ?

  \bSee also:\p IDIV, MUL, SHR

  \bDescription:\p

     Divides an implied destination operand by a specified source
     operand. Both operands are treated as unsigned numbers. If the
     source (divisor) is 16 bits wide, the implied destination
     (dividend) is the DX:AX register pair.

     The quotient goes into AX and the remainder into DX. If the
     source is 8 bits wide, the implied destination operand is
     AX. The quotient goes into AL and the remainder into AH. On the
     80386/486, if the source is EAX, the quotient goes into EAX and
     the remainder into EDX.

.context @DIV.des
.freeze 3
.topic DIV Instruction
 \i\p\aSummary\v@DIV\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@DivLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1111011w    mod,110,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 DIV  reg      ³ div   cx                ³ 88/86 b=80-90,w=144-162
               ³ div   dl                ³   286 b=14,w=22
               ³                         ³   386 b=14,w=22,d=38
               ³                         ³   486 b=16,w=24,d=40
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 DIV  mem      ³ div   [bx]              ³ 88/86 (b=86-96,w=150-168)+EA*
               ³ div   fsize             ³   286 b=17,w=25
               ³                         ³   386 b=17,w=25,d=41
               ³                         ³   486 b=16,w=24,d=40
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * Word memory operands on the 8088 take (158-176)+EA clocks.
.context ENTER
.context @ENTER
.context LEAVE
.topic ENTER/LEAVE Instructions
.freeze 3
..index ENTER instruction, Create Stack Frame
..index LEAVE instruction, Destroy Stack Frame
 \i\p\aDetail\v@ENTER.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Make or Destroy Stack Frame           \bFlags:\p O D I T S Z A P C
            80186-80486 Only                             ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                              -none-
  \bSyntax:\p   ENTER bytes,level
            LEAVE

  \bSee also:\p .186, PROC, PUSH, POP, RET, PROTO, INVOKE

  \bDescription:\p

     ENTER creates a stack frame for a procedure that receives
     parameters passed on the stack. When <level> is 0, ENTER is
     equivalent to push bp, followed by mov bp,sp.

     The first operand of the ENTER instruction specifies the number of
     bytes to reserve for local variables. The second operand specifies
     the nesting level for the procedure. The nesting level should be 0
     for languages that do not allow access to local variables of
     higher-level procedures (such as C, Basic, and FORTRAN).

     LEAVE terminates the stack frame of a procedure. This instruction
     also reverses the action of a previous ENTER instruction by
     restoring SP and BP to the values they had before the procedure
     stack frame was initialized. LEAVE is equivalent to mov sp,bp,
     followed by pop bp.
.context @ENTER.des
.freeze 3
.topic ENTER/LEAVE Instructions
 \i\p\aSummary\v@ENTER\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11001000       data (2)     data (1)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ENTER  immed16,0       ³ enter 4,0            ³ 88/86 ÄÄ
                        ³                      ³   286 11
                        ³                      ³   386 10
                        ³                      ³   486 14
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ENTER  immed16,1       ³ enter 0,1            ³ 88/86 ÄÄ
                        ³                      ³   286 15
                        ³                      ³   386 12
                        ³                      ³   486 17
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ENTER  immed16,immed8  ³ enter 6,4            ³ 88/86 ÄÄ
                        ³                      ³   286 12+4(n-1)
                        ³                      ³   386 15+4(n-1)
                        ³                      ³   486 17+3n
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11001001
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LEAVE                  ³ leave                ³ 88/86 ÄÄ
                        ³                      ³   286 5
                        ³                      ³   386 4
                        ³                      ³   486 5
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context ESC
.topic ESC Instruction
.freeze 3
                                             \i\p\aUp\v@contents\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p
\i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  The ESC (Escape) instruction is no longer supported. All numeric
  coprocessor instructions are now supported directly by the assembler.
.context HLT
.context @HLT
.topic HLT Instruction
.freeze 3
..index HLT instruction, Halt
 \i\p\aDetail\v@HLT.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Halt                                  \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   HLT                                               -none-

  \bDescription:\p

     Stops CPU execution until an interrupt restarts execution at the
     instruction following HLT. In protected mode, this instruction
     works only in privileged mode.
.context @HLT.des
.freeze 3
.topic HLT Instruction
 \i\p\aSummary\v@HLT\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11110100
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 HLT             ³ hlt                      ³ 88/86 2
                 ³                          ³   286 2
                 ³                          ³   386 5
                 ³                          ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context IDIV
.context @IDIV
.topic IDIV Instruction
.freeze 3
..index signed divide
..index IDIV instruction, Signed Divide
 \i\p\aDetail\v@IDIV.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@IdivLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Signed Divide                         \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   IDIV src                                     ?       ? ? ? ? ?

  \bSee also:\p DIV, IMUL, MUL, SAR

  \bDescription:\p

     Divides an implied destination operand by a specified source
     operand. Both operands are treated as signed numbers. If the
     source (divisor) is 16 bits wide, the implied destination
     (dividend) is the DX:AX register pair.

     The quotient goes into AX and the remainder goes into DX. If the
     source is 8 bits wide, the implied destination is AX. The quotient
     goes into AL and the remainder into AH. On the 80386/486, if the
     source is EAX, the quotient goes into EAX and the remainder
     into EDX.

.context @IDIV.des
.freeze 3
.topic IDIV Instruction
 \i\p\aSummary\v@IDIV\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@IdivLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1111011w     mod,111,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 IDIV  reg        ³ idiv  bx            ³ 88/86 b=101-112,w=165-184
                  ³ div   dl            ³   286 b=17,w=25
                  ³                     ³   386 b=19,w=27,d=43
                  ³                     ³   486 b=19,w=27,d=43
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 IDIV  mem        ³ idiv  itemp         ³ 88/86 (b=107-118,w=171-190)+EA*
                  ³                     ³   286 b=20,w=28
                  ³                     ³   386 b=22,w=30,d=46
                  ³                     ³   486 b=20,w=28,d=44
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * Word memory operands on the 8088 take (175-194)+EA clocks.
.context IMUL
.context @IMUL
.topic IMUL Instruction
.freeze 3
..index signed multiply
..index IMUL instruction, Signed Multiply
 \i\p\aDetail\v@IMUL.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@ImulLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Signed Multiply                       \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   IMUL src                                     ñ       ? ? ? ? ñ
            IMUL dest,const
            IMUL dest,src,const
            IMUL dest,src

  \bSee also:\p MUL, IDIV, DIV, SHL

  \bDescription:\p

     Multiplies an implied destination operand by a specified source
     operand. Both operands are treated as signed numbers. If a single
     16-bit operand is given, the implied destination is AX and the
     product goes into the DX:AX register pair. If a single 8-bit
     operand is given, the implied destination is AL and the product
     goes into AX.

     On the 80386/486, if the operand is EAX, the product goes into the
     EDX:EAX register pair. The carry and overflow flags are set if the
     product is sign-extended into DX for 16-bit operands, into AH for
     8-bit operands, or into EDX for 32-bit operands.

     Two additional syntaxes are available on the 80186-80486
     processors. In the two-operand form, a 16-bit register gives one
     of the factors and serves as the destination for the result; a
     source constant specifies the other factor.

     In the three-operand form, the first operand is a 16-bit register
     where the result will be stored; the second is a 16-bit register
     or memory operand containing one of the factors; and the third is
     a constant representing the other factor.

     With both variations, the overflow and carry flags are set if the
     result is too large to fit into the 16-bit destination register.
     Since the low 16 bits of the product are the same for both signed
     and unsigned multiplication, these syntaxes can be used for either
     signed or unsigned numbers. On the 80386/486, the operands can be
     either 16 or 32 bits wide.

     A fourth syntax is available on the 80386/486. Both the source and
     destination operands can be given specifically. The source can be
     any 16- or 32-bit memory operand or general-purpose register. The
     destination can be any general-purpose register of the same size.
     The overflow and carry flags are set if the product does not fit
     in the destination.
.context @IMUL.des
.freeze 3
.topic IMUL Instruction
 \i\p\aSummary\v@IMUL\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@ImulLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1111011w     mod,101,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 IMUL  reg                ³imul  dx        ³ 88/86 b=80-98,w=128-154
                          ³                ³   286 b=13,w=21
                          ³                ³   386 b=9-14,w=9-22,d=9-38*
                          ³                ³   486 b=13-18,w=13-26,d=13-42
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 IMUL  mem                ³imul  factor    ³ 88/86 (b=86-104,w=134-160)+EA 
                          ³                ³   286 b=16,w=24
                          ³                ³   386 b=12-17,w=12-25,d=12-41*
                          ³                ³   486 b=13-18,w=13-26,d=13-42
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * The 80386/486 has an early-out multiplication algorithm. Therefore,
    multiplying an 8-bit or 16-bit value in EAX takes the same time as
    multiplying the value in AL or AX.

    Word memory operands on the 8088 take (138-164)+EA clocks.

 011010s1     mod,reg,r/m      disp (0, 1, or 2)     data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 IMUL  reg16,immed        ³imul  cx,25     ³ 88/86 ÄÄ
 IMUL  reg32,immed*       ³                ³   286 21
                          ³                ³   386 b=9-14,w=9-22,d=9-38 
                          ³                ³   486 b=13-18,w=13-26,d=13-42
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 IMUL  reg16,reg16,immed  ³imul  dx,ax,18  ³ 88/86 ÄÄ
 IMUL  reg32,reg32,immed* ³                ³   286 21
                          ³                ³   386 b=9-14,w=9-22,d=9-38 
                          ³                ³   486 b=13-18,w=13-26,d=13-42
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 IMUL  reg16,mem16,immed  ³imul  bx,[si],60³ 88/86 ÄÄ
 IMUL  reg32,mem32,immed* ³                ³   286 24
                          ³                ³   386 b=12-17,w=12-25,d=12-41 
                          ³                ³   486 b=13-18,w=13-26,d=13-42
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 80386/486 only.

    The variations depend on the source constant size; destination
    size is not a factor.

 00001111     10101111         mod,reg,r/m       disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 IMUL  reg16,reg16        ³imul  cx,ax     ³ 88/86 ÄÄ
 IMUL  reg32,reg32*       ³                ³   286 ÄÄ
                          ³                ³   386 w=9-22,d=9-38
                          ³                ³   486 b=13-18,w=13-26,d=13-42
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 IMUL  reg16,mem16        ³imul  dx,[si]   ³ 88/86 ÄÄ
 IMUL  reg32,mem32*       ³                ³   286 ÄÄ
                          ³                ³   386 w=12-25,d=12-41
                          ³                ³   486 b=13-18,w=13-26,d=13-42
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 80386/486 only.

    The variations depend on the source constant size; destination
    size is not a factor.

.context IN
.context @IN
.topic IN Instruction
.freeze 3
..index IN instruction, Input from Port
 \i\p\aDetail\v@IN.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@Sound.asx\v\i\p                    \i\p\aUp\v@IOInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Input from Port                       \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   IN accumulator,port                               -none-

  \bSee also:\p OUT, INS, OUTS

  \bDescription:\p

     Transfers a byte or word (or doubleword on the 80386/486) from a
     port to the accumulator register. The port address is specified by
     the source operand, which can be DX or an 8-bit constant.

     Constants can only be used for port numbers less than 255; use DX
     for higher port numbers.

     In protected mode, a general-protection fault occurs if IN is used
     when the current privilege level is greater than the value of the
     IOPL flag.
.context @IN.des
.freeze 3
.topic IN Instruction
 \i\p\aSummary\v@IN\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@Sound.asx\v\i\p                    \i\p\aUp\v@IOInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1110010w       data (1)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 IN  accum,immed  ³ in    ax,60h            ³ 88/86 10 (W88=14)
                  ³                         ³   286 5
                  ³                         ³   386 12,pm=6,26*
                  ³                         ³   486 14,pm=9,29* 
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1110110w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 IN  accum,DX     ³ in    ax,dx             ³ 88/86 8 (W88=12)
                  ³ in    al,dx             ³   286 5
                  ³                         ³   386 13,pm=7,27*
                  ³                         ³   486 14,pm=8,28* 
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * First protected-mode timing: CPL <= IOPL. Second timing: CPL > IOPL.

    Takes 27 clocks in virtual 8086 mode.
.context INC
.context @INC
.topic INC Instruction
.freeze 3
..index INC instruction, Increment
 \i\p\aDetail\v@INC.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@WriteFil.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Increment                             \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   INC dest                                     ñ       ñ ñ ñ ñ

  \bSee also:\p DEC, SUB

  \bDescription:\p

     Adds 1 to the destination operand. Because the operand is treated
     as an unsigned integer, the INC instruction does not affect the
     carry flag. If you need to test the carry flag, use the ADD
     instruction.
.context @INC.des
.freeze 3
.topic INC Instruction
 \i\p\aSummary\v@INC\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@WriteFil.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1111111w     mod,000,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 INC  reg8        ³ inc   cl                ³ 88/86 3
                  ³                         ³   286 2
                  ³                         ³   386 2
                  ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 INC  mem         ³ inc   vpage             ³ 88/86 15+EA (W88=23+EA)
                  ³                         ³   286 7
                  ³                         ³   386 6
                  ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 01000reg
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 INC  reg16       ³ inc   bx                ³ 88/86 3
 INC  reg32*      ³                         ³   286 2
                  ³                         ³   386 2
                  ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 80386/486 only.
.context INS
.context @INS
.context INSB
.context @INSB
.context INSW
.context @INSW
.context INSD
.context @INSD
.topic INS Instruction
.freeze 3
..index INS instruction, Input from Port to String
..index INSB instruction, Input from Port to String (Bytes)
..index INSW instruction, Input from Port to String (Words)
..index INSD instruction, Input from Port to String (Doublewords)
 \i\p\aDetail\v@INS.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@IOInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Input from Port to String             \bFlags:\p O D I T S Z A P C
            80186-80486 Only                             ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                              -none-
  \bSyntax:\p   INS dest,src
            INSB
            INSW
            INSD (80386/486 Only)

  \bSee also:\p .186, OUTS, IN, OUT

  \bDescription:\p

     Receives a string from a port. The string is considered the
     destination and must be pointed to by ES:DI (even if an operand
     is given).

     The input port is specified in DX. For each element received, DI
     is adjusted according to the size of the operand and the status of
     the direction flag. DI is increased if the direction flag has been
     cleared with CLD, or decreased if the direction flag has been set
     with STD.

     If the INS form of the instruction is used, a destination operand
     must be provided to indicate the size of the data elements to be
     processed and DX must be specified as the source operand
     containing the port number. A segment override is not allowed.

     If INSB (bytes), INSW (words), or INSD (doublewords) is used, the
     instruction determines the size of the data elements to be
     received.

     INS and its variations are normally used with the REP prefix.
     Before the repeated instruction is executed, CX should contain the
     number of elements to be received. In protected mode, a general-
     protection fault occurs if INS is used when the current privilege
     level is greater than the value of the IOPL flag.

.context @INS.des
.freeze 3
.topic INS Instruction
 \i\p\aSummary\v@INS\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@IOInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 0110110w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 INS  [ES:]dest,DX  ³ ins   es:instr,dx       ³ 88/86 ÄÄ
 INSB [[ES:]dest,DX]³ rep   insb              ³   286 5
 INSW [[ES:]dest,DX]³ rep   insw              ³   386 15,pm=9,29*
 INSD [[ES:]dest,DX]³ rep   insd              ³   486 17,pm=10,32*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * First protected-mode timing: CPL <= IOPL. Second timing: CPL > IOPL.
.context INT
.context @INT
.topic INT Instruction
.freeze 3
..index INT instruction, Interrupt
 \i\p\aDetail\v@INT.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@hello.asm\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Interrupt                             \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   INT number                                       0 0

  \bSee also:\p IRET, STI, INTO, \aDOS Calls\v@DosInt\v, \aBIOS Calls\v@BiosCalls\v

  \bDescription:\p

     Generates a software interrupt. An 8-bit constant operand
     (0 to 255) specifies the interrupt procedure to be called. The
     call is made by indexing the interrupt number into the Interrupt
     Descriptor Table (IDT) starting at segment 0, offset 0.

     In real mode, the IDT contains 4-byte pointers to interrupt
     procedures. In privileged mode, the IDT contains 8-byte pointers.

     When an interrupt is called in real mode, the flags, CS, and then
     IP are pushed onto the stack, and the trap and interrupt flags are
     cleared.

     You can use STI to restore interrupts. See Intel documentation and
     your operating-system documentation for details on using and
     defining interrupts in privileged mode. To return from an
     interrupt, use the IRET instruction.
.context @INT.des
.freeze 3
.topic INT Instruction
 \i\p\aSummary\v@INT\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@Hello.asm\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11001101       data (1)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 INT  immed8      ³ int   25h               ³ 88/86 51 (88=71)
                  ³                         ³   286 23+m,pm=(40,78)+m*
                  ³                         ³   386 37,pm=59,99*
                  ³                         ³   486 30,pm=44,71*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11001100
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 INT  3           ³ int   3                 ³ 88/86 52 (88=72)
                  ³                         ³   286 23+m,pm=(40,78)+m*
                  ³                         ³   386 33,pm=59,99*
                  ³                         ³   486 26,pm=44,71*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * The first protected-mode timing is for interrupts to the same
    privilege level. The second is for interrupts to a higher privilege
    level. Timings for interrupts through task gates are not shown.
.context INTO
.context @INTO
.topic INTO Instruction
.freeze 3
..index INTO instruction, Interrupt on Overflow
 \i\p\aDetail\v@INTO.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Interrupt on Overflow                 \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   INTO                                             ñ ñ

  \bSee also:\p INT, \aInt 04h\v@4h\v

  \bDescription:\p

     Generates Interrupt 04h if the overflow flag is set.

     Under DOS, the default Int 04h service routine is null. You must
     define an interrupt procedure for Int 04h for INTO to have any
     effect.

.comment     Under OS/2, Int 04h causes an overflow error. The Int 04h
.comment     interrupt routine can be replaced by using the API call DosSetVec.
.context @INTO.des
.freeze 3
.topic INTO Instruction
 \i\p\aSummary\v@INTO\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11001110
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 INTO            ³ into             ³ 88/86 53 (88=73),noj=4
                 ³                  ³   286 24+m,noj=3,pm=(40,78)+m*
                 ³                  ³   386 35,noj=3,pm=59,99*
                 ³                  ³   486 28,noj=3,pm=46,73*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * The first protected-mode timing is for interrupts to the same
    privilege level. The second is for interrupts to a higher privilege
    level. Timings for interrupts through task gates are not shown.
.context INVD
.context @INVD
.context WBINVD
.topic INVD/WBINVD Instruction
.freeze 3
..index INVD instruction, Invalidate Data Cache
..index WBINVD instruction, Invalidate Data Cache
 \i\p\aDetail\v@INVD.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Invalidate Data Cache                 \bFlags:\p O D I T S Z A P C
            80486 Only                                   ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                              -none-
  \bSyntax:\p   INVD
            WBINVD

  \bSee also:\p .486, INVLPG

  \bDescription:\p

     INVD empties contents of the current data cache without writing
     changes to memory. WBINVD also empties contents of the current
     data cache, but first writes changes to memory.

     Proper use of these instructions requires knowledge of how
     contents are placed in the cache. INVD and WBINVD are intended
     primarily for systems programming. See Intel documentation for
     details.
.context @INVD.des
.freeze 3
.topic INVD/WBINVD Instruction
 \i\p\aSummary\v@INVD\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     00001000
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 INVD                   ³ invd                      ³ 88/86 ÄÄ
                        ³                           ³   286 ÄÄ
                        ³                           ³   386 ÄÄ
                        ³                           ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     00001001
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 WBINVD                 ³ wbinvd                    ³ 88/86 ÄÄ
                        ³                           ³   286 ÄÄ
                        ³                           ³   386 ÄÄ
                        ³                           ³   486 5
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context INVLPG
.context @INVLPG
.topic INVLPG Instruction
.freeze 3
..index INVLPG instruction, Invalidate TLB Entry
 \i\p\aDetail\v@INVLPG.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Invalidate TLB Entry                  \bFlags:\p O D I T S Z A P C
            80486 Only                                   ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                              -none-
  \bSyntax:\p   INVLPG

  \bSee also:\p .486, INVD

  \bDescription:\p

.comment     Invalidates an entry in the Translation Lookaside Buffer (TLB),
.comment     used by the demand-paging mechanism for OS/2 and other
.comment     virtual-memory systems.
     Invalidates an entry in the Translation Lookaside Buffer (TLB),
     used by the demand-paging mechanism for virtual-memory systems.

     INVLPG takes a single memory operand and calculates the effective
     address of the operand, including the segment address. If the
     resulting address is mapped by any entry in the TLB, this entry is
     removed.
  
     Proper use of this instruction requires understanding of the
     hardware-supported demand-paging mechanism. INVLPG is intended
     primarily for systems programming. See Intel documentation for
     details.

.context @INVLPG.des
.freeze 3
.topic INVLPG Instruction
 \i\p\aSummary\v@INVLPG\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     00000001     mod,reg,r/m     disp (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 INVLPG                ³ invlpg  pointer[bx]       ³ 88/86 ÄÄ
                       ³ invlpg  es:entry          ³   286 ÄÄ
                       ³                           ³   386 ÄÄ
                       ³                           ³   486 12*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 11 clocks if address is not mapped by any TLB entry.
.context IRET
.context @IRET
.context IRETD
.context IRETF
.context IRETDF
.topic IRET Instruction
.topic IRETD Instruction
.topic IRETF Instruction
.topic IRETDF Instruction
.freeze 3
..index IRET instruction, Interrupt Return
..index IRETD instruction, Interrupt Return (32-bit)
 \i\p\aDetail\v@IRET.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@NewBreak.asx\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Interrupt Return                      \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   IRET[F]                                      ñ ñ ñ ñ ñ ñ ñ ñ ñ
            IRETD[F]

  \bSee also:\p INT, PROC, OPTION EPILOGUE:

  \bDescription:\p

     Returns control from an interrupt procedure to the interrupted
     code. In real mode, the IRET instruction pops IP, CS, and the
     flags (in that order) and resumes execution. See Intel
     documentation for details on IRET operation in privileged mode.

     On the 80386/486, use the IRETD instruction to pop a 32-bit
     instruction pointer when returning from an interrupt called from
     a 32-bit segment.

     The F suffix prevents epilogue code from being generated when
     ending a PROC block. Use it to terminate interrupt service
     procedures.
.context @IRET.des
.freeze 3
.topic IRET Instruction
 \i\p\aSummary\v@IRET\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@NewBreak.asx\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11001111
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 IRET             ³ iret             ³ 88/86 32 (88=44)
 IRETD            ³                  ³   286 17+m,pm=(31,55)+m*
 IRETF            ³                  ³   386 22,pm=38,82*
 IRETDF           ³                  ³   486 15,pm=20,36
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * The first protected-mode timing is for interrupts to the same
    privilege level within a task. The second is for interrupts to a
    higher privilege level within a task. Timings for interrupts
    through task gates are not shown.

    80386/486 only.
.context JB
.context JNAE
.context JAE
.context JNB
.context JBE
.context JNA
.context JA
.context JNBE
.context JE
.context JZ
.context JNE
.context JNZ
.context JL
.context JNGE
.context JGE
.context JNL
.context JLE
.context JNG
.context JG
.context JNLE
.context JS
.context JNS
.context JC
.context JNC
.context JO
.context JNO
.context JP
.context JPE
.context @Jcond
.context JNP
.context JPO
.topic Jcondition Instruction
..index JB instruction, Jump Conditionally
..index JNAE instruction, Jump Conditionally
..index JAE instruction, Jump Conditionally
..index JNB instruction, Jump Conditionally
..index JBE instruction, Jump Conditionally
..index JNA instruction, Jump Conditionally
..index JA instruction, Jump Conditionally
..index JNBE instruction, Jump Conditionally
..index JE instruction, Jump Conditionally
..index JZ instruction, Jump Conditionally
..index JNE instruction, Jump Conditionally
..index JNZ instruction, Jump Conditionally
..index JL instruction, Jump Conditionally
..index JNGE instruction, Jump Conditionally
..index JGE instruction, Jump Conditionally
..index JNL instruction, Jump Conditionally
..index JLE instruction, Jump Conditionally
..index JNG instruction, Jump Conditionally
..index JG instruction, Jump Conditionally
..index JNLE instruction, Jump Conditionally
..index JS instruction, Jump Conditionally
..index JNS instruction, Jump Conditionally
..index JC instruction, Jump Conditionally
..index JNC instruction, Jump Conditionally
..index JO instruction, Jump Conditionally
..index JNO instruction, Jump Conditionally
..index JP instruction, Jump Conditionally
..index JPE instruction, Jump Conditionally
..index Jcond instruction, Jump Conditionally
..index JNP instruction, Jump Conditionally
..index JPO instruction, Jump Conditionally
.freeze 3
..index jump conditionally
..index Jcondition instruction, Jump Conditionally
 \i\p\aDetail\v@JB.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@jcond.asm\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Jump Conditionally                    \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   Jcondition label                                  -none-

  \bSee also:\p .IF, JMP, JCXZ, \aSETcond\v@SETcond\v, \aOPTION LJMP\v@ljmp\v

  \bDescription:\p

     Transfers execution to the specified label if the flags condition
     is true. The condition is tested by checking the flags.
     See: \i\p\aJump Conditions Table\v@JBtable\v\i\p

     If the condition is false, no jump is taken and program execution
     continues at the next instruction.

     On the 8086-80286 processors, the label given as the operand must
     be short (between -128 and +127 bytes from the instruction
     following the jump).

     The 80386/486 allows near jumps (-32,768 to +32,767 bytes). On the
     80386/486, the assembler generates the shortest jump possible,
     unless the jump size is explicitly specified.

     When the 80386/486 is in FLAT memory model, short jumps range from
     -128 to +127 bytes and near jumps range from -2 to +2 gigabytes.
     There are no far jumps.

     NOTE: If a source file for an 8086-80286 program contains a
           conditional jump beyond the range of -128 to +127 bytes, the
           assembler emits a level 3 warning and generates two
           instructions (including an unconditional jump) that are the
           equivalent of the desired instruction.

           This behavior can be enabled and disabled with the OPTION
           LJMP and OPTION NOLJMP directives.
.context @JB.des
.freeze 3
.topic Jcondition Instruction
 \i\p\aSummary\v@Jcond\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@jcond.asm\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 0111cond    disp (1)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Jcondition  label   ³ jg    bigger            ³ 88/86 16,noj=4
                     ³ jo    SHORT too_big     ³   286 7+m,noj=3
                     ³ jpe   p_even            ³   386 7+m,noj=3
                     ³                         ³   486 3,noj=1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     1000cond       disp (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 Jcondition  label*  ³ je    next              ³ 88/86 ÄÄ
                     ³ jnae  lesser            ³   286 ÄÄ
                     ³ js    negative          ³   386 7+m,noj=3
                     ³                         ³   486 3,noj=1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * Near labels are only available on the 80386/486. They are the
    default.

.context @JBtable
.freeze 3
..index conditional jumps (table)
.topic Jump Conditions
 \i\p\aSummary\v@Jcond\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@jcond.asm\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
 
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bOpcode\p      \bMnemonic\p  \bFlags Checked\p    \bDescription\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  size 0010   JB/JNAE   CF=1             Jump if below/not above or
                                         equal (unsigned comparisons)
  size 0011   JAE/JNB   CF=0             Jump if above or equal/not
                                         below (unsigned comparisons)
  size 0110   JBE/JNA   CF=1 or ZF=1     Jump if below or equal/not
                                         above (unsigned comparisons)
  size 0111   JA/JNBE   CF=0 and ZF=0    Jump if above/not below or
                                         equal (unsigned comparisons)
  size 0100   JE/JZ     ZF=1             Jump if equal (zero)
  size 0101   JNE/JNZ   ZF=0             Jump if not equal (not zero)
  size 1100   JL/JNGE   SF<>OF           Jump if less/not greater or
                                         equal (signed comparisons)
  size 1101   JGE/JNL   SF=OF            Jump if greater or equal/not
                                         less (signed comparisons)
  size 1110   JLE/JNG   ZF=1 or SF<>OF   Jump if less or equal/not
                                         greater (signed comparisons)
  size 1111   JG/JNLE   ZF=0 and SF=OF   Jump if greater/not less or
                                         equal (signed comparisons)
  size 1000   JS        SF=1             Jump if sign
  size 1001   JNS       SF=0             Jump if not sign
  size 0010   JC        CF=1             Jump if carry
  size 0011   JNC       CF=0             Jump if not carry
  size 0000   JO        OF=1             Jump if overflow
  size 0001   JNO       OF=0             Jump if not overflow
  size 1010   JP/JPE    PF=1             Jump if parity/parity even
  size 1011   JNP/JPO   PF=0             Jump if no parity/parity odd
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  NOTE: The size bits are 0111 for short jumps or 1000 for 80386/486
        near jumps.
.context JCXZ
.context @JCXZ
.context JECXZ
.context @JECXZ
.topic JCXZ/JECXZ Instruction
.freeze 3
..index loops
..index jump conditionally
..index JCXZ instruction, Jump if CX is Zero
..index JECXZ instruction, Jump if ECX is Zero
 \i\p\aDetail\v@JCXZ.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@StrCompa.asx\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Jump if CX is Zero                    \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   JCXZ label                                        -none-
            JECXZ label

  \bSee also:\p LOOP, .REPEAT, REP, \aJcond\v@Jcond\v

  \bDescription:\p

     Transfers program execution to the specified label if CX is 0. On
     the 80386/486, JECXZ can be used to jump if ECX is 0. If the count
     register is not 0, execution continues at the next instruction.
     The label given as the operand must be short (between -128 and
     +127 bytes from the instruction following the jump).
.context @JCXZ.des
.freeze 3
.topic JCXZ/JECXZ Instruction
 \i\p\aSummary\v@JCXZ\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@StrCompa.asx\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11100011       disp (1)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 JCXZ   label     ³ jcxz  notfound          ³ 88/86 18,noj=6
 JECXZ  label*    ³                         ³   286 8+m,noj=4
                  ³                         ³   386 9+m,noj=5
                  ³                         ³   486 8,noj=5
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 80386/486 only.
.context JMP
.context @JMP
.topic JMP Instruction
..index jump unconditionally, JMP Instruction
..index JMP instruction, Jump Unconditionally
.freeze 3
 \i\p\aDetail\v@JMP.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@jump.asm\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Jump Unconditionally                  \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   JMP dest                                          -none-

  \bSee also:\p \aJcond\v@Jcond\v, JCXZ, CALL

  \bDescription:\p

     Transfers program execution to the address specified by the
     destination operand. Jumps are near (between -32,768 and +32,767
     bytes from the instruction following the jump) or short (between
     -128 and +127 bytes) or far (in a different code segment).

     Unless a distance is explicitly specified, the assembler selects
     the shortest possible jump. With near and short jumps, the operand
     specifies a new IP address. With far jumps, the operand specifies
     new IP and CS addresses.

     When the 80386/486 is in FLAT memory model, short jumps range from
     -128 to +127 bytes and near jumps range from -2 to +2 gigabytes.
.context @JMP.des
.freeze 3
.topic JMP Instruction
 \i\p\aSummary\v@JMP\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@jump.asm\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11101011    disp (1)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 JMP  label       ³ jmp   SHORT exit        ³ 88/86 15
                  ³                         ³   286 7+m
                  ³                         ³   386 7+m
                  ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11101001    disp (2)*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 JMP  label       ³ jmp   close             ³ 88/86 15
                  ³ jmp   NEAR PTR distant  ³   286 7+m
                  ³                         ³   386 7+m
                  ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11101010    disp (4)*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 JMP  label       ³ jmp   FAR PTR close     ³ 88/86 15
                  ³ jmp   distant           ³   286 11+m,pm=23+m 
                  ³                         ³   386 12+m,pm=27+m 
                  ³                         ³   486 17,pm=19 
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11111111    mod,100,r/m      disp (0 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 JMP  reg16       ³ jmp   ax                ³ 88/86 11
 JMP  reg32       ³                         ³   286 7+m
                  ³                         ³   386 7+m
                  ³                         ³   486 5
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 JMP  mem16       ³ jmp   WORD PTR [bx]     ³ 88/86 18+EA
 JMP  mem32       ³ jmp   table[di]         ³   286 11+m
                  ³ jmp   DWORD PTR [si]    ³   386 10+m
                  ³                         ³   486 5
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11111111    mod,101,r/m      disp (4)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 JMP  mem32       ³ jmp   fpointer[si]      ³ 88/86 24+EA
 JMP  mem48       ³ jmp   DWORD PTR [bx]    ³   286 15+m,pm=26+m
                  ³ jmp   FWORD PTR [di]    ³   386 12+m,pm=27+m
                  ³                         ³   486 13,pm=18
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * On the 80386/486, the displacement can be four bytes for near
    jumps or six bytes for far jumps.

    Timings for jumps through call or task gates are not shown, since
    they are normally used only in operating systems.

    80386/486 only. You can use DWORD PTR to specify near register-
    indirect jumps or FWORD PTR to specify far register-indirect jumps.
.context LAHF
.context @LAHF
.context SAHF
.topic LAHF/SAHF Instruction
.freeze 3
..index LAHF instruction, Transfer between Flags and AH
..index SAHF instruction, Transfer between Flags and AH
 \i\p\aDetail\v@LAHF.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@Quadrati.asx\v\i\p                    \i\p\aUp\v@FlagInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Transfer between Flags and AH         \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   LAHF                                                 ñ ñ ñ ñ ñ
            SAHF

  \bSee also:\p FSTSW

  \bDescription:\p

     LAHF transfers bits 0-7 of the flags register to AH. SAHF
     transfers AH into bits 0-7 of the flags register. Bits 0-7 include
     the carry, parity, auxiliary carry, zero, and sign flags, but not
     the trap, interrupt, direction, or overflow flags.

.context @LAHF.des
.freeze 3
.topic LAHF/SAHF Instruction
 \i\p\aSummary\v@LAHF\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@FlagInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 10011111
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LAHF             ³ lahf                    ³ 88/86 4
                  ³                         ³   286 2
                  ³                         ³   386 2
                  ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 10011110
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SAHF             ³ sahf                    ³ 88/86 4
                  ³                         ³   286 2
                  ³                         ³   386 3
                  ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context LAR
.context @LAR
.topic LAR Instruction
.freeze 3
..index LAR instruction, Load Access Rights
 \i\p\aDetail\v@LAR.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Load Access Rights                    \bFlags:\p O D I T S Z A P C
            80286-80486 Protected Only                   ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                                   ñ
  \bSyntax:\p   LAR dest,src

  \bSee also:\p .286

  \bDescription:\p

     Loads the access rights of a selector into a specified register.
     The source operand must be a register or memory operand containing
     a selector. The destination operand must be a register that will
     receive the access rights if the selector is valid and visible at
     the current privilege level. The zero flag is set if the access
     rights are transferred, or cleared if they are not.

     See Intel documentation for details on selectors, access rights,
     and other privileged-mode concepts.

.context @LAR.des
.freeze 3
.topic LAR Instruction
 \i\p\aSummary\v@LAR\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     00000010     mod,reg,r/m       disp (0, 1, 2, or 4)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LAR  reg16,reg16   ³ lar   ax,bx              ³ 88/86 ÄÄ
 LAR  reg32,reg32*  ³                          ³   286 14
                    ³                          ³   386 15
                    ³                          ³   486 11
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LAR  reg16,mem16   ³ lar   cx,selector        ³ 88/86 ÄÄ
 LAR  reg32,mem32*  ³                          ³   286 16
                    ³                          ³   386 16
                    ³                          ³   486 11
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 80386/486 only.

.context LDS
.context @LDS
.context LES
.context @LES
.context LFS
.context @LFS
.context LGS
.context @LGS
.context LSS
.context @LSS
.topic LDS Instructions
.freeze 3
..index LDS instruction, Load Far Pointer
..index LES instruction, Load Far Pointer
..index LFS instruction, Load Far Pointer
..index LGS instruction, Load Far Pointer
..index LSS instruction, Load Far Pointer
 \i\p\aDetail\v@LDS.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@LoadPtr.asx\v\i\p                    \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Load Far Pointer                      \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   LDS reg,mem                                       -none-
            LES reg,mem
            LFS reg,mem
            LGS reg,mem
            LSS reg,mem

  \bSee also:\p LEA

  \bDescription:\p

     Reads and stores the far pointer specified by the source memory
     operand. The instruction moves the pointer's segment value into
     DS, ES, FS, GS, or SS (depending on the for of the instruction).
     Then it moves the pointer's offset value into the destination
     operand.

     The LDS and LES instructions are available on all processors.
     The LFS, LGS, and LSS instructions are available only on the
     80386/486.
.context @LDS.des
.freeze 3
.topic LDS Instructions
 \i\p\aSummary\v@LDS\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@LoadPtr.asx\v\i\p                    \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11000101     mod,reg,r/m      disp (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LDS  reg,mem     ³ lds   si,fpointer       ³ 88/86 16+EA (88=24+EA)
                  ³                         ³   286 7,pm=21
                  ³                         ³   386 7,pm=22
                  ³                         ³   486 6,pm=12
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11000100     mod,reg,r/m      disp (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LES  reg,mem     ³ les   di,fpointer       ³ 88/86 16+EA (88=24+EA)
                  ³                         ³   286 7,pm=21
                  ³                         ³   386 7,pm=22
                  ³                         ³   486 6,pm=12
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     10110100         mod,reg,r/m      disp (2 or 4)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LFS  reg,mem     ³ lfs   edi,fpointer      ³ 88/86 ÄÄ
                  ³                         ³   286 ÄÄ
                  ³                         ³   386 7,pm=25
                  ³                         ³   486 6,pm=12
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     10110101         mod,reg,r/m      disp (2 or 4)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LGS  reg,mem     ³ lgs   bx,fpointer       ³ 88/86 ÄÄ
                  ³                         ³   286 ÄÄ
                  ³                         ³   386 7,pm=25
                  ³                         ³   486 6,pm=12
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     10110010         mod,reg,r/m      disp (2 or 4)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LSS  reg,mem     ³ lss   bp,fpointer       ³ 88/86 ÄÄ
                  ³                         ³   286 ÄÄ
                  ³                         ³   386 7,pm=22
                  ³                         ³   486 6,pm=12
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context LEA
.context @LEA
.topic LEA Instruction
.freeze 3
..index LEA instruction, Load Effective Address
 \i\p\aDetail\v@LEA.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Load Effective Address                \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   LEA reg,mem                                       -none-

  \bSee also:\p LDS

  \bDescription:\p

     Calculates the effective address (offset) of the source memory
     operand and stores the result into the destination register.

     If the source operand is a direct memory address, the assembler
     encodes the instruction in the more efficient "MOV reg, immediate"
     form (equivalent to "MOV reg,OFFSET mem").
.context @LEA.des
.freeze 3
.topic LEA Instruction
 \i\p\aSummary\v@LEA\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 10001101    mod,reg,r/m      disp (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LEA  reg16,mem   ³ lea   bx,npointer       ³ 88/86 2+EA
 LEA  reg32,mem   ³                         ³   286 3
                  ³                         ³   386 2
                  ³                         ³   486 1*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 2 if index register used.

    80386/486 only.
.context LGDT
.context @LGDT
.context LIDT
.context @LIDT
.context LLDT
.context @LLDT
.topic LGDT Instructions
.freeze 3
..index LGDT instruction, Load Global Descriptor Table
..index LIDT instruction, Load Interrupt Descriptor Table
..index LLDT instruction, Load Local Descriptor Table
 \i\p\aDetail\v@LGDT.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Load Descriptor Table                 \bFlags:\p O D I T S Z A P C
            80286-80486 Privileged Only                  ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                         ?       ñ ñ ? ñ ?
  \bSyntax:\p   LGDT table
            LIDT table
            LLDT table

  \bSee also:\p .286P, SGDT

  \bDescription:\p

     Loads a value from an operand into a descriptor table register.
     LGDT loads into the Global Descriptor Table, LIDT into the
     Interrupt Descriptor Table, and LLDT into the Local Descriptor
     Table.

     These instructions are available only in protected mode. See Intel
     documentation for details on descriptor tables and other
     privileged-mode concepts.
.context @LGDT.des
.freeze 3
.topic LGDT Instructions
 \i\p\aSummary\v@LGDT\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    00000001    mod,010,r/m       disp (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LGDT  mem48      ³ lgdt  descriptor        ³ 88/86 ÄÄ
                  ³                         ³   286 11
                  ³                         ³   386 11
                  ³                         ³   486 11
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    00000001    mod,011,r/m       disp (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LIDT  mem48      ³ lidt  descriptor        ³ 88/86 ÄÄ
                  ³                         ³   286 12
                  ³                         ³   386 11
                  ³                         ³   486 11
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    00000000    mod,010,r/m       disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LLDT  reg16      ³ lldt  ax                ³ 88/86 ÄÄ
                  ³                         ³   286 17
                  ³                         ³   386 20
                  ³                         ³   486 11
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LLDT  mem16      ³ lldt  selector          ³ 88/86 ÄÄ
                  ³                         ³   286 19
                  ³                         ³   386 24
                  ³                         ³   486 11
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

.context LMSW
.context @LMSW
.context SMSW
.topic LMSW/SMSW Instructions
.freeze 3
..index LMSW instruction, Load Machine Status Word
..index SMSW instruction, Store Machine Status Word
 \i\p\aDetail\v@LMSW.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Load or Store Machine Status Word     \bFlags:\p O D I T S Z A P C
            80286-80486 Only                             ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                              -none-
  \bSyntax:\p   LMSW src
            SMSW dest

  \bSee also:\p .286P

  \bDescription:\p

     LMSW loads a value from a memory operand into the Machine Status
     Word (MSW). SMSW stores the MSW into a specified memory operand.

     LMSW is available only in privileged mode. See Intel documentation
     for details on MSW and other protected-mode concepts.

.context @SMSW.des
.context @LMSW.des
.freeze 3
.topic LMSW/SMSW Instructions
 \i\p\aSummary\v@LMSW\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     00000001    mod,110,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LMSW  reg16        ³ lmsw  ax                ³ 88/86 ÄÄ
                    ³                         ³   286 3
                    ³                         ³   386 10
                    ³                         ³   486 13
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LMSW  mem16        ³ lmsw  machine           ³ 88/86 ÄÄ
                    ³                         ³   286 6
                    ³                         ³   386 13
                    ³                         ³   486 13
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     00000001    mod,100,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SMSW  reg16        ³ smsw  ax                ³ 88/86 ÄÄ
                    ³                         ³   286 2
                    ³                         ³   386 2
                    ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SMSW  mem16        ³ smsw  machine           ³ 88/86 ÄÄ
                    ³                         ³   286 3
                    ³                         ³   386 3
                    ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context LOCK
.context @LOCK
.topic LOCK Instruction
.freeze 3
..index LOCK instruction, Lock the Bus
 \i\p\aDetail\v@LOCK.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Lock the Bus                          \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   LOCK instruction                                  -none-

  \bDescription:\p

     Locks out other processors during execution of the next
     instruction. This instruction is a prefix. It must precede an
     instruction that accesses a memory location that another processor
     can attempt to access at the same time.

     See Intel documentation for details on multiprocessor
     environments.
.context @LOCK.des
.freeze 3
.topic LOCK Instruction
 \i\p\aSummary\v@LOCK\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11110000
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LOCK  instruction   ³ lock  xchg ax,sem       ³ 88/86 2
                     ³                         ³   286 0
                     ³                         ³   386 0
                     ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context LODS
.context @LODS
.context LODSB
.context @LODSB
.context LODSW
.context @LODSW
.context LODSD
.context @LODSD
.topic LODS Instruction
.freeze 3
..index LODS instruction, Load String Operand
..index LODSB instruction, Load String Operand (Bytes)
..index LODSW instruction, Load String Operand (Words)
..index LODSD instruction, Load String Operand (Doublewords)
 \i\p\aDetail\v@LODS.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@WinClose.asx\v\i\p                    \i\p\aUp\v@StringInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Load String Operand                   \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   LODS src                                          -none-
            LODSB
            LODSW
            LODSD (80386/486 Only)

  \bSee also:\p STOS, MOVS, CLD

  \bDescription:\p

     Loads accumulator with element from a string from memory. The
     string to be loaded is the source and must be pointed to by DS:SI
     (even if an operand is given). For each source element loaded, SI
     is adjusted according to the size of the operand and the status
     of the direction flag. SI is incremented if the direction flag has
     been cleared with CLD, or decremented if the direction flag has
     been set with STD.

     If the LODS form of the instruction is used, an operand must be
     provided to indicate the size of the data elements to be
     processed. A segment override can be given.

     If LODSB (bytes), LODSW (words), or LODSD (doublewords) is used,
     the instruction determines the size of the data elements to be
     processed and whether the element will be loaded to AL, AX, or
     EAX.

     LODS and its variations are not used with repeat prefixes,
     since there is no reason to repeatedly load memory values to
     a register.
.context @LODS.des
.freeze 3
.topic LODS Instruction
 \i\p\aSummary\v@LODS\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@WinClose.asx\v\i\p                    \i\p\aUp\v@StringInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1010110w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LODS  [segreg:]src       ³ lods  es:source       ³ 88/86 12 (W88=16)
 LODSB [[segreg:]src]     ³ lodsw                 ³   286 5
 LODSW [[segreg:]src]     ³                       ³   386 5
 LODSD [[segreg:]src]     ³                       ³   486 5
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context LOOP
.context @LOOP
.context LOOPW
.context @LOOPW
.context LOOPD
.context @LOOPD
.topic LOOP Instruction
.freeze 3
..index loops
..index LOOP instruction, Loop
..index LOOPW instruction, Loop (Overrides 16-Bit CX)
..index LOOPD instruction, Loop (Overrides 32-Bit ECX)
 \i\p\aDetail\v@LOOP.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@Loopso.asm\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Loop                                  \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   LOOP label                                        -none-
            LOOPW
            LOOPD

  \bSee also:\p LOOPE, .REPEAT, JCXZ

  \bDescription:\p

     Loops repeatedly to a specified label. LOOP decrements CX (without
     changing any flags) and, if the result is not 0, transfers
     execution to the address specified by the operand.

     On the 80386/486, LOOP uses the 16-bit CX in 16-bit mode and the
     32-bit ECX in 32-bit mode. The default can be overridden with the
     LOOPW (CX) or LOOPD (ECX) forms of the instruction.

     If CX is 0 after being decremented, execution continues at the
     next instruction. The operand must specify a short label (between
     -128 and +127 bytes from the instruction following the LOOP
     instruction).
.context @LOOP.des
.freeze 3
.topic LOOP Instruction
 \i\p\aSummary\v@LOOP\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@Loopso.asm\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11100010       disp (1)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LOOP  label      ³ loop  wend              ³ 88/86 17,noj=5
 LOOPW label*     ³                         ³   286 8+m,noj=4
 LOOPD label*     ³                         ³   386 11+m
                  ³                         ³   486 7,noj=6
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 80386/486 only.
.context LOOPE
.context @LOOPE
.context LOOPZ
.context LOOPNE
.context LOOPNZ
.context LOOPEW
.context LOOPED
.context LOOPZW
.context LOOPZD
.context LOOPNEW
.context LOOPNZW
.context LOOPNZD
.context LOOPNED
.context @LOOPcondition
.topic LOOPcondition Instruction
.freeze 3
..index loops
..index LOOPcondition instruction, Loop If
 \i\p\aDetail\v@LOOPE.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@Loopso.asm\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Loop If                               \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   LOOPE label                                        -none-
            LOOPNE label
            LOOPZ label
            LOOPNZ label
            LOOPEW label
            LOOPNEW label
            LOOPED label
            LOOPNED label
            LOOPZW label
            LOOPNZW label
            LOOPZD label
            LOOPNZD label

  \bSee also:\p CMP, .REPEAT, .WHILE, JCXZ, LOOP

  \bDescription:\p

     Loops repeatedly to a specified label if the condition is met and
     if CX is not 0. On the 80386/486, these instructions use the
     16-bit CX in 16-bit mode and the 32-bit ECX in 32-bit mode. This
     default can be overridden with the W (CX) or D (ECX) forms of the
     instruction.

     The instruction decrements CX without changing any flags and tests
     whether the zero flag was set by a previous instruction (for
     example, CMP). With the synonyms LOOPE and LOOPZ, execution is
     transferred to the label if the zero flag is set and CX is not 0.
     With the synonyms LOOPNE and LOOPNZ, execution is transferred to
     the label if the zero flag is cleared and CX is not 0.

     Execution continues at the next instruction if the condition is
     not met. Before entering the loop, CX should be set to the maximum
     number of repetitions desired.
.context @LOOPE.des
.freeze 3
.topic LOOPcondition Instruction
 \i\p\aSummary\v@LOOPE\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@Loopso.asm\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11100001       disp (1)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LOOPE  label    ³ loopz  again            ³ 88/86 18,noj=6
 LOOPEW label*   ³                         ³   286 8+m,noj=4
 LOOPED label*   ³                         ³   386 11+m
 LOOPZ  label    ³                         ³   486 9,noj=6
 LOOPZW label*   ³                         ³
 LOOPZD label*   ³                         ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 11100000       disp (1)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LOOPNE  label   ³ loopnz for_next         ³ 88/86 19,noj=5
 LOOPNEW label*  ³                         ³   286 8,noj=4
 LOOPNED label*  ³                         ³   386 11+m
 LOOPNZ  label   ³                         ³   486 9,noj=6
 LOOPNZW label*  ³                         ³
 LOOPNZD label*  ³                         ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 80386/486 only.
.context LSL
.context @LSL
.topic LSL Instruction
.freeze 3
..index LSL instruction, Load Segment Limit
 \i\p\aDetail\v@LSL.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Load Segment Limit                    \bFlags:\p O D I T S Z A P C
            80286-80486 Protected Only                   ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                                   ñ
  \bSyntax:\p   LSL dest,src

  \bSee also:\p .286

  \bDescription:\p

     Loads the segment limit of a selector into a specified register.
     The source operand must be a register or memory operand containing
     a selector. The destination operand must be a register that will
     receive the segment limit if the selector is valid and visible at
     the current privilege level. The zero flag is set if the segment
     limit is transferred, or cleared if it is not.

     See Intel documentation for details on selectors, segment limits,
     and other protected-mode concepts.


.context @LSL.des
.freeze 3
.topic LSL Instruction
 \i\p\aSummary\v@LSL\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    00000011    mod,reg,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LSL  reg16,reg16    ³ lsl   ax,bx             ³ 88/86 ÄÄ
 LSL  reg32,reg32*   ³                         ³   286 14
                     ³                         ³   386 20,25 
                     ³                         ³   486 10
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LSL  reg16,mem16    ³ lsl   cx,seg_lim        ³ 88/86 ÄÄ
 LSL  reg32,mem32*   ³                         ³   286 16
                     ³                         ³   386 21,26 
                     ³                         ³   486 10
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 80386/486 only.

    The first value is for byte granular; the second is for page
    granular.

.context LTR
.context @LTR
.context STR
.topic LTR/STR Instructions
.freeze 3
..index LTR instruction, Load Task Register
..index STR instruction, Store Task Register
 \i\p\aDetail\v@LTR.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Load or Store Task Register           \bFlags:\p O D I T S Z A P C
            80286-80486 Only                             ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                              -none-
  \bSyntax:\p   LTR src
            STR dest

  \bSee also:\p .286P

  \bDescription:\p

     LTR loads a value from the specified operand to the current task
     register. STR stores the current task register to the specified
     operand.

     LTR is available only in privileged mode. See Intel documentation
     for details on task registers and other protected-mode concepts.
.context @LTR.des
.freeze 3
.topic LTR/STR Instructions
 \i\p\aSummary\v@LTR\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    00000000   ÿmod,011,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LTR  reg16         ³ ltr   ax                ³ 88/86 ÄÄ
                    ³                         ³   286 17
                    ³                         ³   386 23
                    ³                         ³   486 20
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 LTR  mem16         ³ ltr   task              ³ 88/86 ÄÄ
                    ³                         ³   286 19
                    ³                         ³   386 27
                    ³                         ³   486 20
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    00000000    mod,001,reg      disp (0 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 STR  reg16         ³ str    cx               ³ 88/86 ÄÄ
                    ³                         ³   286 2
                    ³                         ³   386 2
                    ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 STR  mem16         ³ str    taskreg          ³ 88/86 ÄÄ
                    ³                         ³   286 3
                    ³                         ³   386 2
                    ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context MOV
.context @MOV
.topic MOV Instruction
.freeze 3
..index MOV instruction, Move Data
 \i\p\aDetail\v@MOV.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Move Data                             \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   MOV dest,src                                      -none-

  \bSee also:\p MOVS, MOVSX, MOVZX, \aMOV Special\v@MOVIE\v, LEA, XCHG

  \bDescription:\p

     Moves the value in the source operand to the destination operand.
     If the destination operand is SS, interrupts are disabled until
     the next instruction is executed (except on early versions of the
     8088 and 8086).
.context @MOV.des
.freeze 3
.topic MOV Instruction
 \i\p\aSummary\v@MOV\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 100010dw       mod,reg,r/m     disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  reg,reg        ³ mov   dh,bh             ³ 88/86 2
                     ³ mov   dx,cx             ³   286 2
                     ³ mov   bp,sp             ³   386 2
                     ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  mem,reg        ³ mov   array[di],bx      ³ 88/86 9+EA (W88=13+EA)
                     ³ mov   count,cx          ³   286 3
                     ³                         ³   386 2
                     ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  reg,mem        ³ mov   bx,pointer        ³ 88/86 8+EA (W88=12+EA)
                     ³ mov   dx,matrix[bx+di]  ³   286 5
                     ³                         ³   386 4
                     ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1100011w       mod,000,r/m     disp (0, 1, or 2)     data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  mem,immed      ³ mov   [bx],15           ³ 88/86 10+EA (W88=14+EA)
                     ³ mov   color,7           ³   286 3
                     ³                         ³   386 2
                     ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1011wreg       data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  reg,immed      ³ mov   cx,256            ³ 88/86 4
                     ³ mov   dx,OFFSET string  ³   286 2
                     ³                         ³   386 2
                     ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 101000aw       disp (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  mem,accum      ³ mov   total,ax          ³ 88/86 10 (W88=14)
                     ³                         ³   286 3
                     ³                         ³   386 2
                     ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  accum,mem      ³ mov   ax,fsize          ³ 88/86 10 (W88=14)
                     ³                         ³   286 5
                     ³                         ³   386 4
                     ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 100011d0       mod,sreg,r/m    disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  segreg,reg16   ³ mov   ds,ax             ³ 88/86 2
                     ³                         ³   286 2,pm=17
                     ³                         ³   386 2,pm=18
                     ³                         ³   486 3,pm=9
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  segreg,mem16   ³ mov   es,psp            ³ 88/86 8+EA (88=12+EA)
                     ³                         ³   286 5,pm=19
                     ³                         ³   386 5,pm=19
                     ³                         ³   486 3,pm=9
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  reg16,segreg   ³ mov   ax,ds             ³ 88/86 2
                     ³                         ³   286 2
                     ³                         ³   386 2
                     ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  mem16,segreg   ³ mov   stack_save,ss     ³ 88/86 9+EA (88=13+EA)
                     ³                         ³   286 3
                     ³                         ³   386 2
                     ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context @MOVIE
.topic MOV Special Instruction
.freeze 3
..index manipulating debug registers
..index manipulating test registers
..index manipulating control registers
..index MOV special instruction, Move to/from Special Registers
 \i\p\aDetail\v@MOVIE.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Move to/from Special Registers        \bFlags:\p O D I T S Z A P C
            80386/486 Only                               ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                         ?       ? ? ? ? ?
  \bSyntax:\p   MOV dest,src

  \bSee also:\p .386

  \bDescription:\p

     Moves a value from a special register to or from a 32-bit
     general-purpose register. The special registers include the
     control registers CR0, CR2, and CR3; the debug registers DR0, DR1,
     DR2, D3, DR6, and DR7; and the test registers TR6 and TR7. On the
     80486, the test registers TR3, TR4, and TR5 are also available.

     See Intel documentation for details on special registers.
.context @MOVIE.des
.freeze 3
.topic MOV Special Intruction
 \i\p\aSummary\v@MOV\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    001000d0    11,reg*,r/m
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  reg32,controlreg ³ mov   eax,cr2          ³ 88/86 ÄÄ
                       ³                        ³   286 ÄÄ
                       ³                        ³   386 6
                       ³                        ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  controlreg,r32   ³ mov   cr0,ebx          ³ 88/86 ÄÄ
                       ³                        ³   286 ÄÄ
                       ³                        ³   386 CR0=10,CR2=4,CR3=5
                       ³                        ³   486 4,CR0=16
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    001000d1    11,reg*,r/m
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  reg32,debugreg   ³ mov   edx,dr3          ³ 88/86 ÄÄ
                       ³                        ³   286 ÄÄ
                       ³                        ³   386 DR0-3=22,DR6-7=14
                       ³                        ³   486 10
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  debugreg,reg32   ³ mov   dr0,ecx          ³ 88/86 ÄÄ
                       ³                        ³   286 ÄÄ
                       ³                        ³   386 DR0-3=22,DR6-7=16
                       ³                        ³   486 11
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    001001d0    11,reg*,r/m

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  reg32,testreg    ³ mov   edx,tr6          ³ 88/86 ÄÄ
                       ³                        ³   286 ÄÄ
                       ³                        ³   386 12
                       ³                        ³   486 4,TR3=3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOV  testreg,r32      ³ mov   tr7,eax          ³ 88/86 ÄÄ
                       ³                        ³   286 ÄÄ
                       ³                        ³   386 12
                       ³                        ³   486 4,TR3=6
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * The reg field contains the register number of the special register
    (for example, 000 for CR0, 011 for DR7, or 111 for TR7).

.context MOVS
.context @MOVS
.context MOVSB
.context @MOVSB
.context MOVSW
.context @MOVSW
.context MOVSD
.context @MOVSD
.topic MOVS Instruction
.freeze 3
..index MOVS instruction, Move String Data
..index MOVSB instruction, Move String Data (Bytes)
..index MOVSW instruction, Move String Data (Words)
..index MOVSD instruction, Move String Data (Doublewords)
 \i\p\aDetail\v@MOVS.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@WinOpen.asx\v\i\p                    \i\p\aUp\v@StringInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Move String Data                      \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   MOVS dest,src                                     -none-
            MOVSB
            MOVSW
            MOVSD (80386/486 Only)

  \bSee also:\p REP, LODS, STOS, STD

  \bDescription:\p

     Moves a string from one area of memory to another. The source
     string must be pointed to by DS:SI, and the destination address
     must be pointed to by ES:DI (even if operands are given).

     For each element moved, DI and SI are adjusted according to the
     size of the operands and the status of the direction flag. They
     are increased if the direction flag has been cleared with CLD, or
     decreased if the direction flag has been set with STD.

     If the MOVS form of the instruction is used, operands must be
     provided to indicate the size of the data elements to be
     processed. A segment override can be given for the source operand
     (but not for the destination). If MOVSB (bytes), MOVSW (words), or
     MOVSD (doublewords) is used, the instruction determines the size
     of the data elements to be processed.

     Use MOVS and its variations with the REP prefix.
.context @MOVS.des
.freeze 3
.topic MOVS Instruction
 \i\p\aSummary\v@MOVS\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@WinOpen.asx\v\i\p                    \i\p\aUp\v@StringInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1010010w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOVS  [ES:]dest,[segreg:]src  ³ rep   movsb           ³ 88/86 18 (W88=26)
 MOVSB [[ES:]dest,[segreg:]src]³ movs  dest,es:source  ³   286 5
 MOVSW [[ES:]dest,[segreg:]src]³                       ³   386 7
 MOVSD [[ES:]dest,[segreg:]src]³                       ³   486 7
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context MOVSX
.context @MOVSX
.context MOVZX
.topic MOVSX/MOVZX Instructions
.freeze 3
..index MOVSX instruction, Move with Sign-Extend
..index MOVZX instruction, Move with Zero-Extend
 \i\p\aDetail\v@MOVSX.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Move with Sign- or Zero-Extend        \bFlags:\p O D I T S Z A P C
            80386/486 Only                               ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                              -none-
  \bSyntax:\p   MOVSX dest,src
            MOVZX dest,src

  \bSee also:\p .386, MOV, CBW

  \bDescription:\p

     MOVSX moves and sign-extends the value of the source operand to
     the destination register. Use MOVSX to copy a signed 8-bit or
     16-bit source operand to a larger 16-bit or 32-bit destination
     register.

     MOVZX moves and zero-extends the value of the source operand to
     the destination register. Use MOVZX to copy an unsigned 8-bit
     or 16-bit source operand to a larger 16-bit or 32-bit destination
     register.

.context @MOVSX.des
.freeze 3
.topic MOVSX/MOVZX Instructions
 \i\p\aSummary\v@MOVSX\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    1011111w    mod,reg,r/m      disp (0, 1, 2, or 4)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOVSX  reg,reg   ³ movsx  eax,bx           ³ 88/86 ÄÄ
                  ³ movsx  ecx,bl           ³   286 ÄÄ
                  ³ movsx  bx,al            ³   386 3
                  ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOVSX  reg,mem   ³ movsx  cx,bsign         ³ 88/86 ÄÄ
                  ³ movsx  edx,wsign        ³   286 ÄÄ
                  ³ movsx  eax,bsign        ³   386 6
                  ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    1011011w    mod,reg,r/m      disp (0, 1, 2, or 4)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOVZX  reg,reg   ³ movzx  eax,bx           ³ 88/86 ÄÄ
                  ³ movzx  ecx,bl           ³   286 ÄÄ
                  ³ movzx  bx,al            ³   386 3
                  ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MOVZX  reg,mem   ³ movzx  cx,bunsign       ³ 88/86 ÄÄ
                  ³ movzx  edx,wunsign      ³   286 ÄÄ
                  ³ movzx  eax,bunsign      ³   386 6
                  ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

.context MUL
.context @MUL
.topic MUL Instruction
.freeze 3
..index unsigned multiply
..index MUL instruction, Unsigned Multiply
 \i\p\aDetail\v@MUL.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@MulLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Unsigned Multiply                     \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   MUL src                                      ñ       ? ? ? ? ñ

  \bSee also:\p IMUL, DIV, IDIV, SHL

  \bDescription:\p

     Multiplies an implied destination operand by a specified source
     operand. Both operands are treated as unsigned numbers. If a
     single 16-bit operand is given, the implied destination is AX and
     the product goes into the DX:AX register pair. If a single 8-bit
     operand is given, the implied destination is AL and the product
     goes into AX.

     On the 80386/486, if the operand is EAX, the product goes into the
     EDX:EAX register pair. The carry and overflow flags are set if DX
     is not 0 for 16-bit operands or if AH is not 0 for 8-bit operands.

.context @MUL.des
.freeze 3
.topic MUL Instruction
 \i\p\aSummary\v@MUL\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@MulLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1111011w    mod,100,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MUL  reg        ³ mul   bx               ³ 88/86 b=70-77,w=118-133
                 ³ mul   dl               ³   286 b=13,w=21
                 ³                        ³   386 b=9-14,w=9-22,d=9-38 
                 ³                        ³   486 b=13-18,w=13-26,d=13-42
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 MUL  mem        ³ mul   factor           ³ 88/86 (b=76-83,w=124-139)+EA*
                 ³ mul   WORD PTR [bx]    ³   286 b=16,w=24
                 ³                        ³   386 b=12-17,w=12-25,d=12-41 
                 ³                        ³   486 b=13-18,w=13-26,d=13-42
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * Word memory operands on the 8088 take (128-143)+EA clocks.

    The 80386/486 has an early-out multiplication algorithm. Therefore,
    multiplying an 8-bit or 16-bit value in EAX takes the same time as
    multiplying the value in AL or AX.
.context NEG
.context @NEG
.topic NEG Instruction
.freeze 3
..index two's-complement negation
..index NEG instruction, Two's-Complement Negation
 \i\p\aDetail\v@NEG.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Two's-Complement Negation             \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   NEG dest                                     ñ       ñ ñ ñ ñ ñ

  \bSee also:\p SUB, NOT

  \bDescription:\p

     Replaces the operand with its two's complement by subtracting the
     operand from 0. If the operand is 0, the carry flag is cleared.
     Otherwise, the carry flag is set.

     If the operand contains the maximum possible negative value (-128
     for 8-bit operands or -32,768 for 16-bit operands), the value does
     not change, but the overflow and carry flags are set.

.context @NEG.des
.freeze 3
.topic NEG Instruction
 \i\p\aSummary\v@NEG\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1111011w    mod,011,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 NEG  reg         ³ neg   ax                ³ 88/86 3
                  ³                         ³   286 2
                  ³                         ³   386 2
                  ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 NEG  mem         ³ neg   balance           ³ 88/86 16+EA (W88=24+EA)
                  ³                         ³   286 7
                  ³                         ³   386 6
                  ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context NOP
.context @NOP
.topic NOP Instruction
.freeze 3
..index NOP instruction, No Operation
 \i\p\aDetail\v@NOP.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    No Operation                          \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   NOP                                               -none-

  \bDescription:\p

     Performs no operation. NOP can be used for timing delays or
     alignment.

.context @NOP.des
.freeze 3
.topic NOP Instruction
 \i\p\aSummary\v@NOP\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 10010000*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 NOP              ³ nop                     ³ 88/86 3
                  ³                         ³   286 3
                  ³                         ³   386 3
                  ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * The encoding is the same for XCHG AX,AX.
.context NOT
.context @NOT
.topic NOT Instruction
.freeze 3
..index one's-complement negation
..index NOT instruction, One's-Complement Negation
 \i\p\aDetail\v@NOT.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@Colors.asx\v\i\p                    \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    One's-Complement Negation             \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   NOT dest                                          -none-

  \bSee also:\p \aOR Operator\v@LogShiftOp\v, NEG, AND, OR, XOR, SHL, SHR

  \bDescription:\p

     Toggles each bit of the operand by clearing set bits and setting
     cleared bits.

.context @NOT.des
.freeze 3
.topic NOT Instruction
 \i\p\aSummary\v@NOT\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@Colors.asx\v\i\p                    \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1111011w    mod,010,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 NOT  reg         ³ not   ax                ³ 88/86 3
                  ³                         ³   286 2
                  ³                         ³   386 2
                  ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 NOT  mem         ³ not   masker            ³ 88/86 16+EA (W88=24+EA)
                  ³                         ³   286 7
                  ³                         ³   386 6
                  ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context OR
.context @OR
.topic OR Instruction
.freeze 3
..index OR instruction, Logical OR
 \i\p\aDetail\v@OR.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@Colors.asx\v\i\p                    \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    OR                                    \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   OR dest,src                                  0       ñ ñ ? ñ 0

  \bSee also:\p \aOR Operator\v@LogShiftOp\v, \a||\v@ccompare\v, AND, XOR, NOT, SHL, 
SHR, OPTION NOSIGNEXTEND

  \bDescription:\p

     Performs a bitwise OR operation on the source and destination
     operands and stores the result to the destination operand.

     For each bit position in the operands, if either or both bits are
     set, the corresponding bit of the result it set. Otherwise, the
     corresponding bit of the result is cleared.
.context @OR.des
.freeze 3
.topic OR Instruction
 \i\p\aSummary\v@OR\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@Colors.asx\v\i\p                    \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 000010dw    mod,reg,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 OR  reg,reg      ³ or    ax,dx             ³ 88/86 3
                  ³                         ³   286 2
                  ³                         ³   386 2
                  ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 OR  mem,reg      ³ or    [bp+6],cx         ³ 88/86 16+EA (W88=24+EA)
                  ³ or    bits,dx           ³   286 7
                  ³                         ³   386 7
                  ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 OR  reg,mem      ³ or    bx,masker         ³ 88/86 9+EA (W88=13+EA)
                  ³ or    dx,color[di]      ³   286 7
                  ³                         ³   386 6
                  ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 100000sw    mod,001,r/m      disp (0, 1, or 2)     data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 OR  reg,immed    ³ or    dx,110110b        ³ 88/86 4
                  ³                         ³   286 3
                  ³                         ³   386 2
                  ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 OR  mem,immed    ³ or    flag_rec,8        ³ 88/86 (b=17,w=25)+EA
                  ³                         ³   286 7
                  ³                         ³   386 7
                  ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 0000110w    data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 OR  accum,immed  ³ or    ax,40h            ³ 88/86 4
                  ³                         ³   286 3
                  ³                         ³   386 2
                  ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context OUT
.context @OUT
.topic OUT Instruction
.freeze 3
..index OUT instruction, Output to Port
 \i\p\aDetail\v@OUT.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@Sound.asx\v\i\p                    \i\p\aUp\v@IOInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Output to Port                        \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   OUT port,accumulator                              -none-

  \bSee also:\p IN, OUTS, INS, \aECHO Directive\v@ECHO\v, \aMASM 5.1 
Compatibility\v@510out\v

  \bDescription:\p

     Transfers a byte or word (or doubleword on the 80386/486) to a
     port from the accumulator register. The port address is specified
     by the destination operand, which can be DX or an 8-bit constant.

     In protected mode, a general-protection fault occurs if OUT is
     used when the current privilege level is greater than the value of
     the IOPL flag.

.context @OUT.des
.freeze 3
.topic OUT Instruction
 \i\p\aSummary\v@OUT\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@Sound.asx\v\i\p                    \i\p\aUp\v@IOInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1110011w       data (1)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 OUT  immed8,accum³ out   60h,al             ³ 88/86 10 (88=14)
                  ³                          ³   286 3
                  ³                          ³   386 10,pm=4,24*
                  ³                          ³   486 16,pm=11,31*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1110111w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 OUT  DX,accum    ³ out   dx,ax              ³ 88/86 8 (88=12)
                  ³ out   dx,al              ³   286 3
                  ³                          ³   386 11,pm=5,25*
                  ³                          ³   486 16,pm=10,30*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * First protected-mode timing: CPL <= IOPL. Second timing: CPL > IOPL.
.context OUTS
.context @OUTS
.context OUTSB
.context @OUTSB
.context OUTSW
.context @OUTSW
.context OUTSD
.context @OUTSD
.topic OUTS Instruction
.freeze 3
..index OUTS instruction, Output String to Port
..index OUTSB instruction, Output String to Port (Bytes)
..index OUTSW instruction, Output String to Port (Words)
..index OUTSD instruction, Output String to Port (Doublewords)
 \i\p\aDetail\v@OUTS.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@IOInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Output String to Port                 \bFlags:\p O D I T S Z A P C
            80186-80486 Only                             ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                              -none-
  \bSyntax:\p   OUTS DX,src
            OUTSB
            OUTSW
            OUTSD (80386/486 Only)

  \bSee also:\p .186, INS, IN, OUT

  \bDescription:\p

     Sends a string to a port. The string is considered the source and
     must be pointed to by DS:SI (even if an operand is given). The
     output port is specified in DX. For each element sent, SI is
     adjusted according to the size of the operand and the status of
     the direction flag. SI is increased if the direction flag has been
     cleared with CLD or decreased if the direction flag has been set
     with STD.

     If the OUTS form of the instruction is used, an operand must be
     provided to indicate the size of data elements to be sent. A
     segment override can be given. If OUTSB (bytes), OUTSW (words), or
     OUTSD (doublewords) is used, the instruction determines the size
     of the data elements to be sent.

     OUTS and its variations are normally used with the REP prefix.
     Before the instruction is executed, CX should contain the number
     of elements to send. In protected mode, a general-protection fault
     occurs if OUTS is used when the current privilege level is greater
     than the value of the IOPL flag.

.context @OUTS.des
.freeze 3
.topic OUTS Instruction
 \i\p\aSummary\v@OUTS\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@IOInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 0110111w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 OUTS  DX,[segreg:]src   ³rep  outs  dx,buffer ³ 88/86 ÄÄ
 OUTSB [DX,[segreg:]src] ³outsb                ³   286 5
 OUTSW [DX,[segreg:]src] ³rep  outw            ³   386 14,pm=8,28*
 OUTSD [DX,[segreg:]src] ³                     ³   486 17,pm=10,32*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * First protected-mode timing: CPL <= IOPL. Second timing: CPL > IOPL.
.context Pop
.context @Pop
.topic POP Instruction
.freeze 3
..index POP instruction, Pop
 \i\p\aDetail\v@POP.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@GetMem.asx\v\i\p                    \i\p\aUp\v@StackInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Pop                                   \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   POP dest                                          -none-

  \bSee also:\p PUSH, PUSHA, PUSHF, ENTER

  \bDescription:\p

     Pops the top of the stack into the destination operand. The value
     at SS:SP is copied to the destination operand and SP is increased
     by 2. The destination operand can be a memory location, a general-
     purpose 16-bit register, or any segment register except CS. Use
     RET to pop CS.

     On the 80386/486, 32-bit values can be popped by giving a 32-bit
     operand. ESP is increased by 4 for 32-bit pops.

.context @POP.des
.freeze 3
.topic POP Instruction
 \i\p\aSummary\v@POP\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@GetMem.asx\v\i\p                    \i\p\aUp\v@StackInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 01011reg
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 POP  reg16     ³ pop   cx                ³ 88/86 8 (88=12)
 POP  reg32*    ³                         ³   286 5
                ³                         ³   386 4
                ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 10001111     mod,000,r/m       disp (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 POP  mem16     ³ pop   param             ³ 88/86 17+EA (88=25+EA)
 POP  mem32*    ³                         ³   286 5
                ³                         ³   386 5
                ³                         ³   486 6
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 000,sreg,111
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 POP  segreg    ³ pop   es                ³ 88/86 8 (88=12)
                ³ pop   ds                ³   286 5,pm=20
                ³ pop   ss                ³   386 7,pm=21
                ³                         ³   486 3,pm=9
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111     10,sreg,001
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 POP  segreg*   ³ pop   fs                ³ 88/86 ÄÄ
                ³ pop   gs                ³   286 ÄÄ
                ³                         ³   386 7,pm=21
                ³                         ³   486 3,pm=9
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 80386/486 only.
.context Push
.context PushW
.context PushD
.context @Push
.topic PUSH Instruction
.freeze 3
..index PUSH instruction, Push
..index PUSHD instruction, Push (Word)
..index PUSHW instruction, Push (Doubleword)
 \i\p\aDetail\v@PUSH.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@GetMem.asx\v\i\p                    \i\p\aUp\v@StackInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Push                                  \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   PUSH src                                          -none-
            PUSHW src
            PUSHD src

  \bSee also:\p POP, POPA, POPF, LEAVE

  \bDescription:\p

     Pushes the source operand onto the stack. SP is decreased by 2 and
     the source value is copied to SS:SP. The operand can be a memory
     location, a general-purpose 16-bit register, or a segment
     register. On the 80186-80486 processors, the operand can also be a
     constant.

     On the 80386/486, 32-bit values can be pushed by specifying a
     32-bit operand. ESP is decreased by 4 for 32-bit pushes.

     On the 8088 and 8086, push sp saves the value of SP after the
     push. On the 80186-80486 processors, push sp saves the value of SP
     before the push.

     The PUSHW and PUSHD instructions push a word (2 bytes) and a double-
     word (4 bytes), respectively.
.context @Push.des
.freeze 3
.topic PUSH Instruction
 \i\p\aSummary\v@PUSH\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@GetMem.asx\v\i\p                    \i\p\aUp\v@StackInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 01010reg
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 PUSH  reg16   ³ push  dx                ³ 88/86 11 (88=15)
 PUSH  reg32*  ³                         ³   286 3
 PUSHW reg16   ³                         ³   386 2
 PUSHD reg16*  ³                         ³   486 1
 PUSHD reg32*  ³                         ³
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11111111    mod,110,r/m      disp (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 PUSH  mem16   ³ push  [di]              ³ 88/86 16+EA (88=24+EA)
 PUSH  mem32*  ³ push  fcount            ³   286 5
               ³                         ³   386 5
               ³                         ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00,sreg,110
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 PUSH  segreg  ³ push  es                ³ 88/86 10 (88=14)
 PUSHW segreg  ³ push  ss                ³   286 3
 PUSHD segreg* ³ push  cs                ³   386 2
               ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    10,sreg,000
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 PUSH  segreg  ³ push  fs                ³ 88/86 ÄÄ
 PUSHW segreg  ³ push  gs                ³   286 ÄÄ
 PUSHD segreg* ³                         ³   386 2
               ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 011010s0    data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 PUSH  immed   ³ push  'a'               ³ 88/86 ÄÄ
 PUSHW immed   ³ push  15000             ³   286 3
 PUSHD immed*  ³                         ³   386 2
               ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 80386/486 only.
.context PUSHA
.context @PUSHA
.context PUSHAD
.context @PUSHAD
.context POPA
.context POPAD
.topic PUSHA/POPA Instructions
.freeze 3
..index PUSHA instruction, Push All
..index PUSHAD instruction, Push All (32-Bit Registers)
..index POPA instruction, Pop All
..index POPAD instruction, Pop All (32-bit Registers)
 \i\p\aDetail\v@PUSHA.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@PushAll.asx\v\i\p                    \i\p\aUp\v@StackInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Push or Pop All                       \bFlags:\p O D I T S Z A P C
            80186-80486 Only                             ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                              -none-
  \bSyntax:\p   PUSHA
            PUSHAW
            PUSHAD
            POPA
            POPAW
            POPAD

  \bSee also:\p .186, PUSH, POP

  \bDescription:\p

     PUSHA pushes the eight general-purpose registers onto the stack.
     The registers are pushed in the following order: AX, CX, DX, BX,
     SP, BP, SI, DI. The value pushed for SP is the value before the
     instruction.

     POPA pops the top 16 bytes on the stack into the eight general-
     purpose registers. The registers are popped in the following
     order: DI, SI, BP, SP, BX, DX, CX, AX. The value for the SP
     register is actually discarded rather than copied to SP.

     The behavior of PUSHA and POPA depend on the code segment
     they are used in. They work on 16-bit registers in 16-bit segments and
     32-bit registers in 32-bit segments. PUSHAW and POPAW always
     work on 16-bit registers. PUSHAD and POPAD always work on
     32-bit registers (80386/486 only).
.context @PUSHA.des
.freeze 3
.topic PUSHA/POPA Instructions
 \i\p\aSummary\v@PUSHA\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@PushAll.asx\v\i\p                    \i\p\aUp\v@StackInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 01100000
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 PUSHA            ³ pusha                   ³ 88/86 ÄÄ
 PUSHAW           ³                         ³   286 17
 PUSHAD*          ³                         ³   386 18
                  ³                         ³   486 11
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 01100001
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 POPA             ³ popa                    ³ 88/86 ÄÄ
 POPAW            ³                         ³   286 19
 POPAD*           ³                         ³   386 24
                  ³                         ³   486 9
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 80386/486 only.
.context PUSHF
.context @PUSHF
.context PUSHFD
.context @PUSHFD
.context POPF
.context POPFD
.topic PUSHF/POPF Instructions
.freeze 3
..index PUSHF instruction, Push Flags
..index PUSHFD instruction, Push Flags (32-Bit Registers)
..index POPF instruction, Pop Flags
..index POPFD instruction, Pop Flags (32-Bit Registers)
 \i\p\aDetail\v@PUSHF.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@FindFirs.asx\v\i\p                    \i\p\aUp\v@FlagInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Push or Pop Flags                     \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   PUSHF                                        ñ ñ ñ ñ ñ ñ ñ ñ ñ
            PUSHFD
            POPF
            POPFD

  \bSee also:\p PUSH, POP, LAHF

  \bDescription:\p

     PUSHF pushes the flags register onto the stack. POPF pops the
     value on the top of the stack into the flags register.

     PUSHF and POPF always work on the 16-bit flags register. PUSHFD
     and POPFD work on the 32-bit flags register (80386/486 only).

.context @PUSHF.des
.freeze 3
.topic PUSHF/POPF Instructions
 \i\p\aSummary\v@PUSHF\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@FindFirs.asx\v\i\p                    \i\p\aUp\v@FlagInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 10011100
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 PUSHF            ³ pushf                   ³ 88/86 10 (88=14)
 PUSHFD*          ³                         ³   286 3
                  ³                         ³   386 4
                  ³                         ³   486 4,pm=3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 10011101
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 POPF             ³ popf                    ³ 88/86 8 (88=12)
 POPFD*           ³                         ³   286 5
                  ³                         ³   386 5
                  ³                         ³   486 9,pm=6
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 80386/486 only.
.context RCL
.context @RCL
.context RCR
.context @RCR
.context ROL
.context @ROL
.context ROR
.context @ROR
.topic RCL Instruction
.freeze 3
..index left,, rotating bits, ROL Instruction
..index right,, rotating bits, ROR Instruction
..index RCL instruction, Rotate Carry Flag Bits Left
..index RCR instruction, Rotate Carry Flag Bits Right
..index ROL instruction, Rotate Operand Bits Left
..index ROR instruction, Rotate Operand Bits Right
 \i\p\aDetail\v@RCL.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@Colors.asx\v\i\p                    \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Rotate                                \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   RCL dest,count                               ñ               ñ
            ROL dest,count
            RCR dest,count
            ROR dest,count

  \bSee also:\p SHL, SHLD

  \bDescription:\p

     Rotates the bits in the destination operand the number of times
     specified in the source operand. RCL and ROL rotate the bits left;
     RCR and ROR rotate right.

     ROL and ROR rotate the number of bits in the operand. For each
     rotation, the leftmost or rightmost bit is copied to the carry
     flag as well as rotated.

     RCL and RCR rotate through the carry flag. The carry flag becomes
     an extension of the operand so that a 9-bit rotation is done for
     8-bit operands, or a 17-bit rotation for 16-bit operands.

     On the 8088 and 8086, the source operand can be either CL or 1.
     On the 80186-80486, the source operand can be CL or an 8-bit
     constant. On the 80186-80486, rotate counts larger than 31 are
     masked off, but on the 8088 and 8086, larger rotate counts can be
     performed despite the inefficiency involved.

     The overflow flag is modified only by single-bit variations of
     the instruction; for multiple-bit variations, it is undefined.

.context @RCL.des
.freeze 3
.topic RCL Instruction
 \i\p\aSummary\v@RCL\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@Colors.asx\v\i\p                    \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1101000w    mod,TTT*,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ROL  reg,1      ³ ror  ax,1               ³ 88/86 2
 ROR  reg,1      ³ rol  dl,1               ³   286 2
                 ³                         ³   386 3
                 ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 RCL  reg,1      ³ rcl  dx,1               ³ 88/86 2
 RCR  reg,1      ³ rcr  bl,1               ³   286 2
                 ³                         ³   386 9
                 ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ROL  mem,1      ³ ror  bits,1             ³ 88/86 15+EA (W88=23+EA)
 ROR  mem,1      ³ rol  WORD PTR [bx],1    ³   286 7
                 ³                         ³   386 7
                 ³                         ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 RCL  mem,1      ³ rcl  WORD PTR [si],1    ³ 88/86 15+EA (W88=23+EA)
 RCR  mem,1      ³ rcr  WORD PTR m32[0],1  ³   286 7
                 ³                         ³   386 10
                 ³                         ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * TTT represents one of the following bit codes: 000 for ROL, 001 for
    ROR, 010 for RCL, or 011 for RCR.

 1101001w    mod,TTT*,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ROL  reg,CL     ³ ror  ax,cl              ³ 88/86 8+4n
 ROR  reg,CL     ³ rol  dx,cl              ³   286 5+n
                 ³                         ³   386 3
                 ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 RCL  reg,CL     ³ rcl  dx,cl              ³ 88/86 8+4n
 RCR  reg,CL     ³ rcr  bl,cl              ³   286 5+n
                 ³                         ³   386 9
                 ³                         ³   486 8-30
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ROL  mem,CL     ³ ror  color,cl           ³ 88/86 20+EA+4n (W88=28+EA+4n)
 ROR  mem,CL     ³ rol  WORD PTR [bp+6],cl ³   286 8+n
                 ³                         ³   386 7
                 ³                         ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 RCL  mem,CL     ³ rcr  WORD PTR [bx+di],cl³ 88/86 20+EA+4n (W88=28+EA+4n)
 RCR  mem,CL     ³ rcl  masker             ³   286 8+n
                 ³                         ³   386 10
                 ³                         ³   486 9-31
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 * TTT represents one of the following bit codes: 000 for ROL, 001 for
   ROR, 010 for RCL, or 011 for RCR.

 1100000w    mod,TTT*,r/m      disp (0, 1, or 2)     data (1)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ROL  reg,immed8 ³ rol  ax,13              ³ 88/86 ÄÄ
 ROR  reg,immed8 ³ ror  bl,3               ³   286 5+n
                 ³                         ³   386 3
                 ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 RCL  reg,immed8 ³ rcl  bx,5               ³ 88/86 ÄÄ
 RCR  reg,immed8 ³ rcr  si,9               ³   286 5+n
                 ³                         ³   386 9
                 ³                         ³   486 8-30
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 ROL  mem,immed8 ³ rol  BYTE PTR [bx],10   ³ 88/86 ÄÄ
 ROR  mem,immed8 ³ ror  bits,6             ³   286 8+n
                 ³                         ³   386 7
                 ³                         ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 RCL  mem,immed8 ³ rcl  WORD PTR [bp+8],5  ³ 88/86 ÄÄ
 RCR  mem,immed8 ³ rcr  masker,3           ³   286 8+n
                 ³                         ³   386 10
                 ³                         ³   486 9-31
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * TTT represents one of the following bit codes: 000 for ROL, 001 for
    ROR, 010 for RCL, or 011 for RCR.
.context REP
.context @REP
.topic REP Instruction
.freeze 3
..index REP instruction, Repeat String
 \i\p\aDetail\v@REP.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@WinOpen.asx\v\i\p                    \i\p\aUp\v@StringInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Repeat String                         \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   REP instruction                                   -none-

  \bSee also:\p MOVS, STOS, INS, OUTS, REPE

  \bDescription:\p

     Repeats a string instruction the number of times indicated by CX.
     First CX is compared to zero; if it equals zero, execution
     proceeds to the next instruction. Otherwise, CX is decremented, the
     string instruction is performed, and the loop continues.

     REP is used with MOVS and STOS. REP can also be used with INS
     and OUTS on the 80186-80486 processors. On all processors except
     the 80386/486, combining a repeat prefix with a segment override
     may cause errors if an interrupt occurs during a string operation.
.context @REP.des
.freeze 3
.topic REP Instruction
 \i\p\aSummary\v@REP\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@WinOpen.asx\v\i\p                    \i\p\aUp\v@StringInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11110011    1010010w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 REP MOVS dest,src   ³ rep   movs source,dest  ³ 88/86 9+17n (W88=9+25n)
 REP MOVSB [dest,src]³ rep   movsw             ³   286 5+4n
 REP MOVSW [dest,src]³                         ³   386 7+4n
 REP MOVSD [dest,src]³                         ³   486 12+3n 
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11110011    1010101w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 REP STOS dest       ³ rep   stosb             ³ 88/86 9+10n (W88=9+14n)
 REP STOSB [dest]    ³ rep   stos dest         ³   286 4+3n
 REP STOSW [dest]    ³                         ³   386 5+5n
 REP STOSD [dest]    ³                         ³   486 7+4n 
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11110010    1010110w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 REP LODS dest       ³ rep   lodsb             ³ 88/86 ÄÄ
 REP LODSB [dest]    ³ rep   lods dest         ³   286 ÄÄ
 REP LODSW [dest]    ³                         ³   386 ÄÄ
 REP LODSD [dest]    ³                         ³   486 7+4n 
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11110011    0110110w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 REP INS  dest,DX    ³ rep   insb              ³ 88/86 ÄÄ
 REP INSB [dest,DX]  ³ rep   ins dest,dx       ³   286 5+4n
 REP INSW [dest,DX]  ³                         ³   386 13+6n,pm=(7,27)+6n*
 REP INSD [dest,DX]  ³                         ³   486 16+8n,pm=(10,30)+8n*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11110011    0110111w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 REP OUTS DX,src     ³ rep   outs dx,source    ³ 88/86 ÄÄ
 REP OUTSB [src]     ³ rep   outsw             ³   286 5+4n
 REP OUTSW [src]     ³                         ³   386 12+5n,pm=(6,26)+5n*
 REP OUTSD [src]     ³                         ³   486 17+5n,pm=(11,31)+5n*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * First protected-mode timing: CPL <= IOPL. Second timing: CPL > IOPL.

    5 if n = 0, 13 if n = 1.

    5 if n = 0.
.context REPE
.context @REPE
.context REPZ
.context @REPZ
.context REPNE
.context @REPNE
.context REPNZ
.context @REPNZ
.context @REPcondition
.topic REPcondition Instruction
.freeze 3
..index REPcondition instruction, Repeat String Conditionally
 \i\p\aDetail\v@REPE.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@StrCompa.asx\v\i\p                    \i\p\aUp\v@StringInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Repeat String Conditionally           \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   REPE instruction                                       ñ
            REPNE instruction

  \bSee also:\p CMPS, SCAS, REP

  \bDescription:\p

     Repeats a string instruction as long as condition is true and the
     maximum count has not been reached. The synonyms REPE and REPZ
     repeat while the zero flag is set. The synonyms REPNE and REPNZ
     repeat while the zero flag is cleared.

     The conditional repeat prefixes should only be used with SCAS and
     CMPS, since these are the only string instructions that modify the
     zero flag. Before executing the instruction, CX should be set to
     the maximum allowable number of repetitions.  First CX is compared
     to zero; if it equals zero, execution proceeds to the next
     instruction. Otherwise, CX is decremented, the string instruction
     is performed, and the loop continues.

     On all processors except the 80386/486, combining a repeat prefix
     with a segment override may cause errors if an interrupt occurs
     during a string operation.
.context @REPE.des
.freeze 3
.topic REPcondition Instruction
 \i\p\aSummary\v@REPE\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@StrCompa.asx\v\i\p                    \i\p\aUp\v@StringInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11110011     1010011w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 REPE  CMPS src,dest   ³ repz   cmpsb            ³ 88/86 9+22n (W88=9+30n)
 REPE [src,dest]       ³ repe   cmps src,dest    ³   286 5+9n
 REPE [src,dest]       ³                         ³   386 5+9n
 REPE [src,dest]       ³                         ³   486 7+7n*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11110011     1010111w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 REPE  SCAS dest       ³ repe   scas dest        ³ 88/86 9+15n (W88=9+19n)
 REPE [dest]           ³ repz   scasw            ³   286 5+8n
 REPE [dest]           ³                         ³   386 5+8n
 REPE [dest]           ³                         ³   486 7+5n*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11110010     1010011w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 REPNE CMPS src,dest   ³ repne  cmpsw            ³ 88/86 9+22n (W88=9+30n)
 REPNE [src,dest]      ³ repnz  cmps src,dest    ³   286 5+9n
 REPNE [src,dest]      ³                         ³   386 5+9n
 REPNE [src,dest]      ³                         ³   486 7+7n*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11110010     1010111w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 REPNE SCAS dest       ³ repne  scas dest        ³ 88/86 9+15n (W88=9+19n)
 REPNE [dest]          ³ repnz  scasb            ³   286 5+8n
 REPNE [dest]          ³                         ³   386 5+8n
 REPNE [dest]          ³                         ³   486 7+5n*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * 5 if n = 0.
.context RET
.context @RET
.context RETN
.context @RETN
.context RETF
.context @RETF
.topic RET Instructions
.freeze 3
..index subroutines,, returning from
..index RET instruction, Return from Procedure/Subroutine
..index RETN instruction, Near Return from Procedure/Subroutine
..index RETF instruction, Far Return from Procedure/Subroutine
 \i\p\aDetail\v@RET.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@GetMem.asx\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Return from Procedure                 \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   RET [number]                                      -none-
            RETN [number]
            RETF [number]

  \bSee also:\p CALL, PROC, IRET, INVOKE, OPTION EPILOGUE

  \bDescription:\p

     Returns from a procedure by transferring control to an address
     popped from the top of the stack. A constant operand can be given
     indicating the number of additional bytes to release.

     The constant is normally used to adjust the stack for arguments
     pushed before the procedure was called. The size of a return (near
     or far) is the size of the procedure in which the RET is defined
     with the PROC directive.

     Use RETN to specify a near return; use RETF to specify a far
     return. A near return pops a word into IP. A far return pops a
     word into IP and then pops a word into CS. After the return, the
     number of bytes given in the operand (if any) is added to SP.
.context @RET.des
.freeze 3
.topic RET Instructions
 \i\p\aSummary\v@RET\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@FindFirs.asx\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11000011
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 RET              ³ ret                     ³ 88/86 16 (88=20)
 RETN             ³ retn                    ³   286 11+m
                  ³                         ³   386 10+m
                  ³                         ³   486 5
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11000010    data (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 RET   immed16    ³ ret   2                 ³ 88/86 20 (88=24)
 RETN  immed16    ³ retn  8                 ³   286 11+m
                  ³                         ³   386 10+m
                  ³                         ³   486 5
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11001011
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 RET              ³ ret                     ³ 88/86 26 (88=34)
 RETF             ³ retf                    ³   286 15+m,pm=25+m,55*
                  ³                         ³   386 18+m,pm=32+m,62*
                  ³                         ³   486 13,pm=18,33*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11001010    data (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 RET   immed16    ³ ret   8                 ³ 88/86 25 (88=33)
 RETF  immed16    ³ retf  32                ³   286 15+m,pm=25+m,55*
                  ³                         ³   386 18+m,pm=32+m,68*
                  ³                         ³   486 14,pm=17,33*
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * The first protected-mode timing is for a return to the same
    privilege level; the second is for a return to a lesser privilege
    level.
.context SAL
.context @SAL
.context SAR
.context @SAR
.context SHL
.context @SHL
.context SHR
.context @SHR
.topic SHL Instruction
.freeze 3
..index left,, shifting bits
..index left,, shifting bits, SAL Instruction
..index right,, shifting bits, SHR Instruction
..index right,, shifting bits, SAR Instruction
..index SHL instruction, Shift Bits Left
..index SHR instruction, Shift Bits Right
..index SAL instruction, Shift Bits Left
..index SAR instruction, Shift Bits Right
 \i\p\aDetail\v@SAL.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@GetFileT.asx\v\i\p                    \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Shift                                 \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   SHL dest,count                               ñ       ñ ñ ? ñ ñ
            SAL dest,count
            SHR dest,count
            SAR dest,count

  \bSee also:\p \aSHL Operator\v@LogShiftOp\v, \aSHR Operator\v@LogShiftOp\v, ROL, 
MUL, DIV, SHLD, AND, OR,
            XOR, NOT

  \bDescription:\p

     Shifts the bits in the destination operand the number of times
     specified by the source operand. SAL and SHL shift the bits left;
     SAR and SHR shift right.

     With SHL, SAL, and SHR, the bit shifted off the end of the operand
     is copied into the carry flag and the leftmost or rightmost bit
     opened by the shift is set to 0. With SAR, the bit shifted off the
     end of the operand is copied into the carry flag and the leftmost
     bit opened by the shift retains its previous value (thus
     preserving the sign of the operand). SAL and SHL are synonyms.

     On the 8088 and 8086, the source operand can be either CL or 1. On
     the 80186-80486 processors, the source operand can be CL or an
     8-bit constant. On the 80186-80486 processors, shift counts larger
     than 31 are masked off, but on the 8088 and 8086, larger shift
     counts can be performed despite the inefficiency involved.

     The overflow flag is only modified by single-bit variations of the
     instruction; for multiple-bit variations, it is undefined.
.context @SAL.des
.freeze 3
.topic SHL Instruction
 \i\p\aSummary\v@SAL\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@GetFileT.asx\v\i\p                    \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1101000w     mod,TTT*,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SAR  reg,1      ³ sar    di,1               ³ 88/86 2
                 ³ sar    cl,1               ³   286 2
                 ³                           ³   386 3
                 ³                           ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SAL  reg,1      ³ shr    dh,1               ³ 88/86 2
 SHL  reg,1      ³ shl    si,1               ³   286 2
 SHR  reg,1      ³ sal    bx,1               ³   386 3
                 ³                           ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SAR  mem,1      ³ sar    count,1            ³ 88/86 15+EA (W88=23+EA)
                 ³                           ³   286 7
                 ³                           ³   386 7
                 ³                           ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SAL  mem,1      ³ sal    WORD PTR m32[0],1  ³ 88/86 15+EA (W88=23+EA)
 SHL  mem,1      ³ shl    index,1            ³   286 7
 SHR  mem,1      ³ shr    unsign[di],1       ³   386 7
                 ³                           ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * TTT represents one of the following bit codes: 100 for SHL or SAL,
    101 for SHR, or 111 for SAR.

 1101001w     mod,TTT*,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SAR  reg,CL     ³ sar    bx,cl              ³ 88/86 8+4n
                 ³ sar    dx,cl              ³   286 5+n
                 ³                           ³   386 3
                 ³                           ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SAL  reg,CL     ³ shr    dx,cl              ³ 88/86 8+4n
 SHL  reg,CL     ³ shl    di,cl              ³   286 5+n
 SHR  reg,CL     ³ sal    ah,cl              ³   386 3
                 ³                           ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SAR  mem,CL     ³ sar    sign,cl            ³ 88/86 20+EA+4n (W88=28+EA+4n)
                 ³ sar    WORD PTR [bp+8],cl ³   286 8+n
                 ³                           ³   386 7
                 ³                           ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SAL  mem,CL     ³ shr    WORD PTR m32[2],cl ³ 88/86 20+EA+4n (W88=28+EA+4n)
 SHL  mem,CL     ³ sal    BYTE PTR [di],cl   ³   286 8+n
 SHR  mem,CL     ³ shl    index,cl           ³   386 7
                 ³                           ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * TTT represents one of the following bit codes: 100 for SHL or SAL,
    101 for SHR, or 111 for SAR.

 11000000w    mod,TTT*,r/m      disp (0, 1, or 2)     data (1)

ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SAR  reg,immed8 ³ sar    bx,5               ³ 88/86 ÄÄ
                 ³ sar    cl,5               ³   286 5+n
                 ³                           ³   386 3
                 ³                           ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SAL  reg,immed8 ³ sal    cx,6               ³ 88/86 ÄÄ
 SHL  reg,immed8 ³ shl    di,2               ³   286 5+n
 SHR  reg,immed8 ³ shr    bx,8               ³   386 3
                 ³                           ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SAR  mem,immed8 ³ sar    sign_count,3       ³ 88/86 ÄÄ
                 ³ sar    WORD PTR [bx],5    ³   286 8+n
                 ³                           ³   386 7
                 ³                           ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SAL  mem,immed8 ³ shr    mem16,11           ³ 88/86 ÄÄ
 SHL  mem,immed8 ³ shl    unsign,4           ³   286 8+n
 SHR  mem,immed8 ³ sal    array[bx+di],14    ³   386 7
                 ³                           ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * TTT represents one of the following bit codes: 100 for SHL or SAL,
    101 for SHR, or 111 for SAR.
.context SBB
.context @SBB
.topic SBB Instruction
.freeze 3
..index SBB instruction, Subtract with Borrow
 \i\p\aDetail\v@SBB.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@SubLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Subtract with Borrow                  \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   SBB dest,src                                 ñ       ñ ñ ñ ñ ñ

  \bSee also:\p SUB, CLC, ADD, ADC

  \bDescription:\p

     Adds the carry flag to the second operand, then subtracts that
     value from the first operand. This result is assigned to the first
     operand. Use SBB to subtract the least significant portions of
     numbers that must be processed in multiple registers.
.context @SBB.des
.freeze 3
.topic SBB Instruction
 \i\p\aSummary\v@SBB\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@SubLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 000110dw     mod,reg,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SBB  reg,reg       ³ sbb    dx,cx              ³ 88/86 3
                    ³                           ³   286 2
                    ³                           ³   386 2
                    ³                           ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SBB  mem,reg       ³ sbb    WORD PTR m32[2],dx ³ 88/86 16+EA (W88=24+EA)
                    ³                           ³   286 7
                    ³                           ³   386 6
                    ³                           ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SBB  reg,mem       ³ sbb    dx,WORD PTR m32[2] ³ 88/86 9+EA (W88=13+EA)
                    ³                           ³   286 7
                    ³                           ³   386 7
                    ³                           ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 100000sw     mod,011,r/m      disp (0, 1, or 2)     data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SBB  reg,immed     ³ sbb    dx,45              ³ 88/86 4
                    ³                           ³   286 3
                    ³                           ³   386 2
                    ³                           ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SBB  mem,immed     ³ sbb    WORD PTR m32[2],40 ³ 88/86 17+EA (W88=25+EA)
                    ³                           ³   286 7
                    ³                           ³   386 7
                    ³                           ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 0001110w     data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SBB  accum,immed   ³ sb     ax,320             ³ 88/86 4
                    ³                           ³   286 3
                    ³                           ³   386 2
                    ³                           ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context SCAS
.context @SCAS
.context SCASB
.context SCASW
.context SCASD
.topic SCAS Instruction
.freeze 3
..index SCAS instruction, Scan String Flags
..index SCASB instruction, Scan String Flags (Bytes)
..index SCASW instruction, Scan String Flags (Words)
..index SCASD instruction, Scan String Flags (Doublewords)
 \i\p\aDetail\v@SCAS.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@StrFindC.asx\v\i\p                    \i\p\aUp\v@StringInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Scan String Flags                     \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   SCAS dest                                    ñ       ñ ñ ñ ñ ñ
            SCASB
            SCASW
            SCASD (80386/486 Only)

  \bDescription:\p

     Scans a string to find a value specified in the accumulator
     register. The string to be scanned is considered the destination
     and must be pointed to by ES:DI (even if an operand is specified).

     For each element, the destination element is subtracted from the
     accumulator value and the flags are updated to reflect the result
     (although the result is not stored). DI is adjusted according to
     the size of the operands and the status of the direction flag. DI
     is increased if the direction flag has been cleared with CLD or
     decreased if the direction flag has been set with STD.

     If the SCAS form of the instruction is used, an operand must be
     provided to indicate the size of the data elements to be
     processed. No segment override is allowed. If SCASB (bytes), SCASW
     (words), or SCASD (doublewords) is used, the instruction
     determines the size of the data elements to be processed and
     whether the element scanned for is in AL, AX, or EAX.

     SCAS and its variations are normally used with repeat prefixes.
     Use REPNE (or REPNZ) to find the first element in a string that
     matches the value in the accumulator. Use REPE (or REPZ) to
     find the first mismatch.

     Before the scan, CX should contain the maximum number of elements
     to scan. After a REPNE SCAS, the zero flag is clear if the string does
     not contain the accumulator value. After a REPE SCAS, the zero flag 
     is set if a the string contains nothing but the accumulator value.

     When the instruction finishes, ES:DI points to the element that follows
     (if the direction flag is clear) or precedes (if the direction flag is
     set) the match or mismatch. If CX decrements to 0, ES:DI points to the
     element that follows or precedes the last comparison. The zero flag is
     set or clear according to the result of the last comparison, not
     according to the value of CX.

.context @SCAS.des
.freeze 3
.topic SCAS Instruction
 \i\p\aSummary\v@SCAS\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@StrFindC.asx\v\i\p                    \i\p\aUp\v@StringInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1010111w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SCAS  [ES:]dest   ³ repne  scasw            ³ 88/86 15 (W88=19)
 SCASB [[ES:]dest] ³ repe   scasb            ³   286 7
 SCASW [[ES:]dest] ³ scas   es:destin        ³   386 7
 SCASD [[ES:]dest] ³                         ³   486 6
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context SETB
.context SETNAE
.context SETAE
.context SETNB
.context SETBE
.context SETNA
.context SETA
.context SETNBE
.context SETE
.context SETZ
.context SETNE
.context SETNZ
.context SETL
.context SETNGE
.context SETGE
.context SETNL
.context SETLE
.context SETNG
.context SETG
.context SETNLE
.context SETS
.context SETNS
.context SETC
.context SETNC
.context SETO
.context SETNO
.context SETP
.context SETPE
.context SETNP
.context SETPO
.context @SETcond
.topic SETcondition Instruction
.freeze 3
..index setting Boolean flags
..index SETcondition instruction, Set Conditionally
 \i\p\aDetail\v@SETcond.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Set Conditionally                     \bFlags:\p O D I T S Z A P C
            80386/486 Only                               ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                              -none-
  \bSyntax:\p   SETcondition dest

  \bSee also:\p .386, \aJcond\v@Jcond\v

  \bDescription:\p

     Sets the byte specified in the operand to 1 if <condition> is
     true or to 0 if <condition> is false. The condition is tested
     by checking the flags.
     See: \i\p\aSet Conditions Table\v@SETcondtable\v\i\p

     This instruction is used to set Boolean flags conditionally.

.context @SETcond.des
.freeze 3
.topic SETcondition Instruction
 \i\p\aSummary\v@SETcond\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    1001cond    mod,000,r/m
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SETcondition reg8  ³ setc   dh               ³ 88/86 ÄÄ
                    ³ setz   al               ³   286 ÄÄ
                    ³ setae  bl               ³   386 4
                    ³                         ³   486 true=4,false=3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SETcondition mem8  ³ seto   BTYE PTR [ebx]   ³ 88/86 ÄÄ
                    ³ setle  flag             ³   286 ÄÄ
                    ³ sete   Booleans[di]     ³   386 5
                    ³                         ³   486 true=3,false=4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context @SETcondtable
.freeze 3
..index setting Boolean flags, Set Conditions (Table)
.topic Set Conditions
 \i\p\aSummary\v@SETcond\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bOpcode\p     \bMnemonic\p      \bFlags Checked\p    \bDescription\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  10010010   SETB/SETNAE   CF=1             Set if below/not above or
                                            equal (unsigned comparisons)
  10010011   SETAE/SETNB   CF=0             Set if above or equal/not
                                            below (unsigned comparisons)
  10010110   SETBE/SETNA   CF=1 or ZF=1     Set if below or equal/not
                                            above (unsigned comparisons)
  10010111   SETA/SETNBE   CF=0 and ZF=0    Set if above/not below or
                                            equal (unsigned comparisons)
  10010100   SETE/SETZ     ZF=1             Set if equal/zero
  10010101   SETNE/SETNZ   ZF=0             Set if not equal/not zero
  10011100   SETL/SETNGE   SF<>OF           Set if less/not greater or
                                            equal (signed comparisons)
  10011101   SETGE/SETNL   SF=OF            Set if greater or equal/not
                                            less (signed comparisons)
  10011110   SETLE/SETNG   ZF=1 or SF<>OF   Set if less or equal/not greater
                                            or equal (signed comparisons)
  10011111   SETG/SETNLE   ZF=0 and SF=OF   Set if greater/not less or
                                            equal (signed comparisons)
  10011000   SETS          SF=1             Set if sign
  10011001   SETNS         SF=0             Set if not sign
  10010010   SETC          CF=1             Set if carry
  10010011   SETNC         CF=0             Set if not carry
  10010000   SETO          OF=1             Set if overflow
  10010001   SETNO         OF=0             Set if not overflow
  10011010   SETP/SETPE    PF=1             Set if parity/parity even
  10011011   SETNP/SETPO   PF=0             Set if no parity/parity odd
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context SGDT
.context @SGDT
.context SIDT
.context @SIDT
.context SLDT
.context @SLDT
.topic SGDT Instructions
.freeze 3
..index SGDT instruction, Store Global Descriptor Table
..index SIDT instruction, Store Interrupt Descriptor Table
..index SLDT instruction, Store Local Descriptor Table
 \i\p\aDetail\v@SGDT.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Store Descriptor Table                \bFlags:\p O D I T S Z A P C
            80286-80486 Only                             ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                              -none-
  \bSyntax:\p   SGDT table
            SIDT table
            SLDT table

  \bSee also:\p .286P, LGDT

  \bDescription:\p

     Stores a descriptor table register into a specified operand. SGDT
     stores the Global Descriptor Table; SIDT, the Interrupt Descriptor
     Table; and SLDT, the Local Descriptor Table. These instructions
     are available only in protected mode.

     See Intel documentation for details on descriptor tables and other
     protected-mode concepts.
.context @SGDT.des
.freeze 3
.topic SGDT Instructions
 \i\p\aSummary\v@SGDT\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    00000001    mod,000,r/m       disp (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SGDT  mem48        ³ sgdt   descriptor       ³ 88/86 ÄÄ
                    ³                         ³   286 11
                    ³                         ³   386 9
                    ³                         ³   486 10
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    00000001    mod,001,r/m       disp (2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SIDT  mem48        ³ sidt   descriptor       ³ 88/86 ÄÄ
                    ³                         ³   286 12
                    ³                         ³   386 9
                    ³                         ³   486 10
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    00000000    mod,000,r/m       disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SLDT  reg16        ³ sldt   ax               ³ 88/86 ÄÄ
                    ³                         ³   286 2
                    ³                         ³   386 2
                    ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SLDT  mem16        ³ sldt   selector         ³ 88/86 ÄÄ
                    ³                         ³   286 3
                    ³                         ³   386 2
                    ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context SHLD
.context @SHLD
.context SHRD
.context @SHRD
.topic SHLD/SHRD Instruction
.freeze 3
..index SHLD instruction, Double-Precision Shift Bits Right
..index SHRD instruction, Double-Precision Shift
 \i\p\aDetail\v@SHLD.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Double-Precision Shift                \bFlags:\p O D I T S Z A P C
            80386/486 Only                               ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                         ?       ñ ñ ? ñ ñ
  \bSyntax:\p   SHLD dest,src,count
            SHRD dest,src,count

  \bSee also:\p .386, SHL, ROL

  \bDescription:\p

     SHLD shifts the bits of the second operand into the first operand.
     The number of bits shifted is specified by the third operand. SHLD
     shifts the first operand to the left by the number of positions
     specified in the count. The positions opened by the shift are
     filled by the most significant bits of the second operand.

     SHRD shifts the first operand to the right by the number of
     positions specified in the count. The positions opened by the
     shift are filled by the least significant bits of the second
     operand. The count operand can be either CL or an 8-bit constant.
     If a shift count larger than 31 is given, it is adjusted by
     using the remainder (modulo) of a division by 32.
.context @SHLD.des
.freeze 3
.topic SHLD/SHRD Instruction
 \i\p\aSummary\v@SHLD\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    10100100    mod,reg,r/m      disp (0, 1, or 2)    data (1)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SHLD  reg16,reg16,immed8    ³ shld    ax,dx,10      ³ 88/86 ÄÄ
 SHLD  reg32,reg32,immed8    ³                       ³   286 ÄÄ
                             ³                       ³   386 3
                             ³                       ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SHLD  mem16,reg16,immed8    ³ shld    bits,cx,5     ³ 88/86 ÄÄ
 SHLD  mem32,reg32,immed8    ³                       ³   286 ÄÄ
                             ³                       ³   386 7
                             ³                       ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    10101100    mod,reg,r/m      disp (0, 1, or 2)    data (1)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SHRD  reg16,reg16,immed8    ³ shrd    cx,si,3       ³ 88/86 ÄÄ
 SHRD  reg32,reg32,immed8    ³                       ³   286 ÄÄ
                             ³                       ³   386 3
                             ³                       ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SHRD  mem16,reg16,immed8    ³ shrd    [di],dx,13    ³ 88/86 ÄÄ
 SHRD  mem32,reg32,immed8    ³                       ³   286 ÄÄ
                             ³                       ³   386 7
                             ³                       ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    10100101    mod,reg,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SHLD  reg16,reg16,CL        ³ shld    ax,dx,cl      ³ 88/86 ÄÄ
 SHLD  reg32,reg32,CL        ³                       ³   286 ÄÄ
                             ³                       ³   386 3
                             ³                       ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SHLD  mem16,reg16,CL        ³ shld    masker,ax,cl  ³ 88/86 ÄÄ
 SHLD  mem32,reg32,CL        ³                       ³   286 ÄÄ
                             ³                       ³   386 7
                             ³                       ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    10101101    mod,reg,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SHRD  reg16,reg16,CL        ³ shrd    bx,dx,cl      ³ 88/86 ÄÄ
 SHRD  reg32,reg32,CL        ³                       ³   286 ÄÄ
                             ³                       ³   386 3
                             ³                       ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SHRD  mem16,reg16,CL        ³ shrd    [bx],dx,cl    ³ 88/86 ÄÄ
 SHRD  mem32,reg32,CL        ³                       ³   286 ÄÄ
                             ³                       ³   386 7
                             ³                       ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context STOS
.context @STOS
.context STOSB
.context @STOSB
.context STOSW
.context @STOSW
.context STOSD
.context @STOSD
.topic STOS Intruction
.freeze 3
..index STOS instruction, Store String Data
..index STOSB instruction, Store String Data (Byte)
..index STOSW instruction, Store String Data (Word)
..index STOSD instruction, Store String Data (Doubleword)
 \i\p\aDetail\v@STOS.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@WinOpen.asx\v\i\p                    \i\p\aUp\v@StringInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Store String Data                     \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   STOS dest                                         -none-
            STOSB
            STOSW
            STOSD (80386/486 Only)

  \bSee also:\p REP, LODS, MOVS

  \bDescription:\p

     Stores the value in the accumulator in a string. The string 
     is the destination and must be pointed to by ES:DI even if
     an operand is given. For each source element loaded, DI is
     adjusted according to the size of the operand and the status of
     the direction flag. DI is incremented if the direction flag has been
     cleared with CLD or decremented if the direction flag has been set
     with STD.

     If the STOS form of the instruction is used, an operand must be
     provided to indicate the size of the data elements to be
     processed. No segment override is allowed.

     If STOSB (bytes), STOSW (words), or STOSD (doublewords) is used,
     the instruction determines the size of the data elements to be
     processed and whether the element comes from AL, AX, or EAX.

     STOS and its variations are often used with the REP prefix to fill a
     string with a repeated value. Before the repeated instruction is
     executed, CX should contain the number of elements to store.
.context @STOS.des
.freeze 3
.topic STOS Instruction
 \i\p\aSummary\v@STOS\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@WinOpen.asx\v\i\p                    \i\p\aUp\v@StringInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1010101w
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 STOS  [ES:]dest  ³ stos  es:dstring       ³ 88/86 11 (W88=15)
 STOSB [[ES:]dest]³ rep   stosw            ³   286 3
 STOSW [[ES:]dest]³ rep   stosb            ³   386 4
 STOSD [[ES:]dest]³                        ³   486 5
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context SUB
.context @SUB
.topic SUB Instruction
.freeze 3
..index SUB instruction, Subtract
 \i\p\aDetail\v@SUB.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@SubLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Subtract                              \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   SUB dest,src                                 ñ       ñ ñ ñ ñ ñ

  \bSee also:\p DEC, SBB, ADD

  \bDescription:\p

     Subtracts the source operand from the destination operand and
     stores the result in the destination operand.
.context @SUB.des
.freeze 3
.topic SUB Instruction
 \i\p\aSummary\v@SUB\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@SubLong.asx\v\i\p                    \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 001010dw    mod,reg,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SUB  reg,reg      ³ sub    ax,bx              ³ 88/86 3
                   ³ sub    bh,dh              ³   286 2
                   ³                           ³   386 2
                   ³                           ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SUB  mem,reg      ³ sub    tally,bx           ³ 88/86 16+EA (W88=24+EA)
                   ³ sub    array[di],bl       ³   286 7
                   ³                           ³   386 6
                   ³                           ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SUB  reg,mem      ³ sub    cx,discard         ³ 88/86 9+EA (W88=13+EA)
                   ³ sub    al,[bx]            ³   286 7
                   ³                           ³   386 7
                   ³                           ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 100000sw    mod,101,r/m      disp (0, 1, or 2)     data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SUB  reg,immed    ³ sub    dx,45              ³ 88/86 4
                   ³ sub    bl,7               ³   286 3
                   ³                           ³   386 2
                   ³                           ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SUB  mem,immed    ³ sub    total,4000         ³ 88/86 17+EA (W88=25+EA)
                   ³ sub    BYTE PTR [bx+di],2 ³   286 7
                   ³                           ³   386 7
                   ³                           ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 0010110w    data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 SUB  accum,immed  ³ sub    ax,32000           ³ 88/86 4
                   ³                           ³   286 3
                   ³                           ³   386 2
                   ³                           ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context TEST
.context @TEST
.topic TEST Instruction
.freeze 3
..index TEST instruction, Logical Compare
 \i\p\aDetail\v@TEST.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@imullong.asx\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Logical Compare                       \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   TEST dest,src                                0       ñ ñ ? ñ 0

  \bSee also:\p CMP, AND, \aJcond\v@Jcond\v

  \bDescription:\p

     Tests specified bits of an operand and sets the flags for a
     subsequent conditional jump or set instruction. One of the
     operands contains the value to be tested. The other contains a bit
     mask indicating the bits to be tested.

     TEST works by doing a bitwise AND operation on the source and
     destination operands. The flags are modified according to the
     result, but the destination operand is not changed.

     This instruction is the same as the AND instruction, except that
     the result is not stored.
.context @TEST.des
.freeze 3
.topic TEST Instruction
 \i\p\aSummary\v@TEST\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@imullong.asx\v\i\p                    \i\p\aUp\v@CFInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1000010w    mod,reg,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 TEST  reg,reg     ³ test   dx,bx             ³ 88/86 3
                   ³ test   bl,ch             ³   286 2
                   ³                          ³   386 2
                   ³                          ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 TEST  mem,reg     ³ test   dx,flags          ³ 88/86 9+EA (W88=13+EA)
 TEST  reg,mem*    ³ test   bl,bitarray[bx]   ³   286 6
                   ³                          ³   386 5
                   ³                          ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ


 1111011w    mod,000,r/m      disp (0, 1, or 2)     data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 TEST  reg,immed   ³ test   cx,30h            ³ 88/86 5
                   ³ test   cl,1011b          ³   286 3
                   ³                          ³   386 2
                   ³                          ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 TEST  mem,immed   ³ test   masker,1          ³ 88/86 11+EA
                   ³ test   BYTE PTR [bx],03h ³   286 6
                   ³                          ³   386 5
                   ³                          ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1010100w    data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 TEST  accum,immed ³ test   ax,90h            ³ 88/86 4
                   ³                          ³   286 3
                   ³                          ³   386 2
                   ³                          ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * The assembler transposes TEST reg,mem so that it is encoded as
    TEST mem,reg.
.context VERR
.context @VERR
.context VERW
.context @VERW
.topic VERR/VERW Instructions
.freeze 3
..index VERR instruction, Verify Read
..index VERW instruction, Verify Write
 \i\p\aDetail\v@VERR.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Verify Read or Write                  \bFlags:\p O D I T S Z A P C
            80286-80486 Protected Only                   ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                                   ñ
  \bSyntax:\p   VERR src
            VERW src

  \bSee also:\p .286

  \bDescription:\p

     Verifies that a specified segment selector is valid and can be
     read or written to at the current privilege level.

     VERR verifies that the selector is readable; VERW verifies that
     the selector can be written to. If the segment is verified, the
     zero flag is set. Otherwise, the zero flag is cleared.
.context @VERR.des
.freeze 3
.topic VERR/VERW Instructions
 \i\p\aSummary\v@VERR\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    00000000    mod,100,r/m     disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 VERR  reg16     ³ verr   ax               ³ 88/86 ÄÄ
                 ³                         ³   286 14
                 ³                         ³   386 10
                 ³                         ³   486 11
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 VERR  mem16     ³ verr   selector         ³ 88/86 ÄÄ
                 ³                         ³   286 16
                 ³                         ³   386 11
                 ³                         ³   486 11
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    00000000    mod,101,/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 VERW  reg16     ³ verw   cx               ³ 88/86 ÄÄ
                 ³                         ³   286 14
                 ³                         ³   386 15
                 ³                         ³   486 11
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 VERW  mem16     ³ verw   selector         ³ 88/86 ÄÄ
                 ³                         ³   286 16
                 ³                         ³   386 16
                 ³                         ³   486 11
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context WAIT
.context @WAIT
.topic WAIT Instruction
.freeze 3
..index WAIT instruction, Wait
 \i\p\aDetail\v@WAIT.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Wait                                  \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   WAIT                                              -none-

  \bSee also:\p FWAIT

  \bDescription:\p

     Suspends processor execution until the preprocessor receives a
     signal that a coprocessor has finished a simultaneous operation.

     Use WAIT to prevent a coprocessor instruction from modifying a
     memory location that is being modified simultaneously by a
     processor instruction.

     WAIT is the same as the coprocessor FWAIT instruction.
.context @WAIT.des
.freeze 3
.topic WAIT Instruction
 \i\p\aSummary\v@WAIT\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ProcCtrlInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 10011011
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 WAIT            ³ wait                    ³ 88/86 4
                 ³                         ³   286 3
                 ³                         ³   386 6
                 ³                         ³   486 1-3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context XADD
.context @XADD
.topic XADD Instruction
.freeze 3
..index XADD instruction, Exchange and Add
 \i\p\aDetail\v@XADD.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p                               \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Exchange and Add                      \bFlags:\p O D I T S Z A P C
            80486 Only                                   ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
                                                         ñ       ñ ñ ñ ñ ñ
  \bSyntax:\p   XADD dest,src

  \bSee also:\p .486, ADD, XCHG

  \bDescription:\p

     Adds the source and destination operands and stores the sum in the
     destination. The original value of the destination is moved
     simultaneously to the source. The instruction sets flags according
     to the result of the addition.
.context @XADD.des
.freeze 3
.topic XADD Instruction
 \i\p\aSummary\v@XADD\v\i\p \i\p\aKey\v@timings\v\i\p                              \i\p\aUp\v@ArithInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 00001111    1100000b   mod,reg,r/m   disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 XADD mem,reg          ³ xadd  warr[bx],ax         ³ 88/86 ÄÄ
                       ³ xadd  string,bl           ³   286 ÄÄ
                       ³                           ³   386 ÄÄ
                       ³                           ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 XADD reg,reg          ³ xadd  dl,al               ³ 88/86 ÄÄ
                       ³ xadd  bx,dx               ³   286 ÄÄ
                       ³                           ³   386 ÄÄ
                       ³                           ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context XCHG
.context @XCHG
.topic XCHG Instruction
.freeze 3
..index XCHG instruction, Exchange
 \i\p\aDetail\v@XCHG.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@IntToAsc.asx\v\i\p                    \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Exchange                              \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   XCHG dest,src                                     -none-

  \bSee also:\p MOV, XADD

  \bDescription:\p

     Exchanges the values of the source and destination operands.
.context @XCHG.des
.freeze 3
.topic XCHG Instruction
 \i\p\aSummary\v@XCHG\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@IntToAsc.asx\v\i\p                    \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 1000011w    mod,reg,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 XCHG  reg,reg       ³ xchg   cx,dx        ³ 88/86 4
                     ³ xchg   dl,dh        ³   286 3
                     ³ xchg   al,ah        ³   386 3
                     ³                     ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 XCHG  reg,mem       ³ xchg   [bx],ax      ³ 88/86 17+EA (W88=25+EA)
 XCHG  mem,reg       ³ xchg   bx,pointer   ³   286 5
                     ³                     ³   386 5
                     ³                     ³   486 5
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 10010reg
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 XCHG  accum,reg16*  ³ xchg  ax,cx         ³ 88/86 3
 XCHG  reg16,accum*  ³ xchg  cx,ax         ³   286 3
                     ³                     ³   386 3
                     ³                     ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
  * On the 80386/486, the accumulator may also be exchanged with a
    32-bit register.
.context XLAT
.context @XLAT
.context XLATB
.context @XLATB
.topic XLAT Instruction
.freeze 3
..index XLAT[B] instruction, Translate Value
 \i\p\aDetail\v@XLAT.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@BinToHex.asx\v\i\p                    \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Translate                             \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   XLAT [table]                                      -none-
            XLATB [table]

  \bDescription:\p

     Translates a value from one coding system to another by looking up
     the value to be translated in a table stored in memory.

     Before the instruction is executed, BX should point to a table in
     memory and AL should contain the unsigned position of the value to
     be translated from the table. After the instruction, AL contains
     the table value at the specified position.

     No operand is required, but one can be given to specify a segment
     override. DS is assumed unless a segment override is given.

     XLATB is a synonym for XLAT. Either version allows an operand, but
     neither requires one.
.context @XLAT.des
.freeze 3
.topic XLAT Instruction
 \i\p\aSummary\v@XLAT\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@BinToHex.asx\v\i\p                    \i\p\aUp\v@XferInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 11010111
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 XLAT   [[segreg:]mem]   ³ xlat                 ³ 88/86 11
 XLATB  [[segreg:]mem]   ³ xlatb  es:table      ³   286 5
                         ³                      ³   386 5
                         ³                      ³   486 4
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
.context XOR
.context @XOR
.topic XOR Instruction
.freeze 3
..index XOR instruction, Exclusive OR
 \i\p\aDetail\v@XOR.des\v\i\p \i\p\aKey\v@keytoflags\v\i\p \i\p\aExample\v@Colors.asx\v\i\p                    \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p    Exclusive OR                          \bFlags:\p O D I T S Z A P C
                                                         ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ
  \bSyntax:\p   XOR dest,src                                 0       ñ ñ ? ñ 0

  \bSee also:\p \aXOR Operator\v@LogShiftOp\v, AND, OR, NOT, SHL, SHR, OPTION 
NOSIGNEXTEND

  \bDescription:\p

     Performs a bitwise exclusive OR operation on the source and
     destination operands, and stores the result in the destination.

     For each bit position in the operands, if both bits are set or if
     both bits are cleared, the corresponding bit of the result is
     cleared. Otherwise, the corresponding bit of the result is set.
.context @XOR.des
.freeze 3
.topic XOR Instruction
 \i\p\aSummary\v@XOR\v\i\p \i\p\aKey\v@timings\v\i\p \i\p\aExample\v@Colors.asx\v\i\p                    \i\p\aUp\v@LogShiftInst\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 001100dw    mod,reg,r/m      disp (0, 1, or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 XOR  reg,reg    ³ xor    cx,bx            ³ 88/86 3
                 ³ xor    ah,al            ³   286 2
                 ³                         ³   386 2
                 ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 XOR  mem,reg    ³ xor    [bp+10],cx       ³ 88/86 16+EA (W88=24+EA)
                 ³ xor    masked,bx        ³   286 7
                 ³                         ³   386 6
                 ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 XOR  reg,mem    ³ xor    cx,flags         ³ 88/86 9+EA (W88=13+EA)
                 ³ xor    bl,bitarray[di]  ³   286 7
                 ³                         ³   386 7
                 ³                         ³   486 2
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 100000sw    mod,110,r/m      disp (0, 1, or 2)     data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 XOR  reg,immed  ³ xor    bx,10h           ³ 88/86 4
                 ³ xor    bl,1             ³   286 3
                 ³                         ³   386 2
                 ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÅÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 XOR  mem,immed  ³ xor    Boolean,1        ³ 88/86 17+EA (W88=25+EA)
                 ³ xor    switches[bx],101b³   286 7
                 ³                         ³   386 7
                 ³                         ³   486 3
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

 0011010w    data (1 or 2)
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÂÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
 XOR  accum,immed³ xor    ax,01010101b     ³ 88/86 4
                 ³                         ³   286 3
                 ³                         ³   386 2
                 ³                         ³   486 1
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÁÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
