.context @21.biglist
.context 021h
.context 33
.context 21h
..index interrupts,, DOS
..index Int 21h functions, Numeric List of Functions
.freeze 3
.topic Numeric List of Interrupt 21h Functions
                                             \i\p\aUp\v@DOSInt\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bInterrupt 21h\p

     \bSee also:\p \aOther MS-DOS Interrupts\v@21.misc\v

     \bFunction\p     \bName\p

     \a00h          Terminate Process\v@21h.00h\v
     \a01h          Character Input with Echo\v@21h.01h\v
     \a02h          Character Output\v@21h.02h\v
     \a03h          Auxiliary Input\v@21h.03h\v
     \a04h          Auxiliary Output\v@21h.04h\v
     \a05h          Printer Output\v@21h.05h\v
     \a06h          Direct Console I/O\v@21h.06h\v
     \a07h          Unfiltered Character Input without Echo\v@21h.01h\v
     \a08h          Character Input without Echo\v@21h.01h\v
     \a09h          Display String\v@21h.09h\v
     \a0Ah          Buffered Keyboard Input\v@21h.0Ah\v
     \a0Bh          Check Input Status\v@21h.0Bh\v
     \a0Ch          Flush Input Buffer, Then Input\v@21h.0Ch\v
     \a0Dh          Disk Reset\v@21h.0Dh\v
     \a0Eh          Select Disk\v@21h.0Eh\v
     \a0Fh          Open File (FCB)\v@21h.0Fh\v
     \a10h          Close File (FCB)\v@21h.10h\v
     \a11h          Find First File (FCB)\v@21h.11h\v
     \a12h          Find Next File (FCB)\v@21h.11h\v
     \a13h          Delete File (FCB)\v@21h.13h\v
     \a14h          Sequential Read (FCB)\v@21h.14h\v
     \a15h          Sequential Write (FCB)\v@21h.15h\v
     \a16h          Create File (FCB)\v@21h.16h\v
     \a17h          Rename File (FCB)\v@21h.17h\v
     \a19h          Get Current Drive\v@21h.19h\v
     \a1Ah          Set Data Transfer Area (DTA) Address\v@21h.1Ah\v
     \a1Bh          Get Drive Data\v@21h.1Ch\v
     \a1Ch          Get Drive Data\v@21h.1Ch\v
     \a21h          Random Read (FCB)\v@21h.21h\v
     \a22h          Random Write (FCB)\v@21h.22h\v
     \a23h          Get File Size (FCB)\v@21h.23h\v
     \a24h          Set Relative Record Number (FCB)\v@21h.24h\v
     \a25h          Set Interrupt Vector\v@21h.25h\v
     \a26h          Create New Program Segment Prefix (PSP)\v@21h.26h\v
     \a27h          Random Block Read (FCB)\v@21h.27h\v
     \a28h          Random Block Write (FCB)\v@21h.28h\v
     \a29h          Parse Filename (FCB)\v@21h.29h\v
     \a2Ah          Get Date\v@21h.2Ah\v
     \a2Bh          Set Date\v@21h.2Bh\v
     \a2Ch          Get Time\v@21h.2Ch\v
     \a2Dh          Set Time\v@21h.2Dh\v
     \a2Eh          Set Verify Flag\v@21h.2Eh\v
     \a2Fh          Get DTA Address\v@21h.2Fh\v
     \a30h          Get MS-DOS Version Number\v@21h.30h\v
     \a31h          Terminate and Stay Resident\v@21h.31h\v
     \a33h          Get or Set Break Flag\v@21h.33h\v
     \a34h          Get address of InDOS Flag\v@21h.34h\v
     \a35h          Get Interrupt Vector\v@21h.35h\v
     \a36h          Get Drive Allocation Information\v@21h.36h\v
     \a38h          Get or Set Country Information\v@21h.38h\v
     \a39h          Create Directory\v@21h.39h\v
     \a3Ah          Delete Directory\v@21h.3Ah\v
     \a3Bh          Set Current Directory\v@21h.3Bh\v
     \a3Ch          Create File\v@21h.3Ch\v
     \a3Dh          Open File\v@21h.3Dh\v
     \a3Eh          Close File\v@21h.3Eh\v
     \a3Fh          Read File or Device\v@21h.3Fh\v
     \a40h          Write to File or Device\v@21h.40h\v
     \a41h          Delete File\v@21h.41h\v
     \a42h          Set File Pointer (current location in file)\v@21h.42h\v
     \a43h          Get or Set File Attributes\v@21h.43h\v
     \a44h          IOCTL (I/O Control)\v@21h.44h\v
     \a45h          Duplicate Handle\v@21h.45h\v
     \a46h          Redirect Handle\v@21h.46h\v
     \a47h          Get Current Directory\v@21h.47h\v
     \a48h          Allocate Memory Block\v@21h.48h\v
     \a49h          Release Memory Block\v@21h.49h\v
     \a4Ah          Resize Memory Block\v@21h.4Ah\v
     \a4Bh          Execute Program (EXEC)\v@21h.4Bh\v
     \a4Ch          Terminate Process with Return Code\v@21h.4Ch\v
     \a4Dh          Get Return Code\v@21h.4Dh\v
     \a4Eh          Find First File\v@21h.4Eh\v
     \a4Fh          Find Next File\v@21h.4Fh\v
     \a50h          Set Program Segment Prefix (PSP) Address\v@21h.50h\v
     \a51h          Get Program Segment Prefix (PSP) Address\v@21h.51h\v
     \a54h          Get Verify Flag\v@21h.54h\v
     \a56h          Rename File\v@21h.56h\v
     \a57h          Get or Set File Date and Time\v@21h.57h\v
     \a58h          Get or Set Allocation Strategy\v@21h.58h\v
     \a59h          Get Extended Error Information\v@21h.59h\v
     \a5Ah          Create Temporary File\v@21h.5Ah\v
     \a5Bh          Create New File\v@21h.5Bh\v
     \a5Ch          Lock or Unlock Region of File\v@21h.5Ch\v
     \a5Eh          Get Machine Name, Get or Set Printer Setup\v@21h.5Eh\v
     \a5Fh          Device Reallocation\v@21h.5Fh\v
     \a62h          Get PSP Address\v@21h.62h\v
     \a63h          Get Lead Byte Table\v@21h.63h\v
     \a65h          Get Extended Country Information\v@21h.65h\v
     \a66h          Get or Set Code Page\v@21h.66h\v
     \a67h          Set Handle Count (sets maximum number of files)\v@21h.67h\v
     \a68h          Commit File (forces buffer to be written out)\v@21h.68h\v
     \a6Ch          Extended Open File (opens, creates, or replaces file)\v@21h.6Ch\v
     \a5D0Ah        Set Extended Error Information\v@21h.5D0Ah\v
.context @21.char
..index Int 21h functions, Character-Oriented Functions
..index character I/O functions, Interrupt 21h
.freeze 3
.topic Interrupt 21h, Character-Oriented Functions
                                             \i\p\aUp\v@DOSInt\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bInterrupt 21hÄÄCharacter-Oriented Functions\p

     \bFunction\p     \bName\p

     \a01h          Character Input with Echo\v@21h.01h\v
     \a02h          Character Output\v@21h.02h\v
     \a03h          Auxiliary Input\v@21h.03h\v
     \a04h          Auxiliary Output\v@21h.04h\v
     \a05h          Printer Output\v@21h.05h\v
     \a06h          Direct Console I/O\v@21h.06h\v
     \a07h          Unfiltered Character Input without Echo\v@21h.01h\v
     \a08h          Character Input without Echo\v@21h.01h\v
     \a09h          Display String\v@21h.09h\v
     \a0Ah          Buffered Keyboard Input\v@21h.0Ah\v
     \a0Bh          Check Input Status\v@21h.0Bh\v
     \a0Ch          Flush Input Buffer, Then Input\v@21h.0Ch\v
.context @21.dir
..index Int 21h functions, Directory Control
..index directory control, Int 21h
.freeze 3
.topic Interrupt 21h, Directory-Control Functions
                                             \i\p\aUp\v@DOSInt\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bInterrupt 21hÄÄDirectory-Control Functions\p

     \bFunction\p     \bName\p

     \a39h          Create Directory\v@21h.39h\v
     \a3Ah          Delete Directory\v@21h.3Ah\v
     \a3Bh          Set Current Directory\v@21h.3Bh\v
     \a47h          Get Current Directory\v@21h.47h\v
.context @21.disk
..index disk management, Int 21h
..index Int 21h functions, Disk Management
.freeze 3
.topic Interrupt 21h, Disk-Management Functions
                                             \i\p\aUp\v@DOSInt\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bInterrupt 21hÄÄDisk-Management Functions\p

     \bFunction\p     \bName\p

     \a0Dh          Disk Reset\v@21h.0Dh\v
     \a0Eh          Select Disk\v@21h.0Eh\v
     \a19h          Get Current Drive\v@21h.19h\v
     \a1Bh, 1Ch     Get Drive Data\v@21h.1Ch\v
     \a2Eh          Set Verify Flag\v@21h.2Eh\v
     \a36h          Get Drive Allocation Information\v@21h.36h\v
     \a54h          Get Verify Flag\v@21h.54h\v
.context @21.file
..index file operations, Int 21h
..index Int 21h functions, File Operations
.freeze 3
.topic Interrupt 21h, File Operations
                                             \i\p\aUp\v@DOSInt\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bInterrupt 21hÄÄFile Operation Functions\p

     \bFunction\p     \bName\p

     \a3Ch          Create File\v@21h.3Ch\v
     \a3Dh          Open File\v@21h.3Dh\v
     \a3Eh          Close File\v@21h.3Eh\v
     \a41h          Delete File\v@21h.41h\v
     \a43h          Get or Set File Attributes\v@21h.43h\v
     \a45h          Duplicate Handle\v@21h.45h\v
     \a46h          Redirect Handle\v@21h.46h\v
     \a4Eh          Find First File\v@21h.4Eh\v
     \a4Fh          Find Next File\v@21h.4Fh\v
     \a56h          Rename File\v@21h.56h\v
     \a57h          Get or Set File Date and Time\v@21h.57h\v
     \a5Ah          Create Temporary File\v@21h.5Ah\v
     \a5Bh          Create New File\v@21h.5Bh\v
     \a67h          Set Handle Count (sets maximum number of files)\v@21h.67h\v
     \a6Ch          Extended Open File (opens, creates, or replaces file)\v@21h.6Ch\v
.context @21.filefcb
..index file operations (FCB), Int 21h
..index Int 21h functions, File Operations (FCB)
.freeze 3
.topic Interrupt 21h, File Operations, FCB
                                             \i\p\aUp\v@DOSInt\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bInterrupt 21hÄÄFile Operation Functions (FCB)\p

     You can perform all the functions below more easily with functions
     available in DOS 2.0 and later. The services below are documented
     so you can analyze code written for earlier version of DOS.

     \bFunction\p     \bName\p

     \a0Fh          Open File\v@21h.0Fh\v
     \a10h          Close File\v@21h.10h\v
     \a11h          Find First File\v@21h.11h\v
     \a12h          Find Next File\v@21h.11h\v
     \a13h          Delete File\v@21h.13h\v
     \a16h          Create File\v@21h.16h\v
     \a17h          Rename File\v@21h.17h\v
     \a23h          Get File Size\v@21h.23h\v
     \a29h          Parse Filename\v@21h.29h\v

     \bSee also:\p \aFCB description\v@FCB\v
.context @21.mem
..index memory allocation, Int 21h
..index Int 21h functions, Memory Allocation
.topic Interrupt 21h, Memory-Allocation Functions
.freeze 3
                                             \i\p\aUp\v@DOSInt\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bInterrupt 21hÄÄMemory-Allocation Functions\p

     \bFunction\p     \bName\p

     \a48h          Allocate Memory Block\v@21h.48h\v
     \a49h          Release Memory Block\v@21h.49h\v
     \a4Ah          Resize Memory Block\v@21h.4Ah\v
     \a58h          Get or Set Allocation Strategy\v@21h.58h\v
.context @21.sysfun
..index Int 21h functions, System Functions
..index system functions, Int 21h
.freeze 3
.topic Interrupt 21h, System Functions
                                             \i\p\aUp\v@DOSInt\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bInterrupt 21hÄÄSystem Functions\p

     \bFunction\p     \bName\p

     \a25h          Set Interrupt Vector\v@21h.25h\v
     \a30h          Get MS-DOS Version Number\v@21h.30h\v
     \a33h          Get or Set Break Flag\v@21h.33h\v
     \a34h          Get Address of InDOS Flag\v@21h.34h\v
     \a35h          Get Interrupt Vector\v@21h.35h\v
     \a38h          Get or Set Country Information\v@21h.38h\v
     \a44h          IOCTL (I/O Control)\v@21h.44h\v
     \a50h          Set Program Segment Prefix (PSP) Address\v@21h.50h\v
     \a51h          Get Program Segment Prefix (PSP) Address\v@21h.51h\v
     \a59h          Get Extended Error Information\v@21h.59h\v
     \a5Eh          Get Machine Name, Get or Set Printer Setup\v@21h.5Eh\v
     \a5Fh          Device Reallocation\v@21h.5Fh\v
     \a63h          Get Lead Byte Table\v@21h.63h\v
     \a65h          Get Extended Country Information\v@21h.65h\v
     \a66h          Get or Set Code Page\v@21h.66h\v
     \a5D0Ah        Set Extended Error Information\v@21h.5D0Ah\v
.context @21.process
..index process control, Int 21h
..index Int 21h functions, Process Control
.freeze 3
.topic Interrupt 21h, Process-Control Functions
                                             \i\p\aUp\v@DOSInt\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bInterrupt 21hÄÄProcess-Control Functions\p

     \bFunction\p     \bName\p

     \a00h          Terminate Process\v@21h.00h\v
     \a26h          Create New Program Segment Prefix (PSP)\v@21h.26h\v
     \a31h          Terminate and Stay Resident\v@21h.31h\v
     \a4Bh          Execute Program (EXEC)\v@21h.4Bh\v
     \a4Ch          Terminate Process with Return Code\v@21h.4Ch\v
     \a4Dh          Get Return Code\v@21h.4Dh\v
     \a62h          Get PSP Address\v@21h.62h\v
.context @21.rec
..index Int 21h functions, Record Functions
..index recording functions, Int 21h
.freeze 3
.topic Interrupt 21h, Record Functions
                                             \i\p\aUp\v@DOSInt\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bInterrupt 21hÄÄRecord Functions\p

     \bFunction\p     \bName\p

     \a1Ah          Set Data Transfer Area (DTA) Address\v@21h.1Ah\v
     \a2Fh          Get DTA Address\v@21h.2Fh\v
     \a3Fh          Read File or Device\v@21h.3Fh\v
     \a40h          Write to File or Device\v@21h.40h\v
     \a42h          Set File Pointer (current location in file)\v@21h.42h\v
     \a5Ch          Lock or Unlock Region of File\v@21h.5Ch\v
     \a68h          Commit File (forces buffer to be written out)\v@21h.68h\v
.context @21.recfcb
..index Int 21h functions, Record Functions (FCB)
..index recording functions (FCB), Int 21h
.freeze 3
.topic Interrupt 21h, Record Functions (FCB)
                                             \i\p\aUp\v@DOSInt\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bInterrupt 21hÄÄRecord Functions (FCB)\p

     You can perform all the functions below more easily with functions
     available in DOS 2.0 and later. The services below are documented
     so you can analyze code written for earlier version of DOS.

     \bFunction\p     \bName\p

     \a14h          Sequential Read\v@21h.14h\v
     \a15h          Sequential Write\v@21h.15h\v
     \a21h          Random Read\v@21h.21h\v
     \a22h          Random Write\v@21h.22h\v
     \a24h          Set Relative Record Number\v@21h.24h\v
     \a27h          Random Block Read\v@21h.27h\v
     \a28h          Random Block Write\v@21h.28h\v

     \bSee also:\p \aFCB Description\v@FCB\v
.context @21.time
..index Int 21h functions, Time/Date Functions
..index time/date functions, Int 21h
.freeze 3
.topic Interrupt 21h, Time and Date Functions
                                             \i\p\aUp\v@DOSInt\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bInterrupt 21hÄÄTime and Date Functions\p

     \bFunction\p     \bName\p

     \a2Ah          Get Date\v@21h.2Ah\v
     \a2Bh          Set Date\v@21h.2Bh\v
     \a2Ch          Get Time\v@21h.2Ch\v
     \a2Dh          Set Time\v@21h.2Dh\v

     \bSee also:\p \aDOS File Date/Time Formats\v@Datime\v

.context @21.misc
.freeze 3
.topic Other DOS Interrupts
                                             \i\p\aUp\v@DOSInt\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bOther DOS Interrupts\p

     \bInterrupt\p     \bName\p

     \a20h           Terminate Program\v@20h\v
     \a22h           Program Termination Handler\v@22h\v
     \a23h           Ctrl+C Handler\v@23h\v
     \a24h           Critical Error Handler\v@24h\v
     \a25h           Read Disk Sector (ignore logical structure)\v@25h\v
     \a26h           Write Disk Sector (ignore logical structure)\v@26h\v
     \a27h           Terminate and Stay Resident\v@27h\v
     \a28h           DOS Idle\v@28h\v
     \a2Fh           Multiplex Interrupt\v@2Fh\v
.context @21h.5Eh
..index Int 21h Function 5Eh, Machine/Printer
.freeze 3
.topic Interrupt 21h, Function 5Eh (Machine/Printer)
                                             \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bInterrupt 21hÄÄFunction 5Eh (Machine/Printer)\p

     \bSubfunction\p     \bName\p

     \a00h             Get Machine Name\v@21h.5Eh.00h\v
     \a02h             Set Printer Setup String\v@21h.5Eh.02h\v
     \a03h             Get Printer Setup String\v@21h.5Eh.03h\v
.context @21h.5Fh
..index Int 21h Function 5Fh, Device Redirection
.freeze 3
.topic Interrupt 21h, Function 5Fh (Device Redirection)
                                             \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bInterrupt 21hÄÄFunction 5Fh (Device Redirection)\p

     \bSubfunction\p     \bName\p

     \a02h             Get Redirection List Entry\v@21h.5Fh.02h\v
     \a03h             Redirect Device\v@21h.5Fh.03h\v
.context @errcod
..index MS-DOS extended error codes
..index DOS extended error codes
..index error codes, MS-DOS Extended
.freeze 3
.topic List of MS-DOS Extended Error Codes
                                             \i\p\aUp\v@DOSInt\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     \bMS-DOS Extended Error Codes\p

     \bValue\p     \bMeaning\p

     01h       function number invalid
     02h       file not found
     03h       path not found
     04h       too many open files
     05h       access denied
     06h       handle invalid
     07h       memory control blocks destroyed
     08h       insufficient memory
     09h       memory block address invalid
     0Ah       environment invalid
     0Bh       format invalid
     0Ch       access code invalid
     0Dh       data invalid
     0Eh       unknown unit
     0Fh       disk drive invalid
     10h       attempted to remove current directory
     11h       not same device
     12h       no more files
     13h       disk write-protected
     14h       unknown unit
     15h       drive not ready
     16h       unknown command
     17h       data error (CRC)
     18h       bad request structure length
     19h       seek error
     1Ah       unknown media type
     1Bh       sector not found
     1Ch       printer out of paper
     1Dh       write fault
     1Eh       read fault
     1Fh       general failure
     20h       sharing violation
     21h       lock violation
     22h       disk change invalid
     23h       FCB unavailable
     24h       sharing buffer exceeded
     25h       code page mismatched
     26h       handle end of file operation not completed
     27h       disk full
     28h-31h   reserved
     32h       unsupported network request
     33h       remote machine not listening
     34h       duplicate name on network
     35h       network name not found
     36h       network busy
     37h       device no longer exists on network
     38h       netBIOS command limit exceeded
     39h       error in network adapter hardware
     3Ah       incorrect response from network
     3Bh       unexpected network error
     3Ch       remote adapter incompatible
     3Dh       print queue full
     3Eh       not enough room for print file
     3Fh       print file was deleted
     40h       network name deleted
     41h       network access denied
     42h       incorrect network device type
     43h       network name not found
     44h       network name limit exceeded
     45h       netBIOS session limit exceeded
     46h       temporary pause
     47h       network requested not accepted
     48h       print or disk redirection paused
     49h-4Fh   reserved
     50h       file already exists
     51h       duplicate FCB
     52h       cannot make directory
     53h       fail on Int 24H (critical error)
     54h       too many redirections
     55h       duplicate redirection
     56h       invalid password
     57h       invalid parameter
     58h       net write fault
     59h       function not supported by network
     5Ah       required system component not installed
     65h       device not selected
.context 20h
.context 020h
.context @20h
.context 32
.freeze 3
.topic Interrupt 20h
 \i\p\aDetail\v@20h.des\v\i\p                                    \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   20h

  \bTitle:\p       Terminate Process

  \bSee also:\p    \aProgram Segment Prefix Chart\v@SegmentPrefix\v,
               \aTerminate Process with Return Code\v@21h.4Ch\v

     \bDescription:\p

     Terminates the current process. This is one of several methods
     that a program can use to perform a final exit.

     \bInput\p                           \bOutput\p

     CS = Segment address of         None
          program segment prefix
.context @20h.des
.freeze 3
.topic Int 20h
 \i\p\aSummary\v@20h\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If the program is returning to COMMAND.COM, control transfers to
     the resident portion, and the transient portion is reloaded if
     necessary. If a batch file is in progress, the next line of the
     file is fetched and interpreted; otherwise, a prompt is issued for
     the next user command.

     MS-DOS then takes the following actions:

        ş All memory belonging to the process is released.

        ş File buffers are flushed, and any open handles for files or
          devices owned by the process are closed.

        ş The termination handler vector (\aInt 22h\v@22h\v) is restored
          from PSP:000Ah.

        ş The CTRL+C handler vector (\aInt 23h\v@23h\v) is restored from
          PSP:000Eh.

        ş The critical-error handler vector (\aInt 24h\v@24h\v) is restored
          from PSP:0012h (MS-DOS versions 2.0 and later).

        ş Control is transferred to the termination handler.

     Any files that have been written to using FCBs should be closed
     before performing this exit call; otherwise, data may be lost.

     Other methods of performing a final exit are \aInt 21h Function 00h\v@21h.00h\v,
     \aInt 21h Function 31h\v@21h.31h\v, \aInt 21h Function 4Ch\v@21h.4Ch\v, and \aInt 27h\v@27h\v.

     If the program is running on a network, it should remove all locks
     it has placed on file regions before terminating.

     Int 21h Functions 31h and 4Ch are the preferred method for
     termination because they allow a return code to be passed to the
     parent process.
.context @21h.00h
.freeze 3
.topic Int 21h Function 00h
 \i\p\aDetail\v@21h.00h.des\v\i\p                                    \i\p\aUp\v@21.process\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   00h

  \bTitle:\p       Terminate Process

  \bSee also:\p    \aTerminate Process with Return Code\v@21h.4Ch\v

  \bDescription:\p

     Terminates the current process. This is one of several methods
     that a program can use to perform a final exit.

     \bInput                           Output\p

     AH = 00h                        None
     CS = Segment address of
          program segment prefix
.context @21h.00h.des
.freeze 3
.topic Int 21h Function 00h
 \i\p\aSummary\v@21h.00h\v\i\p                                   \i\p\aUp\v@21.process\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     After performing a final exit, MS-DOS takes the following actions:

        ş All memory belonging to the process is released.

        ş File buffers are flushed, and any open handles for files or
          devices owned by the process are closed.

        ş The termination handler vector (Int 22h) is restored from
          PSP:000Ah.

        ş The CTRL+C handler vector (Int 23h) is restored from
          PSP:000Eh.

        ş The critical-error handler vector (Int 24h) is restored from
          PSP:0012h.

        ş Control is transferred to the termination handler.

     If the program is returning to COMMAND.COM, control transfers to
     the resident portion, and the transient portion is reloaded if
     necessary. If a batch file is in progress, the next line of the
     file is fetched and interpreted; otherwise, a prompt is issued for
     the next user command.

     Any files that have been written to using FCBs should be closed
     before performing this exit call; otherwise, data may be lost.

     Other methods of performing a final exit are Int 20h, Int 21h
     Function 31h, Int 21h Function 4Ch, and Int 27h. Int 21h Functions
     31h and 4Ch are the preferred method for termination because they
     allow a return code to be passed to the parent process.

     [Version 3.0+]
     If the program is running on a network, it should remove all locks
     it has placed on file regions before terminating.
.context @21h.01h
.freeze 3
.topic Int 21h Functions 01h, 07h, and 08h
 \i\p\aDetail\v@21h.01h.des\v\i\p                                    \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunctions:\p  01h, 07h, and 08h

  \bTitle:\p       Character Input

  \bSee also:\p    \aASCII Chart\vpwb.hlp!ascii\v, \aExtended Key Codes\v@XKeyChart\v, \aDirect Console I/O\v@21h.06h\v,
               \aRead Character from Keyboard\v@16h.00h\v, \aBuffered Keyboard Input\v@21h.0Ah\v,
               \aRead File or Device\v@21h.3Fh\v, @GetChar

  \bDescription:\p

     Reads a character from the standard input device. If no character
     is ready, the function waits until one is available. Input can be
     redirected. However, if input has been redirected, there is no
     way to detect EOF.

     \bInput                                    Output\p

     AH = 01h for filtered with echo          AL = 8-bit input data
        = 07h for unfiltered without echo
        = 08h for filtered without echo
.context @21h.01h.des
.freeze 3
.topic Int 21h Functions 01h, 07h, and 08h
 \i\p\aSummary\v@21h.01h\v\i\p                                   \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The character is echoed to the standard output device for Function
     01h, but not for Functions 07h and 08h.

     Functions 01h and 08h are filtered for CTRL+C. If the standard
     input is not redirected, BREAK is OFF, and the character read is
     CTRL+C, an Int 23h is executed. Function 07h treats CTRL+C the
     same as any other key.

     To read extended ASCII codes (such as the special function keys F1
     to F10) on the IBM PC and compatibles, you must call this function
     twice. The first call returns the value 00h to signal the presence
     of an extended code.

     You can also read the keyboard by issuing the \aRead File or Device\v@21h.3Fh\v
     function using the predefined handle for the standard input (0) if
     input has not been redirected. Or you can read using a handle
     obtained by opening the logical device CON.
.context @21h.02h
.freeze 3
.topic Int 21h Function 02h
 \i\p\aDetail\v@21h.02h.des\v\i\p \i\p\aExample\v@putstr.asm\v\i\p                          \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   02h

  \bTitle:\p       Character Output

  \bSee also:\p    \aWrite Character at Cursor\v@10h.0Ah\v, \aWrite Character and Attribute\v@10h.09h\v
               \aat Cursor\v@10h.09h\v, \aDisplay String\v@21h.09h\v, \aPrinter Output\v@21h.05h\v, @ShowChar

  \bDescription:\p

     Outputs a character to the standard output device. Output can be
     redirected. However if output is redirected, there is no way to
     detect that the disk is full.

     \bInput                          Output\p

     AH = 02h                       None
     DL = 8-bit data for output
.context @21h.02h.des
.freeze 3
.topic Int 21h Function 02h
 \i\p\aSummary\v@21h.02h\v\i\p \i\p\aExample\v@putstr.asm\v\i\p                         \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If CTRL+C is detected at the keyboard after the requested
     character is output, an Int 23h is executed.

     If the standard output has not been redirected, a backspace code
     (08h) causes the cursor to move left one position. If output has
     been redirected, the backspace code does not receive any special
     treatment.

     You can send strings to the display by performing a write (Int 21h
     Function 40h) using the predefined handle for the standard output
     (0001h) if output has not been redirected. You can also perform a
     write using a handle obtained by opening the logical device CON.
.context @21h.03h
.freeze 3
.topic Int 21h Function 03h
 \i\p\aDetail\v@21h.03h.des\v\i\p                                    \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   03h

  \bTitle:\p       Auxiliary Input

  \bSee also:\p    \aRead Character from Communications Port\v@14h.02h\v, \aAuxiliary Output\v@21h.04h\v

  \bDescription:\p

     Reads a character from the standard auxiliary device. The default
     is the first serial port (COM1).

     \bInput        Output\p

     AH = 03h     AL = 8-bit input data
.context @21h.03h.des
.freeze 3
.topic Int 21h Function 03h
 \i\p\aSummary\v@21h.03h\v\i\p                                   \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     In most MS-DOS systems, the serial device is unbuffered and is not
     interrupt driven. If the auxiliary device sends data faster than
     your program can process it, characters may be lost.

     At startup on the IBM PC, PC-DOS initializes the first serial port
     to 2400 baud, no parity, 1 stop bit, and 8 data bits. Other
     implementations of MS-DOS may initialize the serial device
     differently.

     There is no way for a user program to read the status of the
     auxiliary device or to detect I/O errors (such as lost characters)
     through this function call. On the IBM PC, more precise control
     can be obtained by calling ROM BIOS Int 14h or by driving the
     communications controller directly.

     If CTRL+C is detected at the keyboard, an Int 23h is executed.

     You can also input from the auxiliary device by requesting a read
     (Int 21h Function 3Fh) using the predefined handle for the
     standard auxiliary device (0003h) or using a handle obtained by
     opening the logical device AUX.
.context @21h.04h
.freeze 3
.topic Int 21h Function 04h
 \i\p\aDetail\v@21h.04h.des\v\i\p                                    \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   04h

  \bTitle:\p       Auxiliary Output

  \bSee also:\p    \aWrite Character to Communications Port\v@14h.01h\v, \aAuxiliary Input\v@21h.03h\v

  \bDescription:\p

     Outputs a character to the standard auxiliary device. The default
     is the first serial port (COM1).

     \bInput                          Output\p

     AH = 04h                       None
     DL = 8-bit data for output
.context @21h.04h.des
.freeze 3
.topic Int 21h Function 04h
 \i\p\aSummary\v@21h.04h\v\i\p                                   \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If the output device is busy, this function waits until the device
     is ready to accept a character.

     There is no way to poll the status of the auxiliary device using
     this function. On the IBM PC, more precise control can be obtained
     by calling ROM BIOS Int 14h or by driving the communications
     controller directly.

     If CTRL+C is detected at the keyboard, an Int 23h is executed.

     You can also send strings to the auxiliary device by performing a
     write (Int 21h Function 40h) using the predefined handle for the
     standard auxiliary device (0003h) or using a handle obtained by
     opening the logical device AUX.
.context @21h.05h
.freeze 3
.topic Int 21h Function 05h
 \i\p\aDetail\v@21h.05h.des\v\i\p                                    \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   05h

  \bTitle:\p       Printer Output

  \bSee also:\p    \aWrite Character to Printer\v@17h.00h\v, \aCharacter Output\v@21h.02h\v, @PrtChar

  \bDescription:\p

     Sends a character to the standard list device. The default is the
     printer on the first parallel port (LPT1), unless explicitly
     redirected by the user with the MODE command.

     \bInput                          Output\p

     AH = 05h                       None
     DL = 8-bit data for output
.context @21h.05h.des
.freeze 3
.topic Int 21h Function 05h
 \i\p\aSummary\v@21h.05h\v\i\p                                   \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If the printer is busy, this function waits until the printer is
     ready to accept the character.

     There is no standardized way to poll the status of the printer
     under MS-DOS.

     If CTRL+C is detected at the keyboard, an Int 23h is executed.

     You can also send strings to the printer by performing a write
     (Int 21h Function 40h) using the predefined handle for the
     standard printer device (0004h) or using a handle obtained by
     opening the logical device PRN or LPT1.
.context @21h.06h
.freeze 3
.topic  Int 21h Function 06h
 \i\p\aDetail\v@21h.06h.des\v\i\p \i\p\aExample\v@veriansi.asx\v\i\p                          \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   06h

  \bTitle:\p       Direct Console I/O

  \bSee also:\p    \aCharacter Input\v@21h.01h\v, \aCharacter Output\v@21h.02h\v

  \bDescription:\p

     Used by programs that need to read and write all possible
     characters and control codes without any interference from the
     operating system. Reads a character from the standard input device
     or writes a character to the standard output device. I/O may be
     redirected. However, if I/O has been redirected, there is no way
     to detect EOF or that the disk is full.

     \bInput                               Output\p

     AH = 06h                            If called with DL = 00h-0FEh
     DL = Function requested               None
        = 00h-FEh (if output request)
        = 0FFh (if input request)        If called with DL = FFh and a
                                         character is ready
                                           Zero flag: clear
                                           AL = 8-bit input data

                                         If called with DL = FFh and no
                                         character is ready
                                           Zero flag: set
.context @21h.06h.des
.freeze 3
.topic Int 21h Function 06h
 \i\p\aSummary\v@21h.06h\v\i\p \i\p\aExample\v@VeriAnsi.asx\v\i\p                         \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     No special action is taken upon entry of CTRL+C when this
     function is used.

     To read extended ASCII codes (such as the special function keys F1
     to F10) on the IBM PC and compatibles, you must call this function
     twice. The first call returns the value 00h to signal the presence
     of an extended code.

     You can read the keyboard by issuing a read (Int 21h Function
     3Fh) using the predefined handle for the standard input (0000h)
     if input has not been redirected or a handle obtained by opening
     the logical device CON.

     You can send characters to the display by issuing a write (Int 21h
     Function 40h) using the predefined handle for the standard output
     (0001h) if output has not been redirected. You can also issue a
     write using a handle obtained by opening the logical device CON.
.context @21h.09h
.freeze 3
.topic Int 21h Function 09h
 \i\p\aDetail\v@21h.09h.des\v\i\p \i\p\aExample\v@hello.asm\v\i\p                          \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   09h

  \bTitle:\p       Display String

  \bSee also:\p    \aWrite to File or Device\v@21h.40h\v, \aCharacter Output\v@21h.02h\v, @ShowStr

  \bDescription:\p

     Sends a string of characters to the standard output device. Output
     may be redirected. However, if output has been redirected, there
     is no way to detect that the disk is full.

     \bInput                                Output\p

     AH = 09h                             None
     DS:DX = segment:offset of string
.context @21h.09h.des
.freeze 3
.topic Int 21h Function 09h
 \i\p\aSummary\v@21h.09h\v\i\p \i\p\aExample\v@hello.asm\v\i\p                         \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The string must be terminated with the character $ (24h), which is
     not transmitted. Any other ASCII codes, including control codes,
     can be embedded in the string.

     See Int 21h Functions 02h and 06h for single-character output to
     the video display or standard output device.

     If CTRL+C is detected at the keyboard, an Int 23h is executed.

     You can also send strings to the display by performing a write
     (Int 21h Function 40h) using either the predefined handle for the
     standard output (0001h) if it has not been redirected or a handle
     obtained by opening the logical device CON.
.context @21h.0Ah
.freeze 3
.topic Int 21h Function 0Ah
 \i\p\aDetail\v@21h.0Ah.des\v\i\p \i\p\aExample\v@GetStr.asx\v\i\p                          \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   0Ah

  \bTitle:\p       Buffered Keyboard Input

  \bSee also:\p    \aRead File or Device\v@21h.3Fh\v, \aCharacter Input\v@21h.01h\v, @GetStr

  \bDescription:\p

     Reads a string of bytes from the standard input device, up to and
     including an ASCII carriage return (0Dh), and places it in a
     user-designated buffer. The characters are echoed to the standard
     output device. Input may be redirected. However, if input has been
     redirected, there is no way to detect EOF.

     \bInput                                Output\p

     AH = 0Ah                             None
     DS:DX = segment:offset of buffer
.context @21h.0Ah.des
.freeze 3
.topic Int 21h Function 0Ah
 \i\p\aSummary\v@21h.0Ah\v\i\p \i\p\aExample\v@GetStr.asx\v\i\p                         \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The buffer used by this function has the following format:

     \bByte     Contents\p

     0        Maximum number of characters to read, set by program
     1        Number of characters actually read (excluding carriage
              return), set by MS-DOS
     2+       String read from keyboard or standard input, terminated
              by a carriage return (0Dh)

     If the buffer fills to one fewer than the maximum number of
     characters it can hold, subsequent input is ignored and the bell
     is sounded until a carriage return is detected.

     This input function is buffered with type-ahead capability, and
     all of the standard keyboard editing commands are active.

     If the standard input is not redirected, BREAK is OFF, and CTRL+C
     is detected at the console, an Int 23h is not executed.

     See Int 21h Functions 01h, 06h, 07h, and 08h for single-character
     input from the keyboard or standard input device.

     You can also read strings from the keyboard by performing a read
     (Int 21h Function 3Fh) using either the predefined handle for the
     standard input (0000h) if it has not been redirected or a handle
     obtained by opening the logical device CON.
.context @21h.0Bh
.freeze 3
.topic Int 21h Function 0Bh
 \i\p\aDetail\v@21h.0Bh.des\v\i\p                                    \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   0Bh

  \bTitle:\p       Check Input Status

  \bSee also:\p    \aGet Keyboard Status\v@16h.01h\v, \aCharacter Input\v@21h.01h\v

  \bDescription:\p

     Checks whether a character is available from the standard input
     device. Input can be redirected.

     \bInput        Output\p

     AH = 0Bh     AL = 00h (if no character is available)
                     = FFh (if at least one character is
                            available)
.context @21h.0Bh.des
.freeze 3
.topic Int 21h Function 0Bh
 \i\p\aSummary\v@21h.0Bh\v\i\p                                   \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If CTRL+C is detected, an Int 23h is executed.

     If the standard input is not redirected and CTRL+C is detected at
     the console, an Int 23h is executed. If the standard input is
     redirected, CTRL+C is detected at the console, and BREAK is ON, an
     Int 23h is executed.

     If a character is waiting, this function will continue to return a
     true flag until the character is consumed with a call to Int 21h
     Function 01h, 06h, 07h, 08h, 0Ah, or 3Fh.

     This function is equivalent to \aIOCTL Int 21h Function 44h\v@21h.44h.06h\v
     \aSubfunction 06h\v@21h.44h.06h\v.
.context @21h.0Ch
.freeze 3
.topic Int 21h Function 0Ch
 \i\p\aDetail\v@21h.0Ch.des\v\i\p \i\p\aExample\v@VeriAnsi.asx\v\i\p                          \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   0Ch

  \bTitle:\p       Flush Input Buffer and Then Input

  \bSee also:\p    \aCharacter Input\v@21h.01h\v, \aDirect Console I/O\v@21h.06h\v,
               \aBuffered Keyboard Input\v@21h.0Ah\v

  \bDescription:\p

     Clears the standard input buffer and then invokes one of the
     character input functions. Input can be redirected.

     \bInput                                  Output\p

     AH = 0Ch                               If called with AL = 01h, 06h,
     AL = Number of input function          07h, or 08h
          to be invoked after resetting       AL = 8-bit input data
          buffer (must be 01h, 06h,
          07h, 08h, or 0Ah)                 If called with AL = 0Ah
                                              None
     If AL = 0Ah
       DS:DX = segment:offset of
               input buffer
.context @21h.0Ch.des
.freeze 3
.topic Int 21h Function 0Ch
 \i\p\aSummary\v@21h.0Ch\v\i\p \i\p\aExample\v@VeriAnsi.asx\v\i\p                         \i\p\aUp\v@21.char\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function exists to allow a program to defeat MS-DOS's
     type-ahead feature. It discards any characters that are waiting in
     MS-DOS's internal type-ahead buffer, forcing the specified input
     function to wait for a character (usually a keyboard entry) that
     is truly entered after the program's request.

     The presence or absence of CTRL+C checking during execution of
     this function depends on the function number in register AL.

     A function number in AL other than 01h, 06h, 07h, 08h, or 0Ah
     simply flushes the input buffer and returns control to the calling
     program.
.context @21h.0Dh
.freeze 3
.topic Int 21h Function 0Dh
 \i\p\aDetail\v@21h.0Dh.des\v\i\p                                    \i\p\aUp\v@21.disk\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   0Dh

  \bTitle:\p       Disk Reset

  \bSee also:\p    \aCommit File\v@21h.68h\v

  \bDescription:\p

     Flushes all file buffers. All data that has been logically written
     by user programs but has been temporarily buffered within MS-DOS
     is physically written to the disk.

     \bInput        Output\p

     AH = 0Dh     None
.context @21h.0Dh.des
.freeze 3
.topic Int 21h Function 0Dh
 \i\p\aSummary\v@21h.0Dh\v\i\p                                   \i\p\aUp\v@21.disk\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function does not update the disk directory for any files
     that are still open. If your program fails to properly close all
     files before the disk is removed, and files have changed size, the
     data forced out to the disk by this function may still be
     inaccessible because the directory entries will not be correct.

     [Version 3.3+]
     Int 21h Function 68h (Commit File) should be used instead of this
     function because it also updates the disk directory and file
     allocation table.
.context @21h.0Eh
.freeze 3
.topic Int 21h Function 0Eh
 \i\p\aDetail\v@21h.0Eh.des\v\i\p \i\p\aExample\v@ChangeDi.asx\v\i\p                          \i\p\aUp\v@21.disk\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   0Eh

  \bTitle:\p       Select Disk

  \bSee also:\p    \aGet Current Drive\v@21h.19h\v, @SetDrv

  \bDescription:\p

     Selects the specified drive to be the current, or default, disk
     drive and returns the total number of logical drives in the
     system.

     \bInput                                    Output\p

     AH = 0Eh                                 AL = Number of logical
     DL = Drive code (0 = A, 1 = B,...)            drives in system
.context @21h.0Eh.des
.freeze 3
.topic Int 21h Function 0Eh
 \i\p\aSummary\v@21h.0Eh\v\i\p \i\p\aExample\v@Changedi.asx\v\i\p                         \i\p\aUp\v@21.disk\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     63 drive designators (0 through 3Fh) are available.

     [Version 3.0+]
     26 drive designators (0 through 19h) are available.

     To preserve upward compatibility, new applications should limit
     themselves to the drive letters A-Z (for example, 0 = A and 1 = B).

     Logical drives means the total number of block devices: floppy
     disks, simulated disk drives (RAMdisks), and hard-disk drives. A
     single physical hard-disk drive is frequently partitioned into two
     or more logical drives.

     In single-drive IBM PC-compatible systems, the value 2 is returned
     in AL, because PC-DOS supports two logical drives (A: and B:) on
     the single physical floppy-disk drive. The actual number of
     physical drives in the system can be determined with ROM BIOS Int
     11h.

     [Version 3.0+]
     The value returned in AL is either 5 or the drive code
     corresponding to the LASTDRIVE entry (if any) in CONFIG.SYS,
     whichever is greater.
.context @21h.0Fh
.freeze 3
.topic Int 21h Function 0Fh
 \i\p\aDetail\v@21h.0Fh.des\v\i\p                                    \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   0Fh

  \bTitle:\p       Open File

  \bSee also:\p    \aOpen File (handle)\v@21h.3Dh\v

  \bDescription:\p

     Opens a file and makes it available for subsequent read/write
     operations.

     \bInput                       Output\p

     AH = 0Fh                    If function successful (file found)
     DS:DX = segment:offset        AL = 00
             of file control     And FCB filled in by MS-DOS as
             block               follows:
                                 ş Drive field (offset 00h0) = 1 for
                                   drive A, 2 for drive B,...
                                 ş Current block field (offset 0Ch) = 00h
                                 ş Record size field (offset 0Eh) = 0080h
                                 ş Size field (offset 10h) = File size
                                   from directory
                                 ş Date field (offset 14h) = Date stamp
                                   from directory
                                 ş Time field (offset 16h) = Time stamp
                                   from directory

                                 If function unsuccessful
                                 (file not found)
                                   AL = 0FFh
.context @21h.0Fh.des
.freeze 3
.topic Int 21h Function 0Fh
 \i\p\aSummary\v@21h.0Fh\v\i\p                                   \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If your program is going to use a record size other than 128
     bytes, it should set the record size field at FCB offset 0Eh after
     the file is successfully opened and before any other disk
     operation.

     If random access is to be performed, the calling program must also
     set the FCB relative-record field (offset 21h) after successfully
     opening the file.

     For format of directory time and date, see Int 21h Function 57h.

     Int 21h Function 3Dh, which allows full access to the hierarchical
     directory structure, should be used instead of this function.

     [Version 3.0+]
     If the program is running on a network, the file is opened for
     read/write access in compatibility sharing mode.
.context @21h.10h
.freeze 3
.topic Int 21h Function 10h
 \i\p\aDetail\v@21h.10h.des\v\i\p                                    \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   10h

  \bTitle:\p       Close File

  \bSee also:\p    \aClose File (handle)\v@21h.3Eh\v

  \bDescription:\p

     Closes a file, flushes all MS-DOS internal disk buffers associated
     with the file to disk, and updates the disk directory if the file
     has been modified or extended.

     \bInput                              Output\p

     AH = 10h                           If function successful
     DS:DX = segment:offset of file     (directory update successful)
             control block                AL = 00h

                                        If function unsuccessful (file
                                        not found in directory)
                                          AL = FFh
.context @21h.10h.des
.freeze 3
.topic Int 21h Function 10h
 \i\p\aSummary\v@21h.10h\v\i\p                                   \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     MS-DOS versions 1.x and 2.x do not reliably detect a disk change,
     and an error can occur if the user changes disks while a file is
     still open on that drive. The directory and file allocation table
     of the newly inserted disk may be damaged or destroyed.

     Int 21h Function 3Eh should be used instead of this function.
.context @21h.11h
.freeze 3
.topic Int 21h Functions 11h and 12h
 \i\p\aDetail\v@21h.11h.des\v\i\p                                    \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunctions:\p  11h and 12h

  \bTitle:\p       Find First or Next File

  \bSee also:\p    \aFind First File (handle)\v@21h.3Eh\v

  \bDescription:\p

     Searches the current directory on the designated drive for a
     matching filename.

     \bInput                          Output\p

     AH = 11h for first file        If function successful (matching file
        = 12h for next files        name found)
     DS:DX = segment:offset of        AL = 00h
             file control block       Buffer at current disk transfer
                                      area (DTA) address filled in as an
                                      unopened normal FCB or extended FCB,
                                      depending on type of FCB input to
                                      Function 11h

                                    If function unsuccessful (no matching
                                    filename found)
                                      AL = FFh
.context @21h.11h.des
.freeze 3
.topic Int 21h Functions 11h and 12h
 \i\p\aSummary\v@21h.11h\v\i\p                                   \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Use Int 21h Function 1Ah to set the DTA to point to a buffer of
     adequate size before calling these functions. Get the first file
     with Function 11h, then call Function 12h repeatedly (until it
     fails) to get additional matching files.

     The wildcard character ? is allowed in the filename in all
     versions of MS-DOS. In versions 3.0 and later, the wildcard
     character * may also be used in a filename. If ? or * is used,
     this function returns the first matching filename.

     An extended FCB must be used to search for files that have the
     system, hidden, read-only, directory, or volume-label attributes.

     If an extended FCB is used, its attribute byte determines the type
     of search that will be performed. If the attribute byte (byte 0)
     contains 00h, only ordinary files are found. If the volume-label
     attribute bit is set, only volume labels will be returned (if any
     are present). If any other attribute or combination of attributes
     is set (such as hidden, system, or read-only), those files and all
     ordinary files will be matched.

     Normally Int 21h Functions 4Eh and 4Fh should be used instead of
     these functions, since they allow full access to the hierarchical
     directory structure.
.context @21h.13h
.freeze 3
.topic Int 21h Function 13h
 \i\p\aDetail\v@21h.13h.des\v\i\p \i\p\aExample\v@getcurdi.asx\v\i\p                          \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   13h

  \bTitle:\p       Delete File

  \bSee also:\p    \aDelete File (handle)\v@21h.41h\v

  \bDescription:\p

     Deletes all matching files from the current directory on the
     default or specified disk drive.

     \bInput                          Output\p

     AH = 13h                       If function successful (file or
     DS:DX = segment:offset of      files deleted)
             file control block       AL = 00h

                                    If function unsuccessful (no
                                    matching files were found, or
                                    at least one matching file was
                                    read-only)
                                       AL = FFh
.context @21h.13h.des
.freeze 3
.topic Int 21h Function 13h
 \i\p\aSummary\v@21h.13h\v\i\p \i\p\aExample\v@getcurdi.asx\v\i\p                         \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The wildcard character (?) is allowed in the filename; if ? is
     present and there is more than one matching filename, all matching
     files will be deleted.

     Int 21h Function 41h, which allows full access to the hierarchical
     directory structure, should be used instead of this function.

     [Version 3.0+]
     If the program is running on a network, the user must have Create
     rights to the directory containing the file to be deleted.
.context @21h.14h
.freeze 3
.topic Int 21h Function 14h
 \i\p\aDetail\v@21h.14h.des\v\i\p                                    \i\p\aUp\v@21.recfcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   14h

  \bTitle:\p       Sequential Read

  \bSee also:\p    \aRead File or Device\v@21h.3Fh\v

  \bDescription:\p

     Reads the next sequential block of data from a file and then
     increments the file pointer appropriately.

     \bInput                         Output\p

     AH = 14h                      AL = 00h (if read successful)
     DS:DX = segment:offset of        = 01h (if end-of-file)
             previously opened        = 02h (if segment wrap)
             file control block       = 03h (if partial record at
                                             end-of-file)
.context @21h.14h.des
.freeze 3
.topic Int 21h Function 14h
 \i\p\aSummary\v@21h.14h\v\i\p                                   \i\p\aUp\v@21.recfcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The record is read into memory at the current disk transfer area
     (DTA) address, specified by the most recent call to Int 21h
     Function 1Ah. If the size of the record and the location of the
     buffer are such that a segment overflow or wraparound would occur,
     the function fails with a return code of 02h.

     The number of bytes of data to be read is specified by the record
     size field (offset 0Eh) of the file control block (FCB).

     The file location of the data that will be read is specified by
     the combination of the current block field (offset 0Ch) and
     current record field (offset 20h) of the file control block (FCB).
     These fields are also automatically incremented by this function.

     If a partial record is read at the end-of-file, it is padded to
     the requested record length with zeros.

     [Version 3.0+]
     If the program is running on a network, the user must have Read
     access rights to the directory containing the file to be read.
.context @21h.15h
.freeze 3
.topic Int 21h Function 15h
 \i\p\aDetail\v@21h.15h.des\v\i\p                                    \i\p\aUp\v@21.recfcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   15h

  \bTitle:\p       Sequential Write

  \bSee also:\p    \aWrite to File or Device\v@21h.40h\v

  \bDescription:\p

     Writes the next sequential block of data into a file and then
     increments the file pointer appropriately.

     \bInput                         Output\p

     AH = 15h                      AL = 00h (if write successful)
     DS:DX = segment:offset of        = 01h (if disk full)
             previously opened        = 02h (if segment wrap)
             file control block
.context @21h.15h.des
.freeze 3
.topic Int 21h Function 15h
 \i\p\aSummary\v@21h.15h\v\i\p                                   \i\p\aUp\v@21.recfcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The record is written (logically, not necessarily physically) to
     the disk from memory at the current disk transfer area (DTA)
     address, specified by the most recent call to Int 21h Function
     1Ah. If the size of the record and the location of the buffer are
     such that a segment overflow or wraparound would occur, the
     function fails with a return code of 02h.

     The number of bytes of data to be written is specified by the
     record size field (offset 0Eh) of the file control block (FCB).

     The file location of the data that will be written is specified by
     the combination of the current block field (offset 0Ch) and
     current record field (offset 20h) of the file control block (FCB).
     These fields are also automatically incremented by this function.

     [Version 3.0+]
     If the program is running on a network, the user must have Write
     access rights to the directory containing the file to be written.
.context @21h.16h
.freeze 3
.topic  Int 21h Function 16h
 \i\p\aDetail\v@21h.16h.des\v\i\p                                    \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   16h

  \bTitle:\p       Create File

  \bSee also:\p    \aCreate File (handle)\v@21h.3Ch\v, \aCreate New File\v@21h.5Bh\v, @MakeFile

  \bDescription:\p

     Creates a new directory entry in the current directory or
     truncates any existing file with the same name to zero length.
     Opens the file for subsequent read/write operations.

     \bInput                        Output\p

     AH = 16h                     If function successful (file was
     DS:DX = segment:offset of    created or truncated)
             unopened file          AL = 00h
             control block        And FCB filled in by MS-DOS as
                                  follows:
                                  ş Drive field (offset 00h) = 1 for
                                    drive A, 2 for drive B,...
                                  ş Current block field (offset 0Ch) = 00h
                                  ş Record size field (offset 0Eh) = 0080h
                                  ş Size field (offset 10h) = File size
                                    from directory
                                  ş Date field (offset 14h) = Date stamp
                                    from directory
                                  ş Time field (offset 16h) = Time stamp
                                    from directory

                                  If function unsuccessful
                                  (directory full)
                                    AL = FFh
.context @21h.16h.des
.freeze 3
.topic Int 21h Function 16h
 \i\p\aSummary\v@21h.16h\v\i\p                                   \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function also opens the file; a subsequent call to Int 21h
     Function 0Fh is not required.

     Since an existing file with the specified name is truncated to
     zero length (all data in that file is irretrievably lost), this
     function must be used with caution.

     If this function is called with an extended file control block
     (FCB), the new file may be assigned a special attribute such as
     hidden or system during its creation by setting the appropriate
     bit in the extended FCB's attribute byte.

     For format of directory time and date, see Int 21h Function 57h.

     Int 21h Functions 3Ch, 5Ah, 5Bh, and 6Ch, which provide full
     access to the hierarchical directory structure, should be used
     instead of this function.

     [Version 3.0+]
     If the program is running on a network, the user must have Create
     rights to the directory that will contain the new file.
.context @21h.17h
.freeze 3
.topic Int 21h Function 17h
 \i\p\aDetail\v@21h.17h.des\v\i\p                                    \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   17h

  \bTitle:\p       Rename File

  \bSee also:\p    \aRename File (handle)\v@21h.56h\v

  \bDescription:\p

     Alters the name of all matching files in the current directory on
     the disk in the specified drive.

     \bInput                         Output\p

     AH = 17h                      If function successful (one or more
     DS:DX = segment:offset of     files renamed)
             special file            AL = 00h
             control block
                                   If function unsuccessful (no
                                   matching files or new filename
                                   matched an existing file)
                                     AL = FFh
.context @21h.17h.des
.freeze 3
.topic Int 21h Function 17h
 \i\p\aSummary\v@21h.17h\v\i\p                                   \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The special file control block has a drive code, filename, and
     extension in the usual position (bytes 0 through 0Bh) and a second
     filename starting 6 bytes after the first (offset 11h).

     The ? wildcard character can be used in the first filename. Every
     file matching the first file specification will be renamed to
     match the second file specification.

     If the second file specification contains any ? wildcard
     characters, the corresponding letters in the first filename are
     left unchanged.

     The function terminates if the new name to be assigned to a file
     matches that of an existing file.

     An extended FCB can be used with this function to rename a
     directory.

     Int 21h Function 56h, which allows full access to the hierarchical
     directory structure, should be used instead of this function.
.context @21h.19h
.freeze 3
.topic Int 21h Function 19h
 \i\p\aDetail\v@21h.19h.des\v\i\p \i\p\aExample\v@GetCurDi.asx\v\i\p                          \i\p\aUp\v@21.disk\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   19h

  \bTitle:\p       Get Current Drive

  \bSee also:\p    \aGet Drive Data\v@21h.1Ch\v, \aGet Drive Parameters\v@13h.08h\v, \aSelect Disk\v@21h.0Eh\v, @GetDrv

  \bDescription:\p

     Returns the drive code of the current, or default, disk drive.

     \bInput        Output\p

     AH = 19h     AL = Drive code (0 = A, 1 = B,...)
.context @21h.19h.des
.freeze 3
.topic Int 21h Function 19h
 \i\p\aSummary\v@21h.19h\v\i\p \i\p\aExample\v@GetCurDi.asx\v\i\p                         \i\p\aUp\v@21.disk\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Some other Int 21h functions use drive codes beginning at 1 (that
     is, 1 = A, 2 = B) and reserve drive code zero for the default
     drive.
.context @21h.1Ah
.freeze 3
.topic Int 21h Function 1Ah
 \i\p\aDetail\v@21h.1Ah.des\v\i\p \i\p\aExample\v@SetDTA.asx\v\i\p                          \i\p\aUp\v@21.rec\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   1Ah

  \bTitle:\p       Set DTA Address

  \bSee also:\p    \aGet Data Transfer Area (DTA) Address\v@21h.2Fh\v,
               @SetDTA

  \bDescription:\p

     Specifies the address of the disk transfer area (DTA) to be used
     for subsequent FCB-related function calls.

     \bInput                          Output\p

     AH = 1Ah                       None
     DS:DX = segment:offset of
             disk transfer area
.context @21h.1Ah.des
.freeze 3
.topic Int 21h Function 1Ah
 \i\p\aSummary\v@21h.1Ah\v\i\p \i\p\aExample\v@SetDTA.asx\v\i\p                         \i\p\aUp\v@21.rec\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If this function is never called by the program, the DTA defaults
     to a 128-byte buffer at offset 0080h in the program segment
     prefix.

     In general, it is the programmer's responsibility to ensure that
     the buffer area specified is large enough for any disk operation
     that will use it. The only exception to this is that MS-DOS will
     detect and abort disk transfers that would cause a segment wrap.

     The only handle-type operations that rely on the current DTA
     address are the directory search functions (Int 21h Functions 4Eh
     and 4Fh).
.context @21h.1Ch
.freeze 3
.topic Int 21h Functions 1Bh and 1Ch
 \i\p\aDetail\v@21h.1Ch.des\v\i\p                                    \i\p\aUp\v@21.disk\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunctions:\p  1Bh and 1Ch

  \bTitle:\p       Get Drive Data

  \bSee also:\p    \aSelect Disk\v@21h.0Dh\v, \aGet Drive Parameters\v@13h.08h\v, @ChkDrv

  \bDescription:\p

     Obtains allocation information about the default disk drive
     (Function 1Bh) or about a specified disk drive (Function 1Ch).
     Gets a pointer to the media identification byte from its file
     allocation table.

     \bInput                    Output\p

     AH = 1Bh for default     If function successful
          drive                 AL = Sectors per cluster
        = 1Ch for any           DS:BX = segment:offset of media ID byte
          drive                 CX = Size of physical sector (bytes)
     DL = Drive code for        DX = Number of clusters for default or
          1Ch only                   specified drive
          (0 = default,
           1 = A,...)         If function unsuccessful (invalid drive or
                              critical error)
                                AL = FFh

.context @21h.1Ch.des
.freeze 3
.topic Int 21h Functions 1Bh and 1Ch
 \i\p\aSummary\v@21h.1Ch\v\i\p                                   \i\p\aUp\v@21.disk\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Functions 1Bh and 1Ch are identical except that 1Bh only gets
     information on the default drive.

     The media ID byte has the following meanings:

     \bByte     Meaning\p

     0F0h     3.5-inch double-sided, 18 sectors or "other"
     0F8h     fixed disk
     0F9h     5.25-inch double-sided, 15 sectors
              or 3.5-inch double-sided, 9 sectors
     0FCh     5.25-inch single-sided, 9 sectors
     0FDh     5.25-inch double-sided, 9 sectors
     0FEh     5.25-inch single-sided, 8 sectors
     0FFh     5.25-inch double-sided, 8 sectors

     The address returned in DS:BX points only to a copy of the media
     ID byte from the disk's FAT; the memory above that address cannot
     be assumed to contain the FAT or any other useful information. If
     direct access to the FAT is required, use Int 25h to read it into
     memory.
.context @21h.21h
.freeze 3
.topic Int 21h Function 21h
 \i\p\aDetail\v@21h.21h.des\v\i\p                                    \i\p\aUp\v@21.recfcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   21h

  \bTitle:\p       Random Read

  \bSee also:\p    \aRead File or Device\v@21h.3Fh\v

  \bDescription:\p

     Reads a selected record from a file into memory.

     \bInput                     Output\p

     AH = 21h                  AL = 00h (if read successful)
     DS:DX = segment:offset       = 01h (if end-of-file)
             of previously        = 02h (if segment wrap, read canceled)
             opened file          = 03h (if partial record read at
             control block               end-of-file)
.context @21h.21h.des
.freeze 3
.topic Int 21h Function 21h
 \i\p\aSummary\v@21h.21h\v\i\p                                   \i\p\aUp\v@21.recfcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The record is read into memory at the current disk transfer area
     address, specified by the most recent call to Int 21h Function
     1Ah. It is the programmer's responsibility to ensure that this
     area is large enough for any record that will be transferred. If
     the size and location of the buffer are such that a segment
     overflow or wraparound would occur, the function fails with a
     return code of 02h.

     The file location of the data to be read is determined by the
     combination of the relative-record field (offset 21h) and the
     record size field (offset 0Eh) of the FCB. The default record size
     is 128 bytes.

     The current block field (offset 0Ch) and current record field
     (offset 20h) are updated to agree with the relative-record field
     as a side effect of the function.

     The relative-record field of the FCB is not incremented by this
     function; it is the responsibility of the application to update
     the FCB appropriately if it wishes to read successive records.
     Compare with Int 21h Function 27h, which can read multiple records
     with one function call and automatically increments the
     relative-record field.

     If a partial record is read at end-of-file, it is padded to the
     requested record length with zeros.

     [Version 3.0+]
     If the program is running on a network, the user must have Read
     access rights to the directory containing the file to be read.
.context @21h.22h
.freeze 3
.topic Int 21h Function 22h
 \i\p\aDetail\v@21h.22h.des\v\i\p                                    \i\p\aUp\v@21.recfcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   22h

  \bTitle:\p       Random Write

  \bSee also:\p    \aWrite to File or Device\v@21h.40h\v

  \bDescription:\p

     Writes data from memory into a selected record in a file.

     \bInput                     Output\p

     AH = 22h                  AL = 00h (if write successful)
     DS:DX = segment:offset       = 01h (if disk full)
             of previously        = 02h (if segment wrap, write canceled)
             opened file
             control block
.context @21h.22h.des
.freeze 3
.topic Int 21h Function 22h
 \i\p\aSummary\v@21h.22h\v\i\p                                   \i\p\aUp\v@21.recfcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The record is written (logically, not necessarily physically) to
     the file from memory at the current disk transfer address,
     specified by the most recent call to Int 21h Function 1Ah. If the
     size and location of the buffer are such that a segment overflow
     or wraparound would occur, the function fails with a return code
     of 02h.

     The file location of the data to be written is determined by the
     combination of the relative-record field (offset 21h) and the
     record size field (offset 0Eh) of the FCB. The default record size
     is 128 bytes.

     The current block field (offset 0Ch) and current record field
     (offset 20h) are updated to agree with the relative-record field
     as a side effect of the function.

     The relative-record field of the FCB is not incremented by this
     function; it is the responsibility of the application to update
     the FCB appropriately if it wishes to write successive records.
     Compare with Int 21h Function 28h, which can write multiple
     records with one function call and automatically increments the
     relative-record field.

     If a record is written beyond the current end-of-file, the space
     between the old end-of-file and the new record is allocated but
     not initialized.

     [Version 3.0+]
     If the program is running on a network, the user must have Write
     access rights to the directory containing the file to be written.
.context @21h.23h
.freeze 3
.topic Int 21h Function 23h
 \i\p\aDetail\v@21h.23h.des\v\i\p                                    \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   23h

  \bTitle:\p       Get File Size

  \bSee also:\p    \aSet File Pointer\v@21h.42h\v

  \bDescription:\p

     Searches for a matching file in the current directory; if one is
     found, updates the FCB with the file's size in terms of number of
     records.

     \bInput                        Output\p

     AH = 23h                     If function successful (matching file
     DS:DX = segment:offset       found)
             of unopened file       AL = 00
             control block        And FCB relative-record field
                                  (offset 21h) set to the number of
                                  records in the file, rounded up if
                                  necessary to the next complete
                                  record

                                  If function unsuccessful (no
                                  matching file found)
                                    AL = FFh
.context @21h.23h.des
.freeze 3
.topic Int 21h Function 23h
 \i\p\aSummary\v@21h.23h\v\i\p                                   \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     An appropriate value must be placed in the FCB record size field
     (offset 0Eh) before calling this function. There is no default
     record size for this function. Compare with the FCB-related open
     and create functions (Int 21h Functions 0Fh and 16h), which
     initialize the FCB for a default record size of 128 bytes.

     The record size field can be set to 1 to find the size of the file
     in bytes.

     Because record numbers are zero based, this function can be used
     to position the FCB's file pointer to the end-of-file.
.context @21h.24h
.freeze 3
.topic Int 21h Function 24h
 \i\p\aDetail\v@21h.24h.des\v\i\p                                    \i\p\aUp\v@21.recfcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   24h

  \bTitle:\p       Set Relative-Record Number

  \bSee also:\p    \aSet File Pointer\v@21h.42h\v

  \bDescription:\p

     Sets the relative-record-number field of a file control block
     (FCB) to correspond to the current file position as recorded in
     the opened FCB.

     \bInput                          Output\p

     AH = 24h                       AL is destroyed (other registers
     DS:DX = segment:offset of      not affected)
             previously opened
             file control block     FCB relative-record field (offset
                                    21h) updated
.context @21h.24h.des
.freeze 3
.topic Int 21h Function 24h
 \i\p\aSummary\v@21h.24h\v\i\p                                   \i\p\aUp\v@21.recfcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function is used when switching from sequential to random I/O
     within a file. The contents of the relative-record field (offset
     21h) are derived from the record size (offset 0Eh), current block
     (offset 0Ch), and current record (offset 20h) fields of the file
     control block.

     All four bytes of the FCB relative-record field (offset 21h)
     should be initialized to zero before calling this function.
.context @21h.25h
.freeze 3
.topic Int 21h Function 25h
 \i\p\aDetail\v@21h.25h.des\v\i\p \i\p\aExample\v@Exec.asx\v\i\p                          \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   25h

  \bTitle:\p       Set Interrupt Vector

  \bSee also:\p    \aGet Interrupt Vector\v@21h.35h\v, \aInterrupt Vector Table\v@IntVector\v,
               \aTerminate and Stay Resident\v@21h.31h\v, @SetInt

  \bDescription:\p

     Initializes a CPU interrupt vector to point to an interrupt
     handling routine.

     \bInput                                   Output\p

     AH = 25h                                None
     AL = Interrupt number
     DS:DX = segment:offset of interrupt
             handling routine

.context @21h.25h.des
.freeze 3
.topic Int 21h Function 25h
 \i\p\aSummary\v@21h.25h\v\i\p \i\p\aExample\v@Exec.asx\v\i\p                         \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     For maximum compatibility, this function should be used instead
     of direct editing of the interrupt vector table.

     Before an interrupt vector is modified, its original value should
     be obtained with Int 21h Function 35h and saved, so that it can be
     restored using this function before program termination.
.context @21h.26h
.freeze 3
.topic Int 21h Function 26h
 \i\p\aDetail\v@21h.26h.des\v\i\p                                    \i\p\aUp\v@21.process\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   26h

  \bTitle:\p       Create New PSP

  \bSee also:\p    \aGet PSP Address\v@21h.62h\v

  \bDescription:\p

     Copies the program segment prefix (PSP) of the currently executing
     program to a specified segment address in free memory and then
     updates the new PSP to make it usable by another program.

     \bInput                           Output\p

     AH = 26h                        None
     DX = Segment of new program
          segment prefix
.context @21h.26h.des
.freeze 3
.topic Int 21h Function 26h
 \i\p\aSummary\v@21h.26h\v\i\p                                   \i\p\aUp\v@21.process\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     After the executing program's PSP is copied into the new segment,
     the memory size information in the new PSP is updated
     appropriately and the current contents of the termination (Int
     22h), CTRL+C handler (Int 23h), and critical-error handler (Int
     24h) vectors are saved starting at offset 0Ah.

     This function copies the PSP. It does not load or execute another
     program.

     Int 21h Function 4Bh (EXEC), which can be used to load and execute
     programs or overlays in either .COM or .EXE format, should be used
     instead of this function.
.context @21h.27h
.freeze 3
.topic Int 21h Function 27h
 \i\p\aDetail\v@21h.27h.des\v\i\p                                    \i\p\aUp\v@21.recfcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   27h

  \bTitle:\p       Random Block Read

  \bSee also:\p    \aRead File or Device\v@21h.3Fh\v

  \bDescription:\p

     Reads one or more sequential records from a file into memory,
     starting at a designated file location.

     \bInput                              Output\p

     AH = 27h                           AL = 00h (if all requested
     CX = Number of records to read               records read)
     DS:DX = segment:offset of             = 01h (if end-of-file)
             previously opened file        = 02h (if segment wrap)
             control block                 = 03h (if partial record
                                                  read at end-of-file)
                                        CX = Actual number of records
                                             read
.context @21h.27h.des
.freeze 3
.topic Int 21h Function 27h
 \i\p\aSummary\v@21h.27h\v\i\p                                   \i\p\aUp\v@21.recfcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The records are read into memory at the current disk transfer area
     address, specified by the most recent call to Int 21h Function
     1Ah. It is the programmer's responsibility to ensure that this
     area is large enough for the group of records that will be
     transferred. If the size and location of the buffer are such that
     a segment overflow or wraparound would occur, the function fails
     with a return code of 02h.

     The file location of the data to be read is determined by the
     combination of the relative-record field (offset 21h) and the
     record size field (offset 0Eh) of the FCB. The default record size
     is 128 bytes.

     After the disk transfer is performed, the current block (offset
     0Ch), current record (offset 020h), and relative-record (offset
     21h) fields of the FCB are updated to point to the next record in
     the file.

     If a partial record is read at end-of-file, the remainder of
     the record is padded with zeros.

     Compare with Int 21h Function 21h, which transfers only one record
     per function call and does not update the FCB relative-record
     field.

     [Version 3.0+]
     If the program is running on a network, the user must have Read
     access rights to the directory containing the file to be read.
.context @21h.28h
.freeze 3
.topic Int 21h Function 28h
 \i\p\aDetail\v@21h.28h.des\v\i\p                                    \i\p\aUp\v@21.recfcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   28h

  \bTitle:\p       Random Block Write

  \bSee also:\p    \aWrite to File or Device\v@21h.40h\v

  \bDescription:\p

     Writes one or more sequential records from memory to a file,
     starting at a designated file location.

     \bInput                               Output\p

     AH = 28h                            AL = 00h (if all requested
     CX = Number of records to write               records written)
     DS:DX = segment:offset of              = 01h (if disk full)
             previously opened file         = 02h (if segment wrap)
             control block               CX = Actual number of records
                                              written
.context @21h.28h.des
.freeze 3
.topic Int 21h Function 28h
 \i\p\aSummary\v@21h.28h\v\i\p                                   \i\p\aUp\v@21.recfcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The records are written (logically, not necessarily physically) to
     disk from memory at the current disk transfer area address,
     specified by the most recent call to Int 21h Function 1Ah. If the
     size and location of the buffer are such that a segment overflow
     or wraparound would occur, the function fails with a return code
     of 02h.

     The file location of the data to be written is determined by the
     combination of the relative-record field (offset 21h) and the
     record size field (offset 0Eh) of the FCB. The default record size
     is 128 bytes.

     After the disk transfer is performed, the current block (offset
     0Ch), current record (offset 020h), and relative-record (offset
     21h) fields of the FCB are updated to point to the next record in
     the file.

     If this function is called with CX = 00h, no data is written to
     the disk but the file is extended or truncated to the length
     specified by the combination of the record size (offset 0Eh) and
     the relative-record (offset 21h) fields of the FCB.

     Compare with Int 21h Function 22h, which transfers only one record
     per function call and does not update the FCB relative-record
     field.

     [Version 3.0+]
     If the program is running on a network, the user must have Write
     access rights to the directory containing the file to be written.
.context @21h.29h
.freeze 3
.topic Int 21h Function 29h
 \i\p\aDetail\v@21h.29h.des\v\i\p \i\p\aExample\v@Exec.asx\v\i\p                          \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   29h

  \bTitle:\p       Parse Filename

  \bDescription:\p

     Parses a text string into the various fields of a file control
     block (FCB).

     \bInput                                      Output\p

     AH = 29h                                    AL = 00h (if no
     AL = Flags to control parsing                         wildcard
          Bit 3 = 1 (if the extension field                characters
                     in FCB will be modified               encountered
                     only if an extension is
                     specified in the string        = 01h (if parsed
                     being parsed)                         string
                = 0 (if the extension field                contained
                     in FCB will be modified               wildcard
                     regardless; if no                     characters)
                     extension is present
                     in the parsed string,          = FFh (if drive
                     FCB extension is set                  specifier
                     to ASCII blanks)                      invalid)
          Bit 2 = 1 (if the filename field
                     in FCB will be modified     DS:SI = segment:offset
                     only if a filename is               of first
                     specified in the string             character
                     being parsed)                       after parsed
                = 0 (if the filename field               filename
                     in FCB will be modified
                     regardless; if no           ES:DI = segment:offset
                     filename is present                 of formatted
                     in the parsed string,               unopened file
                     FCB file name is set to             control block
                     ASCII blanks)
          Bit 1 = 1 (if the drive ID byte in
                     FCB will be modified
                     only if a drive was
                     specified in the string
                     being parsed)
                = 0 (if the drive ID byte
                     in FCB will be modified
                     regardless; if no drive
                     specifier is present
                     in the parsed string,
                     FCB drive-code field is
                     set to 0 (default))
          Bit 0 = 1 (if the leading
                     separators will be
                     scanned off (ignored))
                = 0 (if the leading
                     separators will not be
                     scanned off)
     DS:SI = segment:offset of text string
     ES:DI = segment:offset of file control block
.context @21h.29h.des
.freeze 3
.topic Int 21h Function 29h
 \i\p\aSummary\v@21h.29h\v\i\p \i\p\aExample\v@Exec.asx\v\i\p                         \i\p\aUp\v@21.filefcb\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function regards the following as separator characters:
     : . ; , = + tab space

     This function regards all control characters and the following as
     terminator characters:
     : . ; , = + tab space < > / " [ ]

     If no valid filename is present in the string to be parsed, upon
     return ES:DI+1 points to an ASCII blank.

     If the * wildcard character occurs in a filename or extension, it
     and all remaining characters in the corresponding field in the FCB
     are set to ?.

     This function (and file control blocks in general) cannot be used
     with file specifications that include a path.
.context @21h.2Ah
.freeze 3
.topic Int 21h Function 2Ah
 \i\p\aDetail\v@21h.2Ah.des\v\i\p \i\p\aExample\v@GetKeyCl.asx\v\i\p                          \i\p\aUp\v@21.time\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   2Ah

  \bTitle:\p       Get Date

  \bSee also:\p    \aSet Date\v@21h.2Bh\v, \aGet Time\v@21h.2Ch\v, \aGet or Set File Date and Time\v@21h.57h\v,
               @GetTime

  \bDescription:\p

     Obtains the system day of the month, day of the week, month, and
     year.

     \bInput        Output\p

     AH = 2Ah     CX = Year (1980 through 2099)
                  DH = Month (1 through 12)
                  DL = Day (1 through 31)

                  Under MS-DOS versions 1.1 and later
                    AL = Day of the week (0 = Sunday,
                         1 = Monday,...)
.context @21h.2Ah.des
.freeze 3
.topic Int 21h Function 2Ah
 \i\p\aSummary\v@21h.2Ah\v\i\p \i\p\aExample\v@GetKeyCl.asx\v\i\p                         \i\p\aUp\v@21.time\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function's register format is the same as that required for
     Int 21h Function 2Bh (Set Date).

     This function can be used together with Int 21h Function 2Bh to
     find the day of the week for an arbitrary date. The current date
     is first obtained with Function 2Ah and saved. The date of
     interest is then set with Function 2Bh, and the day of the week
     for that date is obtained with a subsequent call to Function 2Ah.
     Finally, the current date is restored with an additional call to
     Function 2Bh, using the values obtained with the original Function
     2Ah call.
.context @21h.2Bh
.context @21h.2Bh.des
.freeze 3
.topic Int 21h Function 2Bh
 \i\p\aExample\v@GetKeyCl.asx\v\i\p                                   \i\p\aUp\v@21.time\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   2Bh

  \bTitle:\p       Set Date

  \bSee also:\p    \aGet Date\v@21h.2Ah\v, \aSet Time\v@21h.2Dh\v, \aGet or Set File Date and Time\v@21h.57h\v,
               @SetDate

  \bDescription:\p

     Initializes the system clock driver to a specific date. The system
     time is not affected. This function's register format is the same
     as that required for Int 21h Function 2Ah (Get Date).

     \bInput                             Output\p

     AH = 2Bh                          AL = 00h (if date set
     CX = Year (1980 through 2099)               successfully)
     DH = Month (1 through 12)            = FFh (if date not valid
     DL = Day (1 through 31)                     (ignored))
.context @21h.2Ch
.freeze 3
.topic Int 21h Function 2Ch
 \i\p\aDetail\v@21h.2Ch.des\v\i\p \i\p\aExample\v@GetKeyCl.asx\v\i\p                          \i\p\aUp\v@21.time\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   2Ch

  \bTitle:\p       Get Time

  \bSee also:\p    \aSet Time\v@21h.2Dh\v, \aGet Date\v@21h.2Ah\v, \aGet or Set File Date and Time\v@21h.57h\v,
               @GetTime

  \bDescription:\p

     Obtains the time of day from the system real-time clock driver,
     converted to hours, minutes, seconds, and hundredths of seconds.

     \bInput        Output\p

     AH = 2Ch     CH = Hours (0 through 23)
                  CL = Minutes (0 through 59)
                  DH = Seconds (0 through 59)
                  DL = Hundredths of seconds (0 through 99)
.context @21h.2Ch.des
.freeze 3
.topic Int 21h Function 2Ch
 \i\p\aSummary\v@21h.2Ch\v\i\p \i\p\aExample\v@GetKeyCl.asx\v\i\p                         \i\p\aUp\v@21.time\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function's register format is the same as that required for
     Int 21h Function 2Dh (Set Time).

     On most IBM PC-compatible systems, the real-time clock does not
     have a resolution of single hundredths of seconds. On such
     machines, the values returned by this function in register DL are
     discontinuous.
.context @21h.2Dh
.context @21h.2Bh.des
.freeze 3
.topic Int 21h Function 2Dh
 \i\p\aExample\v@GetKeyCl.asx\v\i\p                                   \i\p\aUp\v@21.time\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   2Dh

  \bTitle:\p       Set Time

  \bSee also:\p    \aGet Time\v@21h.2Ch\v, \aSet Date\v@21h.2Bh\v, \aGet or Set File Date and Time\v@21h.57h\v,
               @SetTime

  \bDescription:\p

     Initializes the system real-time clock to a specified hour,
     minute, second, and hundredth of second. The system date is not
     affected. This function's register format is the same as that
     required for Int 21h Function 2Ch (Get Time).

     \bInput                           Output\p

     AH = 2Dh                        AL = 00h (if time set
     CH = Hours (0 through 23)                 successfully)
     CL = Minutes (0 through 59)        = FFh (if time not valid
     DH = Seconds (0 through 59)               (ignored))
     DL = Hundredths of seconds
          (0 through 99)
.context @21h.2Eh
.freeze 3
.topic Int 21h Function 2Eh
 \i\p\aDetail\v@21h.2Eh.des\v\i\p                                    \i\p\aUp\v@21.disk\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   2Eh

  \bTitle:\p       Set Verify Flag

  \bSee also:\p    \aGet Verify Flag\v@21h.54h\v

  \bDescription:\p

     Turns off or turns on the operating-system flag for automatic
     read-after-write verification of data.

     \bInput                                     Output\p

     AH = 2Eh                                  None
     AL = 00h (if turning off verify flag)
        = 01h (if turning on verify flag)
     DL = 00h
.context @21h.2Eh.des
.freeze 3
.topic Int 21h Functions 2Eh and 54h
 \i\p\aSummary\v@21h.2Eh\v\i\p                                   \i\p\aUp\v@21.disk\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The verify flag provides increased data integrity by allowing the
     user to force a read-after-write verify of all data written to the
     disk, if that capability is supported by the manufacturer's disk
     driver.

     Because read-after-write verification slows disk operations, the
     default setting of the verify flag is OFF.

     The state of the verify flag can also be controlled by the MS-DOS
     commands VERIFY OFF and VERIFY ON.
.context @21h.2Fh
.context @21h.2Fh.des
.freeze 3
.topic Int 21h Function 2Fh
 \i\p\aExample\v@GetDTA.asx\v\i\p                                   \i\p\aUp\v@21.rec\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   2Fh

  \bTitle:\p       Get DTA Address

  \bSee also:\p    \aSet DTA Address\v@21h.1Ah\v, @GetDTA

  \bDescription:\p

     Obtains the current address of the disk transfer area (DTA) for
     FCB read/write operations. The disk transfer area address is set
     with Int 21h Function 1Ah. The default DTA is a 128-byte buffer at
     offset 80h in the program segment prefix.

     \bInput        Output\p

     AH = 2Fh     ES:BX = segment:offset of disk
                          transfer area
.context @21h.30h
.freeze 3
.topic Int 21h Function 30h
 \i\p\aDetail\v@21h.30h.des\v\i\p \i\p\aExample\vgetver\v\i\p                          \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   30h

  \bTitle:\p       Get MS-DOS Version Number

  \bSee also:\p    @GetVer

  \bDescription:\p

     Returns the version number of the host MS-DOS operating system.
     This function is used by application programs to determine the
     capabilities of their environment.

     \bInput        Output\p

     AH = 30h     If running under MS-DOS version 1.0
                    AL = 00h

                  If running under MS-DOS version 2.0 and later
                    AL = Major version number (MS-DOS 3.1 = 3,...)
                    AH = Minor version number (MS-DOS 3.1 = 0Ah,...)
                    BH = Original Equipment Manufacturer's (OEM's)
                         serial number (OEM dependent--usually 00h for
                         IBM's PC-DOS, 0FFh or other values for MS-DOS)
                    BL:CX = 24-bit user serial number (optional, OEM
                            dependent)
.context @21h.30h.des
.freeze 3
.topic Int 21h Function 30h
 \i\p\aSummary\v@21h.30h\v\i\p \i\p\aExample\v@GetVer.asx\v\i\p                         \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Because this function was not defined under MS-DOS 1.x, it should
     always be called with AL = 00. In an MS-DOS 1.x environment, AL
     will be returned unchanged.

     Care must be taken not to exit in an unacceptable fashion if an
     MS-DOS 1.x environment is detected. For example, \aInt 21h Function\v@21h.4Ch\v
     \a4Ch\v@21h.4Ch\v (Terminate Process with Return Code), \aInt 21h Function 40h\v@21h.40h\v
     (Write to File or Device), and the standard error handler are not
     available in MS-DOS 1.x. In such cases a program should display an
     error message using \aInt 21h Function 09h\v@21h.09h\v and then terminate with
     \aInt 20h\v@20h\v or \aInt 21h Function 00h\v@21h.00h\v.
.context @21h.31h
.freeze 3
.topic Int 21h Function 31h
 \i\p\aDetail\v@21h.31h.des\v\i\p                                     \i\p\aUp\v@21.process\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   31h

  \bTitle:\p       Terminate and Stay Resident

  \bSee also:\p    \aGet Interrupt Vector\v@21h.35h\v, \aSet Interrupt Vector\v@21h.25h\v, @TSR,
               \aTerminate and Stay Resident (BIOS)\v@21h.27h\v

  \bDescription:\p

     Terminates execution of the currently executing program, passing a
     return code to the parent process, but reserves part or all of the
     program's memory so that it will not be overlaid by the next
     transient program to be loaded.

     \bInput                            Output\p

     AH = 31h                         None
     AL = Return code
     DX = Amount of memory to
          reserve (in paragraphs)
.context @21h.31h.des
.freeze 3
.topic Int 21h Function 31h
 \i\p\aSummary\v@21h.31h\v\i\p                                   \i\p\aUp\v@21.process\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function performs the following actions:

        ş Flushes the file buffers and closes any open handles for
          files or devices owned by the process.

        ş Restores the termination handler vector (Int 22h) from
          PSP:000Ah.

        ş Restores the CTRL+C handler vector (Int 23h) from PSP:000Eh.

        ş Restores the critical-error handler vector (Int 24h) from
          PSP:0012h.

     Transfers control to the termination handler.

     If the program is returning to COMMAND.COM, control transfers to
     the resident portion, and the transient portion is reloaded if
     necessary. If a batch file is in progress, the next line of the
     file is fetched and interpreted; otherwise, a prompt is issued for
     the next user command.

     This function call is typically used to allow user-written
     utilities, drivers, or interrupt handlers to be loaded as ordinary
     .COM or .EXE programs and then remain resident. Subsequent
     entrance to the code is via a hardware or software interrupt.

     This function attempts to set the initial memory allocation block
     to the length in paragraphs specified in register DX. If other
     memory blocks have been requested by the application using Int 21h
     Function 48h, they will not be released by this function.

     Other methods of performing a final exit are Int 20h, Int 21h
     Function 00h, Int 21h Function 4Ch, and Int 27h.

     The return code may be retrieved by a parent process through Int
     21h Function 4Dh (Get Return Code). It can also be tested in a
     batch file with an IF ERRORLEVEL statement. By convention, a
     return code of zero indicates successful execution, and a nonzero
     return code indicates an error.

     This function should not be called by .EXE programs that are
     loaded at the high end of the transient program area (linked with
     the /HIGH switch), because doing so reserves the memory that is
     normally used by the transient part of COMMAND.COM. If COMMAND.COM
     cannot be reloaded, the system will fail.

     This function should be used instead of Int 27h because it
     supports return codes, allows larger amounts of memory to be
     reserved, and does not require CS to contain the segment of the
     program segment prefix.

     [Version 3.0+]
     If the program is running on a network, it should remove all locks
     it has placed on file regions before terminating.
.context @21h.33h
.freeze 3
.topic Int 21h Function 33h
 \i\p\aDetail\v@21h.33h.des\v\i\p                                    \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   33h

  \bTitle:\p       Get or Set Break Flag

  \bDescription:\p

     Obtains or changes the status of the operating system's Break
     flag, which influences CTRL+C checking during function calls. Also
     returns the system boot drive in version 4.0.

     \bInput                                      Output\p

     If getting Break flag                      DL = 00h (Break flag
       AH = 33h                                           is OFF)
       AL = 00h                                    = 01h (Break flag
                                                          is ON)
     If setting Break flag
       AH = 33h
       AL = 01h
       DL = 00h (if turning Break flag OFF)
          = 01h (if turning Break flag ON)

     Notes:
          AL will be FFh on exit if an invalid function number was
             entered in AL on entry.
          To get the boot drive, put 5 in AL on entry. The boot drive
             number will be in DL on exit (drive A = 1, drive B = 2)
.context @21h.33h.des
.freeze 3
.topic Int 21h Function 33h
 \i\p\aSummary\v@21h.33h\v\i\p                                   \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     When the system Break flag is ON, the keyboard is examined for
     CTRL+C entry whenever any operating system input or output is
     requested; if one is detected, control is transferred to the
     CTRL+C handler (Int 23h). When the Break flag is OFF, MS-DOS
     checks for CTRL+C entry only when executing the traditional
     character I/O functions (Int 21h Functions 01h through 0Ch).

     The Break flag is not part of the local environment of the
     currently executing program; it affects all programs. An
     application that alters the flag should first save the flag's
     original status and then restore the flag before terminating.
.context @21h.34h
.freeze 3
.topic InDos Flag Interrupt
 \i\p\aDetail\v@21h.34h.des\v\i\p                                    \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   34h

  \bTitle:\p       Get Address of InDos Flag

  \bSee also:\p    \aTerminate and Stay Resident\v@21h.31h\v

  \bDescription:\p

     Returns the far address of InDos flag, maintained by DOS to signal
     activity. The InDos flag is set when DOS functions are executing,
     and is clear otherwise.

     \bInput       Output\p

     AH = 34h    ES:BX = Address of InDos flag
.context @21h.34h.des
.freeze 3
.topic InDos Flag Interrupt
 \i\p\aSummary\v@21h.34h\v\i\p                                   \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     In DOS versions 3.1 and higher, DOS stores the Critical Error
     flag in the byte preceding the InDos flag. A call to function 34h
     thus effectively returns the addresses of both flags.
.comment     In DOS versions 3.1 and higher (not including OS/2's compatibility
.comment     version), DOS stores the Critical Error flag in the byte preceding
.comment     the InDos flag. A call to function 34h thus effectively returns
.comment     the addresses of both flags.

     TSR programs that make calls to DOS must monitor the InDos flag to
     ensure they do not interrupt a non-reentrant DOS function.
.context @21h.35h
.freeze 3
.topic Int 21h Function 35h
 \i\p\aExample\v@Exec.asx\v\i\p                                   \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   35h

  \bTitle:\p       Get Interrupt Vector

  \bSee also:\p    \aSet Interrupt Vector\v@21h.25h\v, \aInterrupt Vector Table\v@IntVector\v,
               \aTerminate and Stay Resident\v@21h.31h\v, @GetInt

  \bDescription:\p

     Obtains the address of the current interrupt handler routine for
     the specified machine interrupt. Together with Int 21h Function
     25h (Set Interrupt Vector), this function is used for maximum
     compatibility by application programs to modify or inspect the
     machine interrupt vector table.

     \bInput                     Output\p

     AH = 35h                  ES:BX = segment:offset of
     AL = Interrupt number             interrupt handler
.context @21h.36h
.freeze 3
.topic Int 21h Function 36h
 \i\p\aDetail\v@21h.36h.des\v\i\p \i\p\aExample\v@GetDiskS.asx\v\i\p                          \i\p\aUp\v@21.disk\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   36h

  \bTitle:\p       Get Drive Allocation Information

  \bSee also:\p    \aGet Drive Data\v@21h.1Ch\v, \aGet Drive Parameters\v@13h.08h\v, \aSelect Disk\v@21h.0Dh\v,
               @ChkDrv

  \bDescription:\p

     Obtains selected information about a disk drive, from which the
     drive's capacity and remaining free space can be calculated.

     \bInput                             Output\p

     AH = 36h                          If function successful
     DL = Drive code (0 = default,       AX = Sectors per cluster
          1 = A,...)                     BX = Number of available
                                              clusters
                                         CX = Bytes per sector
                                         DX = Clusters per drive

                                       If function unsuccessful
                                       (drive invalid)
                                         AX = FFFFh
.context @21h.36h.des
.freeze 3
.topic Int 21h Function 36h
 \i\p\aSummary\v@21h.36h\v\i\p \i\p\aExample\v@GetDiskS.asx\v\i\p                         \i\p\aUp\v@21.disk\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function regards "lost" clusters as being in use and does not
     report them as part of the number of available clusters, even
     though they are not assigned to a file.

     Similar information is returned by Int 21h Functions 1Bh and 1Ch.
.context @21h.38h
.freeze 3
.topic Int 21h Function 38h
 \i\p\aDetail\v@21h.38h.des\v\i\p                                    \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   38h

  \bTitle:\p       Get or Set Country Information

  \bSee also:\p    \aGet Extended Country Information\v@21h.65h\v

  \bDescription:\p

     Obtains internationalization information for the current country.
     [Version 3.0+] Obtains internationalization information for the
     current or specified country, or sets the current country code.

     \bInput                                Output\p

     If getting internationalization      If function successful
     information                            Carry flag: clear
       AH = 38h                           And if getting
       AL = 0 to get "current"            internationalization information
            country information             BX = Country code
       DS:DX = segment:offset of            DS:DX = segment:offset of
               buffer for returned             buffer holding
               information                     internationalization
               [Version 3.0+]                  information filled in
       AH = 38h                                as follows:
       AL = 0  to get "current"
            country information                [PC-DOS versions 2.0 and 2.1]
          = 1-FEh to get information
            for countries with                 \bBytes     Contents\p
            code < 255
          = FFh to get information             00h-01h   Date format
            for countries with                           0 = USA m d y
            code >= 255                                  1 = Europe d m y
       BX = Country code if AL = FFh                     2 = Japan y m d
       DS:DX = segment:offset of buffer        02h-03h   ASCIIZ currency
               for returned information                  symbol
                                               04h-05h   ASCIIZ thousands
     If setting current country code                     separator
     [Version 3.0+]                            06h-07h   ASCIIZ decimal
       AH = 38h                                          separator
       AL = 1-0FEh country code for            08h-1Fh   Reserved
            countries with code < 255
          = 0FFh for countries with            [MS-DOS version 2.0+,
            code >= 255                        PC-DOS version 3.0+]
       BX = Country code if AL = 0FFh
       DX = FFFFh                              \bBytes    Contents\p

                                               00h-01h   Date format
                                                         0 = USA m d y
                                                         1 = Europe d m y
                                                         2 = Japan y m d
                                               02h-06h   ASCIIZ currency
                                                         symbol string
                                               07h-08h   ASCIIZ thousands
                                                         separator
                                                         character
                                               09h-0Ah   ASCIIZ decimal
                                                         separator
                                                         character
                                               0Bh-0Ch   ASCIIZ date
                                                         separator
                                                         character
                                               0Dh-0Eh   ASCIIZ time
                                                         separator
                                                         character
                                               0Fh       Currency format
                                                         Bit 0 = 0 (if
                                                         currency symbol
                                                         precedes value)
                                                         Bit 0 = 1 (if
                                                         currency symbol
                                                         follows value)
                                                         Bit 1 = 0 (if no
                                                         space between
                                                         value and
                                                         currency symbol)
                                                         Bit 1 = 1 (if
                                                         one space
                                                         between value
                                                         and currency
                                                         symbol)
                                                         Bit 2 = 0 (if
                                                         currency symbol
                                                         and decimal are
                                                         separate)
                                                         Bit 2 = 1 (if
                                                         currency symbol
                                                         replaces
                                                         decimal
                                                         separator)
                                               10h       Number of digits
                                                         after decimal in
                                                         currency
                                               11h       Time format
                                                         Bit 0 = 0 (if
                                                         12-hour clock)
                                                         Bit 0 = 1 (if
                                                         24-hour clock)
                                               12h-15h   Case-map call
                                                         address
                                               16h-17h   ASCIIZ data-list
                                                         separator
                                               18h-21h   Reserved

                                          If function unsuccessful
                                            Carry flag: set
                                            AX = Error code (02h)
                                            See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.38h.des
.freeze 3
.topic Int 21h Function 38h
 \i\p\aSummary\v@21h.38h\v\i\p                                   \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The default country code is determined by the KEYBxx keyboard
     driver file if one is loaded. Otherwise, the default country code
     is OEM dependent.

     The previous contents of register CX may be destroyed by the Get
     Country Information subfunction.

     The case-map call address is the segment:offset of a FAR procedure
     that performs country-specific mapping on character values from
     80h through 0FFh. The procedure must be called with the character
     to be mapped in register AL. If an alternate value exists for that
     character, it is returned in AL; otherwise, AL is unchanged. In
     general, lowercase characters are mapped to uppercase, and
     accented or otherwise modified vowels are mapped to their plain
     vowel equivalents.

     [Version 3.0+]
     The value in register DX is used by MS-DOS to select between the
     Set Country and Get Country Information subfunctions.

     [Version 3.3+]
     Int 21h Function 65h (Get Extended Country Information) returns a
     superset of the internationalization information supplied by this
     function.
.context @21h.39h
.freeze 3
.topic Int 21h Function 39h
 \i\p\aDetail\v@21h.39h.des\v\i\p \i\p\aExample\v@MakeDir.asx\v\i\p                          \i\p\aUp\v@21.dir\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   39h

  \bTitle:\p       Create Directory

  \bSee also:\p    \aDelete Directory\v@21h.3Ah\v, \aSet Current Directory\v@21h.3Bh\v,
               \aGet Current Directory\v@21h.47h\v, @MkDir

  \bDescription:\p

     Creates a directory using the specified drive and path.

     \bInput                                Output\p

     AH = 39h                             If function successful
     DS:DX = segment:offset of ASCIIZ       Carry flag: clear
             path name
                                          If function unsuccessful
                                            Carry flag: set
                                            AX = Error code (03h or 05h)
                                            See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.39h.des
.freeze 3
.topic Int 21h Function 39h
 \i\p\aSummary\v@21h.39h\v\i\p \i\p\aExample\v@MakeDir.asx\v\i\p                         \i\p\aUp\v@21.dir\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The function fails if

        ş Any element of the path name does not exist.
        ş A directory with the same name at the end of the same path
          already exists.
        ş The parent directory for the new directory is the root
          directory and is full.
        ş [Version 3.0+] The program is running on a network and the user
          running the program has insufficient access rights.

.context @21h.3Ah
.freeze 3
.topic Int 21h Function 3Ah
 \i\p\aDetail\v@21h.3Ah.des\v\i\p \i\p\aExample\v@RemoveDi.asx\v\i\p                          \i\p\aUp\v@21.dir\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   3Ah

  \bTitle:\p       Delete Directory

  \bSee also:\p    \aCreate Directory\v@21h.39h\v, \aSet Current Directory\v@21h.3Bh\v,
               \aGet Current Directory\v@21h.47h\v, @RmDir

  \bDescription:\p

     Removes a directory using the specified drive and path.

     \bInput                                Output\p

     AH = 3Ah                             If function successful
     DS:DX = segment:offset of ASCIIZ       Carry flag: clear
             path name
                                          If function unsuccessful
                                            Carry flag: set
                                            AX = Error code (03h, 05h,
                                                 or 10h)
                                            See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.3Ah.des
.freeze 3
.topic Int 21h Function 3Ah
 \i\p\aSummary\v@21h.3Ah\v\i\p \i\p\aExample\v@RemoveDi.asx\v\i\p                         \i\p\aUp\v@21.dir\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The function fails if

        ş Any element of the path name does not exist.
        ş The specified directory is also the current directory.
        ş The specified directory contains any files.
        ş [Version 3.0+] The program is running on a network and the user
          running the program has insufficient access rights.

.context @21h.3Bh
.freeze 3
.topic Int 21h Function 3Bh
 \i\p\aDetail\v@21h.3Bh.des\v\i\p \i\p\aExample\v@ChangeDi.asx\v\i\p                          \i\p\aUp\v@21.dir\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   3Bh

  \bTitle:\p       Set Current Directory

  \bSee also:\p    \aGet Current Directory\v@21h.47h\v, \aCreate Directory\v@21h.39h\v,
               \aDelete Directory\v@21h.3Ah\v, @ChDir

  \bDescription:\p

     Sets the current, or default, directory using the specified drive
     and path.

     \bInput                                Output\p

     AH = 3Bh                             If function successful
     DS:DX = segment:offset of ASCIIZ       Carry flag: clear
             path name
                                          If function unsuccessful
                                            Carry flag: set
                                            AX = Error code (03h)
                                            See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.3Bh.des
.freeze 3
.topic Int 21h Function 3Bh
 \i\p\aSummary\v@21h.3Bh\v\i\p \i\p\aExample\v@ChangeDi.asx\v\i\p                         \i\p\aUp\v@21.dir\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The function fails if any element of the path name does not exist.

     Int 21h Function 47h can be used to obtain the name of the current
     directory before using Int 21h Function 3Bh to select another so
     that the original directory can be restored later.
.context @21h.3Ch
.freeze 3
.topic  Int 21h Function 3Ch
 \i\p\aDetail\v@21h.3Ch.des\v\i\p \i\p\aExample\v@CreateFi.asx\v\i\p                          \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   3Ch

  \bTitle:\p       Create File

  \bSee also:\p    \aCreate New File\v@21h.5Bh\v, \aCreate Temporary File\v@21h.5Ah\v

  \bDescription:\p

     Given an ASCIIZ path name, creates a new file in the designated or
     default directory on the designated or default disk drive. If the
     specified file already exists, it is truncated to zero length. In
     either case, the file is opened and a handle is returned that can
     be used by the program for subsequent access to the file.

     \bInput                                          Output\p

     AH = 3Ch                                       If function
     CX = File attribute (bits can be combined)     successful
                                                       Carry flag: clear
          \bBits     Significance (if set)\p               AX = Handle

          0        Read-only                        If function
          1        Hidden                           unsuccessful
          2        System                              Carry flag: set
          3        Volume label                        AX = Error code (03h,
          4        Reserved (0)                             04h, or 05h)
          5        Archive                             See: \i\p\aError codes\v@errcod\v\i\p
          6-15     Reserved (0)

     DS:DX = segment:offset of ASCIIZ path name
.context @21h.3Ch.des
.freeze 3
.topic Int 21h Function 3Ch
 \i\p\aSummary\v@21h.3Ch\v\i\p \i\p\aExample\v@CreateFi.asx\v\i\p                         \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The function fails if

        ş Any element of the pathname does not exist.
        ş The file is being created in the root directory and the root
          directory is full.
        ş A file with the same name and the read-only attribute already
          exists in the specified directory.
        ş [Version 3.0+] The program is running on a network and the
          user running the program has insufficient access rights.

     If the volume label or directory bits are set in the file
     attribute passed in register CX, they are ignored by MS-DOS.

     A file is usually given a normal (00h) attribute when it is
     created. The file's attribute can subsequently be modified with
     Int 21h Function 43h.

     [Version 3.0+]
     A volume label can be created using an attribute of 0008h if one
     does not already exist. When files are created, bit 3 of the
     attribute parameter should always be clear (0).

     [Version 4.0+]
     \aInt 21h Function 6Ch\v@21h.6Ch\v combines the services of \aFunctions 3Ch\v@21h.3Ch\v, \a3Dh\v@21h.3Dh\v,
     and \a5Bh\v@21h.5Bh\v.
.context @21h.3Dh
.freeze 3
.topic Int 21h Function 3Dh
 \i\p\aDetail\v@21h.3Dh.des\v\i\p \i\p\aExample\v@OpenFile.asx\v\i\p                          \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   3Dh

  \bTitle:\p       Open File

  \bSee also:\p    \aClose File\v@21h.3Eh\v, \aExtended Open File\v@21h.6Ch\v, \aCreate File\v@21h.3Ch\v, @OpenFile

  \bDescription:\p

     Given an ASCIIZ path name, the function opens the specified file
     in the designated or default directory on the designated or
     default disk drive. A handle is returned that can be used by the
     program for subsequent access to the file.

     \bInput                                   Output\p

     AH = 3Dh                                If function successful
     AL = Access mode                          Carry flag: clear
                                               AX = Handle
          \bBits    Significance\p
                                             If function unsuccessful
          0-2     Access mode                  Carry flag: set
                  000 = read access            AX = Error code (02h, 03h,
                  001 = write access                04h, 05h, or 0Ch)
                  010 = read/write access      See: \i\p\aError codes\v@errcod\v\i\p
          3       Reserved (0)
          4-6     Sharing mode
                  [Version 3.0+]
                  000 = compatibility mode
                  001 = deny all
                  010 = deny write
                  011 = deny read
                  100 = deny none
          7       Inheritance flag
                  [Version 3.0+]

     0 = Child process inherits handle
     1 = Child does not inherit handle
     DS:DX = segment:offset of ASCIIZ
             path name
.context @21h.3Dh.des
.freeze 3
.topic Int 21h Function 3Dh
 \i\p\aSummary\v@21h.3Dh\v\i\p \i\p\aExample\v@OpenFile.asx\v\i\p                         \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Any normal, system, or hidden file with a matching name will be
     opened by this function. If the file is read-only, the success of
     the operation also depends on the access code in bits 0-2 of
     register AL. After opening the file, the file read/write pointer
     is set to offset zero (the first byte of the file).

     The function fails if

        ş Any element of the path name does not exist.
        ş The file is opened with an access mode of read/write and the
          file has the read-only attribute.
        ş [Version 3.0+] SHARE.EXE is loaded and the file has already been
          opened by one or more other processes in a sharing mode that
          is incompatible with the current program's request.

     The file's date and time stamp can be accessed after a successful
     open call with Int 21h Function 57h.

     The file's attributes (hidden, system, read-only, or archive) can
     be obtained with Int 21h Function 43h.

     When a file handle is inherited by a child process or is
     duplicated with Int 21h Functions 45h or 46h, all sharing and
     access restrictions are also inherited.

     [Version 3.0+]
     Bit 3 should always be zero; bits 4-7 control access to the file
     by other programs. Bits 4-6 have no effect unless SHARE.EXE is
     loaded.

     [Version 3.0+]
     A file-sharing error causes a critical-error exception (Int 24h)
     with an error code of 02h. Int 21h Function 59h can be used to
     obtain information about the sharing violation.

     [Version 4.0+]
     \aInt 21h Function 6Ch\v@21h.6Ch\v combines the services of \aFunctions 3Ch\v@21h.3Ch\v, \a3Dh\v@21h.3Dh\v,
     and \a5Bh\v@21h.5Bh\v.
.context @21h.3Eh
.freeze 3
.topic Int 21h Function 3Eh
 \i\p\aDetail\v@21h.3Eh.des\v\i\p \i\p\aExample\v@CloseFil.asx\v\i\p                          \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   3Eh

  \bTitle:\p       Close File

  \bSee also:\p    \aOpen File\v@21h.3Dh\v, \aDelete File\v@21h.41h\v, @CloseFile

  \bDescription:\p

     Given a handle that was obtained by a previous successful open or
     create operation, flushes all internal buffers associated with the
     file to disk, closes the file, and releases the handle for reuse.
     If the file was modified, the time and date stamp and file size
     are updated in the file's directory entry.

     \bInput          Output\p

     AH = 3Eh       If function successful
     BX = Handle      Carry Flag: clear

                    If function unsuccessful
                      Carry flag: set
                      AX = Error code (06h)
                      See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.3Eh.des
.freeze 3
.topic Int 21h Function 3Eh
 \i\p\aSummary\v@21h.3Eh\v\i\p \i\p\aExample\v@CloseFil.asx\v\i\p                         \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If you accidentally call this function with a zero handle, the
     standard input device is closed, and the keyboard appears to go
     dead. Be sure you always call the close function with a valid,
     nonzero handle.
.context @21h.3Fh
.freeze 3
.topic Int 21h Function 3Fh
 \i\p\aDetail\v@21h.3Fh.des\v\i\p \i\p\aExample\v@ReadFile.asx\v\i\p                          \i\p\aUp\v@21.rec\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   3Fh

  \bTitle:\p       Read File or Device

  \bSee also:\p    \aWrite to File or Device\v@21h.40h\v, \aSet File Pointer\v@21h.42h\v, @Read

  \bDescription:\p

     Given a valid file handle from a previous open or create
     operation, a buffer address, and a length in bytes, this function
     transfers data at the current file pointer position from the file
     into the buffer and then updates the file pointer position.

     \bInput                                Output\p

     AH = 3Fh                             If function successful
     BX = Handle                            Carry flag: clear
     CX = Number of bytes to read           AX = Bytes transferred
     DS:DX = segment:offset of buffer
                                          If function unsuccessful
                                            Carry flag: set
                                            AX = Error code (05h or 06h)
                                            See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.3Fh.des
.freeze 3
.topic Int 21h Function 3Fh
 \i\p\aSummary\v@21h.3Fh\v\i\p \i\p\aExample\v@ReadFile.asx\v\i\p                         \i\p\aUp\v@21.rec\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If reading from a character device (such as the standard input) in
     cooked mode, at most one line of input will be read (up to a
     carriage return character or the specified length, whichever comes
     first).

     If the carry flag is returned clear but AX = 0, then the file
     pointer was already at end-of-file when the program requested the
     read.

     If the carry flag is returned clear but AX < CX, then a partial
     record was read at end of file or there is an error.

     [Version 3.0+]
     If the program is running on a network, the user must have Read
     access rights to the directory and file.
.context @21h.40h
.freeze 3
.topic Int 21h Function 40h
 \i\p\aDetail\v@21h.40h.des\v\i\p \i\p\aExample\v@WriteFil.asx\v\i\p                          \i\p\aUp\v@21.rec\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   40h

  \bTitle:\p       Write File or Device

  \bSee also:\p    \aRead File or Device\v@21h.3Fh\v, \aSet File Pointer\v@21h.42h\v, @Write

  \bDescription:\p

     Given a valid file handle from a previous open or create
     operation, a buffer address, and a length in bytes, this function
     transfers data from the buffer into the file and then updates the
     file pointer position.

     \bInput                                Output\p

     AH = 40h                             If function successful
     BX = Handle                             Carry flag: clear
     CX = Number of bytes to write           AX = Bytes transferred
     DS:DX = segment:offset of buffer
                                          If function unsuccessful
                                             Carry flag: set
                                             AX = Error code (05h or 06H)
                                             See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.40h.des
.freeze 3
.topic Int 21h Function 40h
 \i\p\aSummary\v@21h.40h\v\i\p \i\p\aExample\v@WriteFil.asx\v\i\p                         \i\p\aUp\v@21.rec\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If the carry flag is returned clear but AX < CX, then a partial
     record was written or there is an error. This can be caused by a
     CTRL+Z (1Ah) embedded in the data if the destination is a
     character device in cooked mode or by a disk-full condition if the
     destination is a file.

     If the function is called with CX = 0, the file is truncated or
     extended to the current file pointer position.

     [Version 3.0+]
     If the program is running on a network, the user must have Write
     access rights to the directory and file.
.context @21h.41h
.freeze 3
.topic Int 21h Function 41h
 \i\p\aDetail\v@21h.41h.des\v\i\p \i\p\aExample\v@DelFile.asx\v\i\p                          \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   41h

  \bTitle:\p       Delete File

  \bSee also:\p    \aDelete Directory\v@21h.3Ah\v, @DelFile

  \bDescription:\p

     Deletes a file from the specified or default disk and directory.

     \bInput                                Output\p

     AH = 41h                             If function successful
     DS:DX = segment:offset of ASCIIZ       Carry flag: clear
             path name
                                          If function unsuccessful
                                            Carry flag: set
                                            AX = Error code (02h, 03h,
                                                 or 05h)
                                                 See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.41h.des
.freeze 3
.topic Int 21h Function 41h
 \i\p\aSummary\v@21h.41h\v\i\p \i\p\aExample\v@DelFile.asx\v\i\p                         \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function deletes a file by replacing the first character of
     its filename in the directory with the character e (E5h) and
     marking the file's clusters as "free" in the disk's file
     allocation table. The actual data stored in those clusters is not
     overwritten.

     Only one file at a time may be deleted with this function. Unlike
     the FCB-related Delete File function (Int 21h Function 13h), the *
     and ? wildcard characters are not allowed in the file
     specification.

     The function fails if

        ş Any element of the path name does not exist.
        ş The designated file exists but has the read-only attribute
          (Int 21h Function 43h can be used to examine and modify a
          file's attribute before attempting to delete it).
        ş [Version 3.0+] The program is running on a network, and the user
          running the program has insufficient access rights.

.context @21h.42h
.freeze 3
.topic Int 21h Function 42h
 \i\p\aDetail\v@21h.42h.des\v\i\p \i\p\aExample\v@Rewind.asx\v\i\p                          \i\p\aUp\v@21.rec\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   42h

  \bTitle:\p       Set File Pointer

  \bSee also:\p    \aRead File or Device\v@21h.3Fh\v, \aWrite to File or Device\v@21h.40h\v, @GetFileSize,
               @MovePtrAbs, @MovePtrRel

  \bDescription:\p

     Sets the file location pointer relative to the start-of-file,
     end-of-file, or the current file position.

     \bInput                             Output\p

     AH = 42h                          If function successful
     AL = Method code                    Carry flag: clear
        = 00h Absolute offset            DX = Most significant half of
              from start of file              resulting file pointer
        = 01h Signed offset from         AX = Least significant half
              current file pointer            of resulting file pointer
        = 02h Signed offset from
              end of file              If function unsuccessful
     BX = Handle                         Carry flag: set
     CX = Most significant half          AX = Error code (01h or 06h)
          of offset                      See: \i\p\aError codes\v@errcod\v\i\p
     DX = Least significant half
          of offset
.context @21h.42h.des
.freeze 3
.topic Int 21h Function 42h
 \i\p\aSummary\v@21h.42h\v\i\p \i\p\aExample\v@Rewind.asx\v\i\p                         \i\p\aUp\v@21.rec\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function uses a method code and a double-precision (32-bit)
     value to set the file pointer. The next record read or written in
     the file will begin at the new file pointer location.

     Method 02h may be used to find the size of the file by calling Int
     21h Function 42h with an offset of 0 and examining the pointer
     location that is returned.

     Using methods 01h or 02h, it is possible to set the file pointer
     to a location before the start of file. If this is done, no error
     is returned by this function, but an error will be encountered
     upon a subsequent attempt to read or write the file.

     No matter what method is used in the call to this function, the
     file pointer returned in DX:AX is always the resulting absolute
     byte offset from the start of the file.
.context @21h.43h
.freeze 3
.topic Int 21h Function 43h
 \i\p\aDetail\v@21h.43h.des\v\i\p \i\p\aExample\v@SetAttri.asx\v\i\p                          \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   43h

  \bTitle:\p       Get or Set File Attributes

  \bSee also:\p    \aGet or Set File Date and Time\v@21h.57h\v

  \bDescription:\p

     Obtains or alters the attributes of a file (read-only, hidden,
     system, or archive).

     \bInput                                    Output\p

     AH = 43h                                 If function successful
     AL = 00h (if getting file attribute)       Carry flag: clear
        = 01h (if setting file attribute)       CX = File attribute
     CX = New file attribute if AL = 01h
          (bits can be combined)              If function unsuccessful
          Bit 5 = Archive                       Carry flag: set
          Bit 2 = System                        AX = Error code (01h, 02h,
          Bit 1 = Hidden                             03h, or 05h)
          Bit 0 = Read-only                     See: \i\p\aError codes\v@errcod\v\i\p
     DS:DX = segment:offset of ASCIIZ
             path name
.context @21h.43h.des
.freeze 3
.topic Int 21h Function 43h
 \i\p\aSummary\v@21h.43h\v\i\p \i\p\aExample\v@SetAttri.asx\v\i\p                         \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Bits 3 and 4 of register CX must always be clear (0) when this
     function is called; in other words, you cannot change an existing
     file into a directory or volume label. However, you can assign the
     "hidden" attribute to an existing directory with this function.

     [Version 3.0+]
     If the program is running on a network, the user must have Create
     access rights to the directory containing the file whose attribute
     is to be modified.
.context IOCTL
.context @21h.44h
.freeze 3
.topic Int 21h Function 44h
                                             \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h

  \bTitle:\p       IOCTL (I/O Control)

  \bSee also:\p    \aDirect Disk Services\v@13h\v, \aSerial Port Services\v@14h\v,
               \aParallel Port Services\v@17h\v

  \bSubfunction  Name\p

  \a00h          Get Device Information\v@21h.44h.00h\v
  \a01h          Set Device Information\v@21h.44h.01h\v
  \a02h          Receive Control Data from Character Device Driver\v@21h.44h.02h\v
  \a03h          Send Control Data to Character Device Driver\v@21h.44h.03h\v
  \a04h          Receive Control Data from Block Device Driver\v@21h.44h.04h\v
  \a05h          Send Control Data to Block Device Driver\v@21h.44h.05h\v
  \a06h          Check Input Status\v@21h.44h.06h\v
  \a07h          Check Output Status\v@21h.44h.07h\v
  \a08h          Check if Block Device is Removable\v@21h.44h.08h\v
  \a09h          Check if Block Device is Remote\v@21h.44h.09h\v
  \a0Ah          Check if Handle Is Remote\v@21h.44h.0Ah\v
  \a0Bh          Change Sharing Retry Count\v@21h.44h.0Bh\v
  \a0Ch          Generic I/O Control for Character Devices\v@21h.44h.0Ch\v
  \a0Dh          Generic I/O Control for Block Devices\v@21h.44h.0Dh\v
  \a0Eh          Get Logical Drive Map\v@21h.44h.0Eh\v
  \a0Fh          Set Logical Drive Map\v@21h.44h.0Fh\v

  Note: Only IOCTL Subfunctions 00h, 06h, and 07h may be used for
        handles associated with files. Subfunctions 00h-08h are not
        supported on network devices.
.context @21h.44h.00h
.freeze 3
.topic  Int 21h Function 44h Subfunction 00h
 \i\p\aDetail\v@21h.44h.00h.des\v\i\p                                    \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h     \bSubfunction:\p   00h

  \bTitle:\p       IOCTL: Get Device Information

  \bSee also:\p    \aGet Drive Parameters\v@13h.08h\v

  \bDescription:\p

     Returns a device information word for the file or device
     associated with the specified handle.

     \bInput            Output\p

     AH = 44h         If function successful
     AL = 00h           Carry flag: clear
     BX = Handle        DX = Device information word
                           For a file:
                           Bits 8-15 = 0 (reserved)
                           Bit  7    = 0 (indicating a file)
                           Bit  6    = 0 (file has been written)
                                     = 1 (file has not been written)
                           Bits 0-5  = drive number (0 = A, 1 = B,...)
                           For a device:
                           Bit 15    = reserved
                           Bit 14    = 1 (if device supports IOCTL Read
                                       and  Write Control Data
                                       subfunctions)
                                     = 0 (if Control Data subfunctions not
                                       supported)
                           Bits 8-13 = reserved
                           Bit 7     = 1 (indicating a device)
                           Bit 6     = 0 (if end of file on input)
                           Bit 5     = 0 (if handle in ASCII ("cooked")
                                         mode)
                                     = 1 (if handle in binary ("raw") mode)
                           Bit 4     = reserved
                           Bit 3     = 1 (if clock device)
                           Bit 2     = 1 (if NUL device)
                           Bit 1     = 1 (if console output)
                           Bit 0     = 1 (if console input)

                      If function unsuccessful
                        Carry flag: set
                        AX = Error code (01h, 05h,
                             or 06h)
                        See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.44h.00h.des
.freeze 3
.topic Int 21h Function 44h Subfunction 00h
 \i\p\aSummary\v@21h.44h.00h\v\i\p                                   \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Bits 8-15 of DX correspond to the upper 8 bits of the device
     driver attribute word.

     Bit 5 of the device information word for a handle associated with
     a character device signifies whether MS-DOS considers that handle
     to be in binary (raw) mode or ASCII (cooked) mode. In cooked mode,
     MS-DOS filters the character stream and may take special action
     when the characters CTRL+C, CTRL+S, CTRL+P, CTRL+Z, and carriage
     return are detected. In raw mode, all characters are treated as
     data, and the exact number of characters requested is always read
     or written.
.context @21h.44h.01h
.freeze 3
.topic Int 21h Function 44h Subfunction 01h
 \i\p\aDetail\v@21h.44h.01h.des\v\i\p                                    \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h     \bSubfunction:\p   01h

  \bTitle:\p       IOCTL: Set Device Information

  \bDescription:\p

     Sets certain flags for a handle associated with a character
     device. This subfunction may not be used for a handle that is
     associated with a file.

     \bInput                                      Output\p

     AH = 44h                                   If function successful
     AL = 01h                                     Carry flag: clear
     BX = Handle
     DX = Device information word               If function unsuccessful
          Bits 8-15 = 0 (reserved)                Carry flag: set
          Bit  7    = 1 (indicating a device)     AX = Error code (01h,
          Bit  6    = 0 (reserved)                     05h, or 06h)
          Bit  5    = 0 (to select ASCII          See: \i\p\aError codes\v@errcod\v\i\p
                        ("cooked") mode)
                    = 1 (to select binary
                        ("raw") mode)
          Bit  4    = 0 (reserved)
          Bit  3    = 1 (if clock device)
          Bit  2    = 1 (if NUL device)
          Bit  1    = 1 (if console output)
          Bit  0    = 1 (if console input)
.context @21h.44h.01h.des
.freeze 3
.topic Int 21h Function 44h Subfunction 01h
 \i\p\aSummary\v@21h.44h.01h\v\i\p                                   \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If register Dh does not contain 00h, control returns to the
     program with the carry flag set and error code 0001h (invalid
     function) in register AX.

     Bit 5 of the information word for a handle associated with a
     character device signifies whether MS-DOS considers that handle to
     be in ASCII (cooked) or binary (raw) mode. See IOCTL Subfunction
     00h for more information.
.context @21h.44h.02h
.freeze 3
.topic Int 21h Function 44h Subfunction 02h
 \i\p\aDetail\v@21h.44h.02h.des\v\i\p                                    \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h   \bSubfunction:\p   02h

  \bTitle:\p       IOCTL: Read Control Data from Character Device Driver

  \bDescription:\p

     Reads control data from a character device driver. The length and
     contents of the data are specific to each device driver and do not
     follow any standard format. This function does not necessarily
     result in any input from the physical device.

     \bInput                                 Output\p

     AH = 44h                              If function successful
     AL = 02h                                Carry flag: clear
     BX = Handle                             AX = Bytes read and
     CX = Number of bytes to read                 buffer contains
     DS:DX = segment:offset of buffer             control data from
                                                  driver

                                           If function unsuccessful
                                             Carry flag: set
                                             AX = Error code (01h, 05h,
                                                  06h, or 0Dh)
                                             See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.44h.02h.des
.freeze 3
.topic Int 21h Function 44h.02h
 \i\p\aSummary\v@21h.44h.02h\v\i\p                                   \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If supported by the driver, this subfunction can be used to obtain
     hardware-dependent status and availability information that is not
     supported by other MS-DOS function calls.

     Character device drivers are not required to support IOCTL
     Subfunction 02h. A program can test bit 14 of the device
     information word returned by IOCTL Subfunction 00h to determine
     whether the driver supports this subfunction. If Subfunction 02h
     is requested and the driver does not have the ability to process
     control data, control returns to the program with the carry flag
     set and error code 0001h (invalid function) in register AX.
.context @21h.44h.03h
.freeze 3
.topic Int 21h Function 44h Subfunction 03h
 \i\p\aDetail\v@21h.44h.03h.des\v\i\p                                    \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h     \bSubfunction:\p   03h

  \bTitle:\p       IOCTL: Write Control Data to Character Device Driver

  \bDescription:\p

     Transfers control data from an application to a character device
     driver. The length and contents of the data are specific to each
     device driver and do not follow any standard format. This function
     does not necessarily result in any output to the physical device.

     \bInput                              Output\p

     AH = 44h                           If function successful
     AL = 03h                             Carry flag: clear
     BX = Handle                          AX = Bytes transferred
     CX = Number of bytes to write
     DS:DX = segment:offset of data     If function unsuccessful
                                          Carry flag: set
                                          AX = Error code (01h, 05h, 06h,
                                               or 0Dh)
                                          See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.44h.03h.des
.freeze 3
.topic Int 21h Function 44h Subfunction 03h
 \i\p\aSummary\v@21h.44h.03h\v\i\p                                   \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If supported by the driver, this subfunction can be used to
     request hardware-dependent operations (such as setting baud rate
     for a serial port) that are not supported by other MS-DOS function
     calls.

     Character device drivers are not required to support IOCTL
     Subfunction 03h. A program can test bit 14 of the device
     information word returned by IOCTL Subfunction 00h to determine
     whether the driver supports this subfunction. If Subfunction 03h
     is requested and the driver does not have the ability to process
     control data, control returns to the program with the carry flag
     set and error code 0001h (invalid function) in register AX.
.context @21h.44h.04h
.freeze 3
.topic Int 21h Function 44h Subfunction 04h
 \i\p\aDetail\v@21h.44h.04h.des\v\i\p                                    \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h     \bSubfunction:\p   04h

  \bTitle:\p       IOCTL: Read Control Data from Block Device Driver

  \bDescription:\p

     Transfers control data from a block device driver directly into an
     application program's buffer. The length and contents of the data
     are specific to each device driver and do not follow any standard
     format. This function does not necessarily result in any input
     from the physical device.

     \bInput                                Output\p

     AH = 44h                             If function successful
     AL = 04h                               Carry flag: clear
     BL = Drive code (0 = default,          AX = Bytes transferred and
          1 = A, 2 = B,...)                      buffer contains
     CX = Number of bytes to read                control data from
     DS:DX = segment:offset of buffer            device driver

                                          If function unsuccessful
                                            Carry flag: set
                                            AX = Error code (01h, 05h,
                                                 06h,or 0Dh)
                                            See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.44h.04h.des
.freeze 3
.topic Int 21h Function 44h Subfunction 04h
 \i\p\aSummary\v@21h.44h.04h\v\i\p                                   \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     When supported by the driver, this subfunction can be used to
     obtain hardware-dependent status and availability information that
     is not provided by other MS-DOS function calls.

     Block device drivers are not required to support IOCTL Subfunction
     04h. If this subfunction is requested and the driver does not have
     the ability to process control data, control returns to the
     program with the carry flag set and error code 0001h (invalid
     function) in register AX.
.context @21h.44h.05h
.freeze 3
.topic Int 21h Function 44h Subfunction 05h
 \i\p\aDetail\v@21h.44h.05h.des\v\i\p                                    \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h     \bSubfunction:\p   05h

  \bTitle:\p       IOCTL: Write Control Data to Block Device Driver

  \bDescription:\p

     Transfers control data from an application program directly to a
     block device driver. The length and contents of the control data
     are specific to each device driver and do not follow any standard
     format. This function does not necessarily result in any output to
     the physical device.

     \bInput                              Output\p

     AH = 44h                           If function successful
     AL = 05h                             Carry flag: clear
     BL = Drive code (0 = default,        AX = Bytes transferred
          1 = A, 2 = B,...)
     CX = Number of bytes to write      If function unsuccessful
     DS:DX = segment:offset of data       Carry flag: set
                                          AX = Error code (01h, 05h,
                                               06h,or 0Dh)
                                          See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.44h.05h.des
.freeze 3
.topic Int 21h Function 44h Subfunction 05h
 \i\p\aSummary\v@21h.44h.05h\v\i\p                                   \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     When supported by the driver, this subfunction can be used to
     request hardware-dependent operations (such as tape rewind or disk
     eject) that are not provided by other MS-DOS function calls.

     Block device drivers are not required to support IOCTL Subfunction
     05h. If this subfunction is requested and the driver does not have
     the ability to process control data, control returns to the
     program with the carry flag set and error code 0001h (invalid
     function) in register AX.
.context @21h.44h.06h
.freeze 3
.topic Int 21h Function 44h Subfunction 06h
                                             \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h     \bSubfunction:\p   06h

  \bTitle:\p       IOCTL: Check Input Status

  \bDescription:\p

     Returns a code indicating whether the device or file associated
     with a handle is ready for input. This function can be used to
     check the status of character devices such as the serial port
     that do not have their own "traditional" MS-DOS status calls.

     \bInput           Output\p

     AH = 44h        If function successful
     AL = 06h          Carry flag: clear
     BX = Handle     And for a device
                       AL = 00h (if device not ready)
                          = FFh (if device ready)
                     Or for a file
                       AL = 00h (if file pointer at EOF)
                          = FFh (if file pointer not at EOF)

                     If function unsuccessful
                       Carry flag: set
                       AX = Error code (01h, 05h, 06h,or 0Dh)
                       See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.44h.07h
.freeze 3
.topic Int 21h Function 44h Subfunction 07h
                                             \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h     \bSubfunction:\p   07h

  \bTitle:\p       IOCTL: Check Output Status

  \bDescription:\p

     Returns a code indicating whether the device associated with a
     handle is ready for output. When used with a handle for a file,
     this function always returns a ready status, even if the disk is
     full or no disk is in the drive.

     \bInput           Output\p

     AH = 44h        If function successful
     AL = 07h          Carry flag: clear
     BX = Handle     And for a device
                       AL = 00h (if device not ready)
                          = FFh (if device ready)
                     Or for a file
                       AL = FFh

                     If function unsuccessful
                       Carry flag: set
                       AX = Error code (01h, 05h, 06h,or 0Dh)
                       See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.44h.08h
.freeze 3
.topic Int 21h Function 44h Subfunction 08h
 \i\p\aDetail\v@21h.44h.08h.des\v\i\p                                    \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h     \bSubfunction:\p   08h

  \bTitle:\p       IOCTL: Check if Block Device is Removable [Version 3.0+]

  \bDescription:\p

     Checks whether the specified block device contains a removable
     storage medium, such as a floppy disk.

     \bInput                             Output\p

     AH = 44h                          If function successful
     AL = 08h                            Carry flag: clear
     BL = Drive number (0 = default,     AL = 00h (if medium is
          1 = A, 2 = B,...)                        removable)
                                            = 01h (if medium is not
                                                   removable)

                                       If function unsuccessful
                                         Carry flag: set
                                         AX = Error code (01h or 0Fh)
                                         See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.44h.08h.des
.freeze 3
.topic Int 21h Function 44h Subfunction 08h
 \i\p\aSummary\v@21h.44h.08h\v\i\p                                   \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If a file is not found as expected on a particular drive, a
     program can use this subfunction to determine whether the user
     should be prompted to insert another disk.

     This subfunction may not be used for a network drive.

     Block drivers are not required to support Subfunction 08h. If this
     subfunction is requested and the block device cannot supply the
     information, control returns to the program with the carry flag
     set and error code 0001h (invalid function) in register AX.
.context @21h.44h.09h
.freeze 3
.topic Int 21h Function 44h Subfunction 09h
                                             \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h    \bSubfunction:\p   09h

  \bTitle:\p       IOCTL: Check if Block Device is Remote [Version 3.1+]

  \bDescription:\p

     Checks whether the specified block device is local (attached to
     the computer running the program) or remote (redirected to a
     network server). Use of this subfunction should be avoided.
     Application programs should not distinguish between files on
     local and remote devices.

     \bInput                               Output\p

     AH = 44h                            If function successful
     AL = 09h                              Carry flag: clear
     BL = Drive number (0 = default,       DX = Device attribute word
          1 = A, 2 = B,...)                     Bit 12 = 0 (if drive is
                                                         local)
                                                       = 1 (if drive is
                                                         remote)

                                         If function unsuccessful
                                           Carry flag: set
                                           AX = Error code (01h or 0Fh)
                                           See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.44h.0Ah
.freeze 3
.topic Int 21h Function 44h Subfunction 0Ah
 \i\p\aDetail\v@21h.44h.0Ah.des\v\i\p                                    \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h     \bSubfunction:\p   0Ah

  \bTitle:\p       IOCTL: Check if Handle is Remote [Version 3.1+]

  \bDescription:\p

     Checks whether the specified handle refers to a file or device
     that is local (located on the PC that is running the program) or
     remote (located on a network server).

     \bInput           Output\p

     AH = 44h        If function successful
     AL = 0Ah          Carry flag: clear
     BX = Handle       DX = Attribute word for file or device
                            Bit 15 = 0 (if local)
                                   = 1 (if remote)

                     If function unsuccessful
                       Carry flag: set
                       AX = Error code (01h or 06h)
                       See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.44h.0Ah.des
.freeze 3
.topic Int 21h Function 44h Subfunction 0Ah
 \i\p\aSummary\v@21h.44h.0Ah\v\i\p                                   \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Application programs should not ordinarily attempt to distinguish
     between files on local and remote devices.

     If the network has not been started, control returns to the
     calling program with the carry flag set and error code 0001h
     (invalid function) in register AX.
.context @21h.44h.0Bh
.freeze 3
.topic Int 21h Function 44h Subfunction 0Bh
 \i\p\aDetail\v@21h.44h.0Bh.des\v\i\p                                    \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h     \bSubfunction:\p   0Bh

  \bTitle:\p       IOCTL: Change Sharing Retry Count [Version 3.1+]

  \bDescription:\p

     Sets the number of times MS-DOS retries a disk operation after a
     failure caused by a file-sharing violation before it returns an
     error to the requesting process. This subfunction is not available
     unless the file-sharing module (SHARE.EXE) is loaded.

     \bInput                       Output\p

     AH = 44h                    If function successful
     AL = 0Bh                      Carry flag: clear
     CX = Delays per retry
          (default = 1)          If function unsuccessful
     DX = Number of retries        Carry flag: set
          (default = 3)            AX = Error code (01h)
                                   See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.44h.0Bh.des
.freeze 3
.topic Int 21h Function 44h Subfunction 0Bh
 \i\p\aSummary\v@21h.44h.0Bh\v\i\p                                   \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The length of a delay is a machine-dependent value determined by
     the CPU type and clock speed. Each delay consists of the following
     instruction sequence:

       xor cx,cx
       loop $

     which executes 65,536 times before falling out of the loop.

     The sharing retry count affects the behavior of the system as a
     whole and is not a local parameter for the process. If a program
     changes the sharing retry count, it should restore the default
     values before terminating.
.context @21h.44h.0Ch
.freeze 3
.topic Int 21h Function 44h Subfunction 0Ch
 \i\p\aDetail\v@21h.44h.0Ch.des\v\i\p                                    \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h     \bSubfunction:\p   0Ch

  \bTitle:\p       IOCTL: Generic I/O Control for Character Devices
               [Version 3.2+]

  \bDescription:\p

     Provides a general-purpose mechanism for communication between
     application programs and character device drivers.

     \bInput                              Output\p

     AH = 44h                           If function successful
     AL = 0Ch                             Carry flag: clear
     BX = Handle                        And if called with CL = 65h,
     CH = Category (major) code:        6Ah, or 6Bh
          00 = Unknown                    DS:DX = segment:offset of
          01 = COM1, COM2, COM3, or               parameter block
               COM4 [Version 3.3]
          03 = CON (keyboard and        If function unsuccessful
               display) [Version 3.3]     Carry flag: set
          05 = LPT1, LPT2, or LPT3        AX = Error code (01h)
               [Version 3.2]              See: \i\p\aError codes\v@errcod\v\i\p
     CL = Function (minor) code:
          45h = Set Iteration Count
                [Version 3.2]
          4AH = Select Code Page
                [Version 3.3]
          4CH = Start Code Page
                Preparation
                [Version 3.3]
          4DH = End Code Page
                Preparation
                [Version 3.3]
          5Fh = Set Display
                Information
                [Version 4.0]
          65h = Get Iteration Count
                [Version 3.2]
          6AH = Query Selected Code
                Page [Version 3.3]
          6BH = Query Prepare List
                [Version 3.3]
          7Fh = Get Display
                Information
                [Version 4.0]
     DS:DX = segment:offset of
             parameter block
.context @21h.44h.0Ch.des
.freeze 3
.topic Int 21h Function 44h Subfunction 0Ch
 \i\p\aSummary\v@21h.44h.0Ch\v\i\p                                   \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If the minor code is 45h (Set Iteration Count) or 65h (Get
     Iteration Count), the parameter block is simply a 2-byte buffer
     containing or receiving the iteration count for the printer. This
     call is valid only for printer drivers that support Output Until
     Busy, and determines the number of times the device driver will
     wait for the device to signal ready before returning from the
     output call.

     For MS-DOS version 3.3, the parameter block for minor codes 4Ah
     (Select Code Page), 4Dh (End Code Page Preparation), or 6Ah (Query
     Code Page) has the following format:

       WORD   2          ; length of following data
       WORD   ?          ; code page ID

     For MS-DOS version 4.0, minor codes 4Ah and 6Ah also set or get
     the double-byte character set (DBCS) lead byte table, and the
     following format is used:

       WORD   (n+2)*2+1  ; length of following data
       WORD   ?          ; code page ID
       BYTE   start, end ; DBCS lead byte range 1
       .
       .
       .
       BYTE   start, end ; DBCS lead byte range n
       BYTE   0, 0

     The parameter block for minor code 4Ch (Start Code Page
     Preparation) has the following format:

       WORD   0          ; font type
                         ; bit 0 = 0 downloaded
                         ;       = 1 cartridge
                         ; bits 1-15 = reserved (0)
       WORD   (n+1)*2    ; length of remainder of
                         ; parameter block
       WORD   n          ; number of code pages in
                         ; the following list
       WORD   ?          ; code page 1
       WORD   ?          ; code page 2
       .
       .
       .
       WORD   ?          ; code page n

     The parameter block for minor code 6Bh (Query Prepare List) has
     the following format, assuming n hardware code pages and m
     prepared code pages (n <= 12, m <= 12):

       WORD   (n+m+2)*2  ; length of following data
       WORD   n          ; number of hardware code pages
       WORD   ?          ; hardware code page 1
       WORD   ?          ; hardware code page 2
       .
       .
       .
       WORD   ?          ; hardware code page n
       WORD   m          ; number of prepared code pages
       WORD   ?          ; prepared code page 1
       WORD   ?          ; prepared code page 2
       .
       .
       .
       WORD   ?          ; prepared code page m

     After a minor code 4Ch (Start Code Page Preparation) call, the
     data defining the code page font is written to the driver using
     one or more calls to the IOCTL Write Control Data subfunction
     (Interrupt 21h, Function 44h, Subfunction 03h). The format of the
     data is device- and driver-specific. After the font data has been
     written to the driver, a minor code 4Dh (End Code Page
     Preparation) call must be issued. If no data is written to the
     driver between the minor code 4Ch and 4Dh calls, the driver
     interprets the newly prepared code pages as hardware code pages.

     A special variation of the minor code 4Ch (Start Code Page
     Preparation) call, called "Refresh," is required to actually load
     the peripheral device with the prepared code pages. The refresh
     operation is obtained by requesting minor code 4Ch with each code
     page position in the parameter block set to -1, followed by an
     immediate call for minor code 4Dh (End Code Page Preparation).

     [Version 4.0+]
     For minor codes 5Fh (Set Display Information) and 7Fh (Get Display
     Information), the parameter block is formatted as follows:

       BYTE   0          ; level (0 in MS-DOS 4.0)
       BYTE   0          ; reserved (must be 0)
       WORD   14         ; length of following data
       WORD   ?          ; control flags
                         ; bit 0  = 0 intensity
                         ;        = 1 blink
                         ; bits 1-15 = reserved (0)
       BYTE   ?          ; mode type (1 = text, 2 = APA)
       BYTE   0          ; reserved (must be 0)
       WORD   ?          ; colors
                         ; 0 = monochrome compatible
                         ; 1 = 2 colors
                         ; 2 = 4 colors
                         ; 4 = 16 colors
                         ; 8 = 256 colors
       WORD   ?          ; pixel columns
       WORD   ?          ; pixel rows
       WORD   ?          ; character columns
       WORD   ?          ; character rows
.context @21h.44h.0Dh
.freeze 3
.topic Int 21h Function 44h Subfunction 0Dh
 \i\p\aDetail\v@21h.44h.0Dh.des\v\i\p                                    \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h     \bSubfunction:\p   0Dh

  \bTitle:\p       IOCTL: Generic I/O Control for Block Devices [Version 3.2+]

  \bDescription:\p

     Provides a general-purpose mechanism for communication between
     application programs and block device drivers. Allows a program to
     inspect or change device parameters for a logical drive and to
     read, write, format, and verify disk tracks in a hardware-independent
     manner.

     \bInput                                Output\p

     AH = 44h                             If function successful
     AL = 0Dh                               Carry flag: clear
     BL = Drive code (0 = default,        And if called with
          1 = A, 2 = B,...)               CL = 60h or 61h
     CH = Category (major) code:            DS:DX = segment:offset of
          08h = Disk drive                          parameter block
     CL = Function (minor) code:
          40h = Set Device Parameters     If function unsuccessful
          41h = Write Track                 Carry flag: set
          42h = Format and Verify           AX = Error code (01h or 02h)
                Track                       See: \i\p\aError codes\v@errcod\v\i\p
          46h = Set Media ID (4.0+)
          47h = Set Access Flag
          60h = Get Device Parameters
          61h = Read Track
          62h = Verify Track
          66h = Get Media ID (4.0+)
          67h = Get Access Flag
     DS:DX = segment:offset of
             parameter block
.context @21h.44h.0Dh.des
.freeze 3
.topic Int 21h Function 44h Subfunction 0Dh
 \i\p\aSummary\v@21h.44h.0Dh\v\i\p                                   \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The minor code 40h (Set Device Parameters) function must be used
     before an attempt to write, read, format, or verify a track on a
     logical drive. In general, the following sequence applies to any
     of these operations:

        ş Get the current parameters (minor code 60h). Examine and save
          them. Set the new parameters (minor code 40h).
        ş Perform the task.
        ş Retrieve the original parameters and restore them with minor
          code 40h.

     For minor codes 40h (Set Device Parameters) and 60h (Get Device
     Parameters), the parameter block is formatted as follows:

     Special-functions field: offset 00h, length = 1 byte

     \bBits    Value     Meaning\p

     0       0         Device BPB field contains a new default BPB
             1         Use current BPB
     1       0         Use all fields in parameter block
             1         Use track layout field only
     2       0         Sectors in track may be different sizes
                       (should always be avoided)
             1         Sectors in track are all same size;
                       sector numbers range from 1 to the
                       total number of sectors in the track
                       (should always be used)
     3-7     0         Reserved

     Device type field: offset 01h, length 1 byte

     \bValue     Meaning\p

     0         320/360K, 5.25-inch disk
     1         1.2 megabyte, 5.25-inch disk
     2         720K, 3.5-inch disk
     3         Single-density, 8-inch disk
     4         Double-density, 8-inch disk
     5         Fixed disk
     6         Tape drive
     7         Other type of block device

     Device attributes field: offset 02h, length 1 word

     \bBits     Value     Meaning\p

     0        0       Removable storage medium
              1       Nonremovable storage medium
     1        0       Door lock not supported
              1       Door lock supported
     2-15     0       Reserved

     Number of cylinders field: offset 04h, length 1 word

     Maximum number of cylinders supported on the block device.

     Media type field: offset 06h, length 1 byte

     \bValue     Meaning\p

     0         1.2 megabyte, 5.25-inch disk
     1         320/360K, 5.25-inch disk

     Device BPB field: offset 07h, length 31 bytes

     If bit 0 = 0 in special-functions field, this field contains the
     new default BPB for the device.

     If bit 0 = 1 in special-functions field, the BPB in this field is
     returned by the device driver in response to subsequent Build BPB
     requests.

     Track layout field: offset 26h, variable-length table

     \bLength     Meaning\p

     Word       Number of sectors in track
     Word       Number of first sector in track
     Word       Size of first sector in track
     .
     .
     .
     Word       Number of last sector in track
     Word       Size of last sector in track

     The device BPB field is a 31-byte data structure that describes
     the current drive and its control areas. The field is formatted
     as follows:

     \bBytes       Meaning\p

     00h-01h     Bytes per sector
     02h         Sectors per cluster (allocation unit)
     03h-04h     Reserved sectors, beginning at sector 0
     05h         Number of file allocation tables (FATs)
     06h-07h     Maximum number of root-directory entries
     08h-09h     Number of sectors
     0Ah         Media descriptor
     0Bh-0Ch     Sectors per FAT
     0Dh-0Eh     Sectors per track
     0Fh-10h     Number of heads
     11h-14h     Number of hidden sectors
     15h-18h     Large number of sectors
                 (if bytes 08h-09h = 0)
     19h-1Eh     Reserved

     When minor code 40h (Set Device Parameters) is used, the number of
     cylinders should not be altered, or some or all of the volume may
     become inaccessible.

     For minor codes 41h (Write Track) and 61h (Read Track), the
     parameter block is formatted as follows:

     \bBytes       Meaning\p

     00h         Special-functions field (must be 0)
     01h-02h     Head
     03h-04h     Cylinder
     05h-06h     Starting sector
     07h-08h     Sectors to transfer
     09h-0Ch     Transfer buffer address

     For minor codes 42h (Format and Verify Track) and 62h (Verify
     Track), the parameter block is formatted as follows:

     \bBytes       Meaning\p

     00h         Special-functions field  (must be 0)

                 \bBits     Significance\p

                 0        Format/Verify track
                 1        Format status call [Version 4.0+]
                 1-7      Reserved (0)

     01h-02h     Head
     03h-04h     Cylinder

     In MS-DOS 4.0, this function may be called with bit 0 of the
     special-functions field set after a minor code 40h call (Set
     Device Parameters) to determine whether the driver supports the
     specified number of tracks and sectors per track. A status is
     returned in the special-functions field which is interpreted as
     follows:

     \bValue    Meaning\p

     0        Specified number of tracks and sectors per track
              supported
     1        This function not supported by the ROM BIOS
     2        Specified number of tracks and sectors per track not
              supported
     3        No disk in drive

     For minor codes 46h (Set Media ID) and 66h (Get Media ID), the
     parameter block is formatted as follows:

     Bytes       Meaning

     00h-01h     Information level (must be 0)
     02h-05h     Volume serial number (a hash of the time and date
                 at format time)
     06h-10h     Volume label from boot record (space padded)
     11h-19h     File system type (space padded). The string for
                 current versions can be "FAT12   ", "FAT16   ",
                 or "NO NAME  "

     These minor functions work in MS-DOS 4.0 and higher
.comment     but not in the OS/2 1.x compatibility box.

     For minor codes 47h (Set Access Flag) and 67h (Get Access Flag),
     the parameter block is formatted as follows:

     \bByte     Meaning\p

     00h      Special-functions field (must be 0)
     01h      Disk access flag

     When the disk access flag is zero, access to the medium is blocked
     by the driver. The flag is set to zero when the driver detects an
     unformatted medium or a medium with an invalid boot record. When
     the access flag is nonzero, read/write operations to the medium
     are allowed by the driver. A formatting program must set the disk
     access flag with minor code 47h before it requests minor code 42h
     (Format and Verify Track).
.context @21h.44h.0Eh
.freeze 3
.topic Int 21h Function 44h Subfunction 0Eh
                                             \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h     \bSubfunction:\p   0Eh

  \bTitle:\p       IOCTL: Get Logical Drive Map [Version 3.2+]

  \bDescription:\p

     Returns the logical drive code that was most recently used to
     access the specified block device. If a drive has not been
     assigned a logical mapping with Function 44h Subfunction OFh,
     the logical and physical drive codes are the same.

     \bInput                   Output\p

     AH = 44h                If function successful
     AL = 0Eh                  Carry flag: clear
     BL = Drive code           AL = Mapping code
          (0 = default,           = 00h (if only one logical drive code
           1 = A, 2 = B,                 assigned to the block device)
           ...)                   = 01h-1Ah (logical drive code (1 = A,
                                             2 = B,...) mapped to
                                             the block device)

                             If function unsuccessful
                               Carry flag: set
                               AX = Error code (01h or 05h)
                               See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.44h.0Fh
.freeze 3
.topic Int 21h Function 44h Subfunction 0Fh
                                             \i\p\aUp\v@21h.44h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   44h     \bSubfunction:\p   0Fh

  \bTitle:\p       IOCTL: Set Logical Drive Map [Version 3.2+]

  \bDescription:\p

     Sets the next logical drive code that will be used to reference a
     block device. When a physical block device is aliased to more than
     one logical drive code, this function can be used to inform the
     driver which drive code will next be used to access the device.

     \bInput                              Output\p

     AH = 44h                           If function successful
     AL = 0Fh                             Carry flag: clear
     BL = Drive code (0 = default,        AL = Mapping code
          1 = A, 2 = B,...)                  = 00h (if only one logical
                                                    drive code assigned
                                                    to the block device)
                                             = 01h-1Ah (logical drive
                                                        code (1 = A,
                                                        2 = B,...)
                                                        mapped to the
                                                        block device)

                                        If function unsuccessful
                                          Carry flag: set
                                          AX = Error code (01h or 05h)
                                          See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.45h
.freeze 3
.topic Int 21h Function 45h
 \i\p\aDetail\v@21h.45h.des\v\i\p                                    \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p     45h

  \bTitle:\p       Duplicate Handle

  \bSee also:\p    \aRedirect Handle\v@21h.46h\v, \aOpen File\v@21h.3Dh\v

  \bDescription:\p

     Given a handle for a currently open device or file, this function
     returns a new handle that refers to the same device or file at the
     same position.

     \bInput                            Output\p

     AH = 45h                         If function successful
     BX = Handle to be duplicated       Carry flag: clear
                                        AX = New handle

                                      If function unsuccessful
                                        Carry flag: set
                                        AX = Error code (04h or 06h)
                                        See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.45h.des
.freeze 3
.topic Int 21h Function 45h
 \i\p\aSummary\v@21h.45h\v\i\p                                   \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     A seek, read, or write operation that moves the file pointer for
     one of the two handles also moves the file pointer associated with
     the other.

     This function can be used to efficiently update the directory for
     a file that has changed in length, without incurring the overhead
     of closing and then reopening the file. The handle for the file is
     simply duplicated with this function and the duplicate is closed,
     leaving the original handle open for further read/write
     operations.
.context @21h.46h
.freeze 3
.topic Int 21h Function 46h
 \i\p\aDetail\v@21h.46h.des\v\i\p                                    \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   46h

  \bTitle:\p       Redirect Handle

  \bSee also:\p    \aDuplicate Handle\v@21h.45h\v

  \bDescription:\p

     Given two handles, this function makes the second handle refer to
     the same device or file at the same location as the first handle.
     The second handle is then said to be redirected.

     \bInput                              Output\p

     AH = 46h                           If function successful
     BX = Handle for file or device       Carry flag: clear
     CX = Handle to be redirected
                                        If function unsuccessful
                                          Carry flag: set
                                          AX = Error code (04h or 06h)
                                          See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.46h.des
.freeze 3
.topic Int 21h Function 46h
 \i\p\aSummary\v@21h.46h\v\i\p                                   \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If the handle passed in CX already refers to an open file, that
     file is closed first.

     A seek, read, or write operation that moves the file pointer for
     one of the two handles also moves the file pointer associated with
     the other.

     This function is commonly used to redirect the standard input and
     output handles to another file or device before a child process is
     executed with Int 21h Function 4Bh.
.context @21h.47h
.freeze 3
.topic Int 21h Function 47h
 \i\p\aDetail\v@21h.47h.des\v\i\p \i\p\aExample\v@GetCurDi.asx\v\i\p                          \i\p\aUp\v@21.dir\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   47h

  \bTitle:\p       Get Current Directory

  \bSee also:\p    \aSet Current Directory\v@21h.3Bh\v, \aCreate Directory\v@21h.39h\v,
               \aDelete Directory\v@21h.3Ah\v, @GetDir

  \bDescription:\p

     Obtains an ASCIIZ string that describes the path from the root to
     the current directory, and the name of that directory.

     \bInput                             Output\p

     AH = 47h                          If function successful
     DL = Drive code (0 = default,       Carry flag: clear
          1 = A,...)                   And buffer is filled in with
     DS:SI = segment:offset of         full path name from root of
             64-byte buffer            current directory

                                       If function unsuccessful
                                         Carry flag: set
                                         AX = Error code (0Fh)
                                         See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.47h.des
.freeze 3
.topic Int 21h Function 47h
 \i\p\aSummary\v@21h.47h\v\i\p \i\p\aExample\v@GetCurDi.asx\v\i\p                         \i\p\aUp\v@21.dir\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The returned path name does not include the drive identifier or a
     leading backslash (\\). It is terminated with a null (00h) byte.
     Consequently, if the current directory is the root directory, the
     first byte in the buffer will contain 00h.

     The function fails if the drive code is invalid.

     The current directory may be set with Int 21h Function 3Bh.
.context @21h.48h
.freeze 3
.topic Int 21h Function 48h
 \i\p\aDetail\v@21h.48h.des\v\i\p \i\p\aExample\v@WinOpen.asx\v\i\p                          \i\p\aUp\v@21.mem\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   48h

  \bTitle:\p       Allocate Memory Block

  \bSee also:\p    \aRelease Memory Block\v@21h.49h\v, \aResize Memory Block\v@21h.4Ah\v,
               \aGet or Set Allocation Strategy\v@21h.3Ah\v, @GetBlock

  \bDescription:\p

     Allocates a block of memory and returns a pointer to the beginning
     of the allocated area.

     \bInput                         Output\p

     AH = 48h                      If function successful
     BX = Number of paragraphs       Carry flag: clear
          of memory needed           AX = Initial segment of allocated
                                          block

                                   If function unsuccessful
                                     Carry flag: set
                                     AX = Error code (07h or 08h)
                                     See: \i\p\aError codes\v@errcod\v\i\p
                                     BX = Size of largest available
                                          block (paragraphs)
.context @21h.48h.des
.freeze 3
.topic Int 21h Function 48h
 \i\p\aSummary\v@21h.48h\v\i\p \i\p\aExample\v@WinOpen.asx\v\i\p                         \i\p\aUp\v@21.mem\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If the function succeeds, the base address of the newly allocated
     block is AX:0000.

     The default allocation strategy used by MS-DOS is "first fit";
     that is, the memory block at the lowest address that is large
     enough to satisfy the request is allocated. The allocation
     strategy can be altered with Int 21h Function 58h.

     When a .COM program is loaded, it ordinarily already "owns" all of
     the memory in the transient program area, leaving none for dynamic
     allocation. The amount of memory initially allocated to a .EXE
     program at load time depends on the MINALLOC and MAXALLOC fields
     in the .EXE file header.
.context @21h.49h
.freeze 3
.topic Int 21h Function 49h
 \i\p\aDetail\v@21h.49h.des\v\i\p \i\p\aExample\v@WinClose.asx\v\i\p                          \i\p\aUp\v@21.mem\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   49h

  \bTitle:\p       Release Memory Block

  \bSee also:\p    \aAllocate Memory Block\v@21h.48h\v, @FreeBlock

  \bDescription:\p

     Releases a memory block and makes it available for use by other
     programs.

     \bInput                        Output\p

     AH = 49h                     If function successful
     ES = Segment of block to       Carry flag: clear
          be released
                                  If function unsuccessful
                                    Carry flag: set
                                    AX = Error code (07h or 09h)
                                    See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.49h.des
.freeze 3
.topic Int 21h Function 49h
 \i\p\aSummary\v@21h.49h\v\i\p \i\p\aExample\v@WinClose.asx\v\i\p                         \i\p\aUp\v@21.mem\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function assumes that the memory block being released was
     previously obtained by a successful call to Int 21h Function 48h.

     The function will return an error code and can cause unpredictable
     system errors if

        ş The program releases a memory block that does not belong to
          it.
        ş The segment address passed in register ES is not a valid base
          address for an existing memory block.
.context @21h.4Ah
.freeze 3
.topic Int 21h Function 4Ah
 \i\p\aDetail\v@21h.4Ah.des\v\i\p \i\p\aExample\v@NewBlock.asx\v\i\p                          \i\p\aUp\v@21.mem\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   4Ah

  \bTitle:\p       Resize Memory Block

  \bSee also:\p    \aAllocate Memory Block\v@21h.48h\v, @ModBlock

  \bDescription:\p

     Dynamically shrinks or extends a memory block according to the
     needs of an application program.

     \bInput                              Output\p

     AH = 4Ah                           If function successful
     BX = Desired new block size in       Carry flag: clear
          paragraphs
     ES = Segment of block to be        If function unsuccessful
          modified                        Carry flag: set
                                          AX = Error code (07, 08h, or
                                               09h)
                                          See: \i\p\aError codes\v@errcod\v\i\p
                                          BX = Maximum block size
                                               available (paragraphs)
.context @21h.4Ah.des
.freeze 3
.topic Int 21h Function 4Ah
 \i\p\aSummary\v@21h.4Ah\v\i\p \i\p\aExample\v@NewBlock.asx\v\i\p                         \i\p\aUp\v@21.mem\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function modifies the size of a memory block that was
     previously allocated with a call to Int 21h Function 48h.

     If the program is requesting an increase in the size of an
     allocated block and this function fails, the maximum possible
     size for the specified block is returned in register BX. The
     program can use this value to determine whether it should
     terminate, or continue in a degraded fashion with less memory.

     A program that uses EXEC (Int 21h Function 4Bh) to load and
     execute a child program must call this function first, passing the
     address of its own PSP in register ES and the amount of memory
     needed for its own code, data, and stacks in register BX.
.context @21h.4Bh
.freeze 3
.topic Int 21h Function 4Bh
 \i\p\aDetail\v@21h.4Bh.des\v\i\p \i\p\aExample\v@Exec.asx\v\i\p                          \i\p\aUp\v@21.process\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   4Bh

  \bTitle:\p       Execute Program (EXEC)

  \bSee also:\p    \aGet Return Code\v@21h.4Dh\v, \aFile Control Block (FCB)\v@FCB\v

  \bDescription:\p

     Allows an application program to run another program, regaining
     control when it is finished. This function can also be used to
     load overlays, although this use is uncommon.

     \bInput                                   Output\p

     AH = 4Bh                                If function successful
     AL = Subfunction                          Carry flag: clear
          00h = Load and Execute Program     All registers except for
          03h = Load Overlay                 CS:IP may be destroyed
     ES:BX = segment:offset of parameter     [Version 3.0+] Registers
             block                           are preserved in the
     DS:DX = segment:offset of program       usual fashion
             specification
                                             If function unsuccessful
                                               Carry flag: set
                                               AX = Error code (01h,
                                                    02h, 03h, 05h, 08h,
                                                    0Ah, or 0Bh)
                                               See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.4Bh.des
.freeze 3
.topic Int 21h Function 4Bh
 \i\p\aSummary\v@21h.4Bh\v\i\p \i\p\aExample\v@Exec.asx\v\i\p                         \i\p\aUp\v@21.process\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The parameter block format for Subfunction 00h (Load and Execute
     Program) is as follows:

     \bBytes       Contents\p

     00h-01h     Segment pointer to environment block
     02h-03h     Offset of command line tail
     04h-05h     Segment of command line tail
     06h-07h     Offset of first FCB to be copied into new PSP+5Ch
     08h-09h     Segment of first FCB
     0Ah-0Bh     Offset of second FCB to be copied into new PSP+6Ch
     0Ch-0Dh     Segment of second FCB

     The parameter block format for Subfunction 03h (Load Overlay) is
     as follows:

     \bBytes       Contents\p

     00h-01h     Segment address where overlay is to be loaded
     02h-03h     Relocation factor to apply to loaded image

     The environment block must be paragraph aligned. It consists of a
     sequence of ASCIIZ strings in the form:

       BYTE   'COMSPEC=A:\\COMMAND.COM',0

     The entire set of strings is terminated by an extra null (00h)
     byte.

     The command tail format consists of a count byte, followed by an
     ASCII string, terminated by a carriage return (which is not
     included in the count). The first character in the string should
     be an ASCII space (20h) for compatibility with the command tail
     passed to programs by COMMAND.COM. For example:

       BYTE   6,' *.DAT',0dh

     Before a program uses Int 21h Function 4Bh to run another program,
     it must release all memory it is not actually using with a call to
     Int 21h Function 4Ah, passing the segment address of its own PSP
     and the number of paragraphs to retain.

     Ordinarily, all active handles of the parent program are inherited
     by the child program, although the parent can prevent this in
     MS-DOS versions 3.0 and later by setting the inheritance bit when
     the file or device is opened. Any redirection of the standard
     input and/or output in the parent process also affects the child
     process.

     The environment block can be used to pass information to the child
     process. If the environment block pointer in the parameter block
     is zero, the child program inherits an exact copy of the parent's
     environment. In any case, the segment address of the child's
     environment is found at offset 002Ch in the child's PSP.

     After return from the EXEC function call, the termination type and
     return code of the child program may be obtained with Int 21h
     Function 4Dh.

     The following structure defines the parameter block:

       PARAM_BLK    STRUCT
         EnvSeg     WORD    ?               ; Segment address of
                                              environment block
         TailAddr   DWORD   WORD PTR ?      ; Segment:offset of command-
                                              line tail
         Fcb1Addr   DWORD   WORD PTR ?      ; Segment:offset of 1st FCB
         Fcb2Addr   DWORD   WORD PTR ?      ; Segment:offset of 2nd FCB
       PARAM_BLK    ENDS

     The command-line tail is a string containing the program arguments
     as they would be entered from the keyboard. The first byte
     specifies the number of characters in the tail, including tabs and
     spaces. The terminating byte must be ASCII character 0Dh (carriage
     return), which is not included in the character count.
.context @21h.4Ch
.freeze 3
.topic Int 21h Function 4Ch
 \i\p\aDetail\v@21h.4Ch.des\v\i\p \i\p\aExample\v@hellomo.asm\v\i\p                          \i\p\aUp\v@21.process\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   4Ch

  \bTitle:\p       Terminate Process with Return Code

  \bSee also:\p    @Exit

  \bDescription:\p

     Terminates the current process, passing a return code to the
     parent process. This is one of several methods that a program can
     use to perform a final exit.

     If you use the .STARTUP directive, you should also use the .EXIT
     directive, which automatically generates code to call this
     function.

     \bInput                Output\p

     AH = 4Ch             None
     AL = Return code
.context @21h.4Ch.des
.freeze 3
.topic Int 21h Function 4Ch
 \i\p\aSummary\v@21h.4Ch\v\i\p \i\p\aExample\v@hellof.asm\v\i\p                         \i\p\aUp\v@21.process\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function performs the following actions:

        ş All memory belonging to the process is released.

        ş File buffers are flushed and any open handles for files or
          devices owned by the process are closed.

        ş The termination handler vector (Int 22h) is restored from
          PSP:000Ah.

        ş The CTRL+C handler vector (Int 23h) is restored from
          PSP:000Eh.

        ş The critical-error handler vector (Int 24h) is restored from
          PSP:0012h.

        ş Control is transferred to the termination handler.

     If the program is returning to COMMAND.COM, control transfers to
     the resident portion and the transient portion is reloaded if
     necessary. If a batch file is in progress, the next line of the
     fil` is fetched and interpreted; otherwise, a prompt is issued
     for the next user command.

     This is the preferred method of termination for application
     programs because it allows a return code to be passed to the
     parent program and does not rely on the contents of any segment
     register. Other methods of performing a final exit are Int 20h,
     Int 21h Function 00h, Int 21h Function 31h, and Int 27h.

     Any files that have been opened using FCBs and modified by the
     program should be closed before program termination; otherwise,
     data may be lost.

     The return code can be retrieved by the parent process with Int
     21h Function 4Dh (Get Return Code). It can also be tested in a
     batch file with an IF ERRORLEVEL statement. By convention, a
     return code of zero indicates successful execution, and a nonzero
     return code indicates an error.

     [Version 3.0+]
     If the program is running on a network, it should remove all locks
     it has placed on file regions before terminating.
.context @21h.4Dh
.freeze 3
.topic Int 21h Function 4Dh
 \i\p\aDetail\v@21h.4Dh.des\v\i\p \i\p\aExample\v@Exec.asx\v\i\p                          \i\p\aUp\v@21.process\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   4Dh

  \bTitle:\p       Get Return Code

  \bSee also:\p    \aExecute Program\v@21h.4Bh\v

  \bDescription:\p

     Used by a parent process, after the successful execution of an
     EXEC call (Int 21h Function 4Bh), to obtain the return code and
     termination type of a child process.

     \bInput        Output\p

     AH = 4Dh     AH = Exit type
                     = 00h (if normal termination by Int 20h, Int 21h
                            Function 0, or Int 21h Function 4Ch)
                     = 01h (if termination by user's entry of CTRL+C)
                     = 02h (if termination by critical-error handler)
                     = 03h (if termination by Int 21h Function 31h or
                            Int 27h)
                  AL = Return code passed by child process (0 if child
                       terminated by Int 20h, Int 21h Function 00h, or
                       Int 27h)
.context @21h.4Dh.des
.freeze 3
.topic Int 21h Function 4Dh
 \i\p\aSummary\v@21h.4Dh\v\i\p \i\p\aExample\v@Exec.asx\v\i\p                         \i\p\aUp\v@21.process\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function will yield the return code of a child process only
     once. A subsequent call without an intervening EXEC (Int 21h
     Function 4Bh) will not necessarily return any valid information.

     This function does not set the carry flag to indicate an error. If
     no previous child process has been executed, the values returned
     in AL and AH are undefined.
.context @21h.4Eh
.freeze 3
.topic Int 21h Function 4Eh
 \i\p\aDetail\v@21h.4Eh.des\v\i\p \i\p\aExample\v@FindFirs.asx\v\i\p                          \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   4Eh

  \bTitle:\p       Find First File

  \bSee also:\p    \aFind Next File\v@21h.4Fh\v, \aSet DTA Address\v@21h.1Ah\v,
               \aDOS File Date/Time Formats\v@Datime\v, @GetFirst

  \bDescription:\p

     Given a file specification in the form of an ASCIIZ string, this
     function searches the default or specified directory on the
     default or specified drive for the first matching file.

     \bInput                               Output\p

     AH = 4Eh                             If function unsuccessful (no
     CX = Attribute to use in search      matching files)
          (bits can be combined)            Carry flag: set
                                            AX = Error code (02h, 03h,
          Bits   Significance                    or 12h)
                 (if set)                   See: \i\p\aError codes\v@errcod\v\i\p

          0      Read-only                If function successful
          1      Hidden                   (matching file found)
          2      System                     Carry flag: clear
          3      Volume label
          4      Directory                Disk transfer area (DTA)
          5      Archive                  filled in as follows:
          6-15   Reserved (0)
                                          Bytes     Description
     DS:DX = segment:offset of ASCIIZ
             path name                    00h-14h   Reserved (0)
                                          15h       Attribute of matched
                                                    file or directory
                                          16h-17h   \aPacked file time\v@Datime\v
                                          18h-19h   \aPacked file date\v@Datime\v
                                          1Ah-1Dh   File size
                                          1Eh-2Ah   ASCIIZ filename
.context @21h.4Eh.des
.freeze 3
.topic Int 21h Functions 4Eh and 4Fh
 \i\p\aSummary\v@21h.4Eh\v\i\p \i\p\aExample\v@FindFirs.asx\v\i\p                         \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     These functions assume that the DTA has been previously set by the
     program with Int 21h Function 1Ah to point to a buffer of adequate
     size.

     The * and ? wildcard characters are allowed in the filename. If
     wildcard characters are present, function 4Eh returns only the
     first matching filename. To get additional matching files, call
     function 4Fh repeatedly until it fails (by setting the carry
     flag and returning an error code in AX).

     If the initial attribute is 00h, only ordinary files are found.
     If the volume label attribute bit is set, only volume labels will
     be returned (if any are present). Any other attribute or
     combination of attributes (hidden, system, and directory) results
     in those files and all normal files being matched.

     The following 43-byte structure defines the DTA:

       DTA          STRUCT
         Rsv        BYTE    21 DUP(?)       ; Reserved by DOS
         Attr       BYTE    ?               ; File attribute
         Time       WORD    ?               ; Time file created or last
                                                updated
         Date       WORD    ?               ; Date file created or
                                                last updated
         Len        DWORD   ?               ; File size in bytes
         FName      BYTE    13 DUP(?)       ; Filename.ext with zero
                                                terminator
       DTA          ENDS

     The Date and Time members use the standard packed date/time formats.
.context @21h.4Fh
.freeze 3
.topic Int 21h Function 4Fh
 \i\p\aExample\v@FindNext.asx\v\i\p                                   \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   4Fh

  \bTitle:\p       Find Next File

  \bSee also:\p    \aFind First File\v@21h.4Eh\v, \aSet DTA Address\v@21h.1Ah\v, \aDOS File Date/Time\v@Datime\v
               \aFormats\v@Datime\v, @GetNext

  \bDescription:\p

     Assuming a previous successful call to Int 21h Function 4Eh, this
     function finds the next file in the default or specified directory
     on the default or specified drive that matches the original file
     specification.

     \bInput                             Output\p

     AH = 4Fh                          If function unsuccessful (no
     Assumes DTA points to working     matching files)
     buffer used by previous             Carry flag: set
     successful call to Int 21h          AX = Error code (12h)
     Function 4Eh or 4Fh                 See: \i\p\aError codes\v@errcod\v\i\p

                                       If function successful
                                       (matching file found)
                                         Carry flag: clear

                                       Disk transfer area (DTA)
                                       filled in as follows:

                                       Bytes     Description

                                       00h-14h   Reserved (0)
                                       15h       Attribute of matched
                                                 file or directory
                                       16h-17h   \aPacked file time\v@Datime\v
                                       18h-19h   \aPacked file date\v@Datime\v
                                       1Ah-1Dh   File size
                                       1Eh-2Ah   ASCIIZ filename
.context @21h.50h
.freeze 3
.topic Set PSP Address Interrupt
                                             \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   50h

  \bTitle:\p       Set PSP Address

  \bSee also:\p    \aProgram Segment Prefix\v@SegmentPrefix\v, \aGet PSP Address\v@21h.51h\v

  \bDescription:\p

     Sets 256-byte data area as new program segment prefix (PSP). The
     area must be properly initialized with valid PSP data.

     This function does not recover from errors and must be used with
     care.

     \bInput                            Output\p

     AH = 50h                         None
     BX = New PSP segment address
.context @21h.51h
.freeze 3
.topic Get PSP Address Interrupt
                                             \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   51h

  \bTitle:\p       Get PSP Address

  \bSee also:\p    \aProgram Segment Prefix\v@SegmentPrefix\v, \aGet PSP Address\v@21h.50h\v

  \bDescription:\p

     Returns the segment address of a current program segment prefix
     (PSP).

     \bInput        Output\p

     AH = 51h     BX = PSP segment address
.context @21h.54h
.freeze 3
.topic Int 21h Function 54h
 \i\p\aDetail\v@21h.2Eh.des\v\i\p                                    \i\p\aUp\v@21.disk\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   54h

  \bTitle:\p       Get Verify Flag

  \bSee also:\p    \aSet Verify Flag\v@21h.2Eh\v

  \bDescription:\p

     Obtains the current value of the system verify (read-after-write)
     flag.

     \bInput         Output\p

     AH = 54h      AL = Current verify flag value
                      = 00h (if verify OFF)
                      = 01h (if verify ON)
.context @21h.56h
.freeze 3
.topic Int 21h Function 56h
 \i\p\aDetail\v@21h.56h.des\v\i\p \i\p\aExample\v@RenameFi.asx\v\i\p                          \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   56h

  \bTitle:\p       Rename File

  \bSee also:\p    @MoveFile

  \bDescription:\p

     Renames a file and/or moves its directory entry to a different
     directory on the same disk. In MS-DOS versions 3.0 and later, this
     function can also be used to rename a directory.

     \bInput                                Output\p

     AH = 56h                             If function successful
     DS:DX = segment:offset of              Carry flag: clear
             current ASCIIZ path name
     ES:DI = segment:offset of new        If function unsuccessful
             ASCIIZ path name               Carry flag: set
                                            AX = Error code (02h, 03h,
                                                 05h, or 11h)
                                            See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.56h.des
.freeze 3
.topic Int 21h Function 56h
 \i\p\aSummary\v@21h.56h\v\i\p \i\p\aExample\v@RenameFi.asx\v\i\p                         \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The function fails if

        ş Any element of the path name does not exist.
        ş A file with the new path name already exists.
        ş The current path name specification contains a different disk
          drive than does the new path name.
        ş The file is being moved to the root directory and the root
          directory is full.
        ş [Version 3.0+] The program is running on a network and the user
          has insufficient access rights to either the existing file
          or the new directory.

     The * and ? wildcard characters are not allowed in either the
     current or new path name specifications.
.context @21h.57h
.freeze 3
.topic Int 21h Function 57h
 \i\p\aDetail\v@21h.57h.des\v\i\p \i\p\aExample\v@SetAttri.asx\v\i\p                          \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   57h

  \bTitle:\p       Get or Set File Date and Time

  \bSee also:\p    \aDOS File Date/Time Formats\v@Datime\v, \aGet Date\v@21h.2Ah\v, \aGet Time\v@21h.2Ch\v

  \bDescription:\p

     Obtains or modifies the date and time stamp in a file's directory
     entry.

     \bInput                                       Output\p

     If getting date and time                    If function successful
       AH = 57h                                    Carry flag: clear
       AL = 00h                                  And if called with
       BX = Handle                               AL = 00h
                                                   CX = Time
     If setting date and time                      DX = Date
       AH = 57h
       AL = 01h                                  If function unsuccessful
       BX = Handle                                 Carry flag: set
       CX = Time                                   AX = Error code (01h
            Bits 0Bh-0Fh = hours (0-23)                 or 06h)
            Bits 05h-0AH = minutes (0-59)          See: \i\p\aError codes\v@errcod\v\i\p
            Bits 00h-04h = 2-second increments
                           (0-29)
       DX = Date
            Bits 09h-0Fh = year (relative to
                           1980)
            Bits 05h-08h = month (1-12)
            Bits 00h-04h = day (1-31)

.context @21h.57h.des
.freeze 3
.topic Int 21h Function 57h
 \i\p\aSummary\v@21h.57h\v\i\p \i\p\aExample\v@SetAttri.asx\v\i\p                         \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The file must have been previously opened or created via a
     successful call to Int 21h Function 3Ch, 3Dh, 5Ah, 5Bh, or 6Ch.

     If the 16-bit date for a file is set to zero, that file's date and
     time are not displayed on directory listings.

     A date and time set with this function will prevail, even if the
     file is modified afterwards before the handle is closed.
.context @21h.58h
.freeze 3
.topic Int 21h Function 58h
 \i\p\aDetail\v@21h.58h.des\v\i\p                                    \i\p\aUp\v@21.mem\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   58h

  \bTitle:\p       Get or Set Allocation Strategy [Version 3.0+]

  \bSee also:\p    \aAllocate Memory Block\v@21h.48h\v

  \bDescription:\p

     Obtains or changes the code indicating the current MS-DOS strategy
     for allocating memory blocks.

     \bInput                           Output\p

     If getting strategy code        If function successful
       AH = 58h                        Carry flag: clear
       AL = 00h                      And if called with AL = 00h
                                       AX = Allocation chosen
     If setting strategy code               00h = First fit
       AH = 58h                             01h = Best fit
       AL = 01h                             02h = Last fit
       BX = Desired strategy code    If function unsuccessful
            00h = First fit            Carry flag: set
            01h = Best fit             AX = Error code (01h)
            02h = Last fit             See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.58h.des
.freeze 3
.topic Int 21h Function 58h
 \i\p\aSummary\v@21h.58h\v\i\p                                   \i\p\aUp\v@21.mem\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The memory allocation strategies are:

     First Fit: MS-DOS searches the available memory blocks from low
     addresses to high addresses, assigning the first one large enough
     to satisfy the block allocation request.

     Best Fit: MS-DOS searches all available memory blocks and assigns
     the smallest available block that will satisfy the request,
     regardless of its position.

     Last Fit: MS-DOS searches the available memory blocks from high
     addresses to low addresses, assigning the highest one large enough
     to satisfy the block allocation request.

     The default MS-DOS memory allocation strategy is First Fit
     (code 0).
.context @21h.59h
.freeze 3
.topic Int 21h Function 59h
 \i\p\aDetail\v@21h.59h.des\v\i\p                                    \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   59h

  \bTitle:\p       Get Extended Error Information [Version 3.0+]

  \bSee also:\p    \aSet Extended Error Information\v@21h.5D0Ah\v

  \bDescription:\p

     Obtains detailed error information after a previous unsuccessful
     Int 21h function call, including the recommended remedial action.

     \bInput        Output\p

     AH = 59h     AX = Extended error code
     BX = 00h     See: \i\p\aError codes\v@errcod\v\i\p
                  BH = Error class
                       01h (if out of resource (such as storage
                            or handles))
                       02h (if not error, but temporary situation
                            (such as locked region in file) that
                            can be expected to end)
                       03h (if authorization problem)
                       04h (if internal error in system software)
                       05h (if hardware failure)
                       06h (if system software failure not the
                            fault of the active process (such
                            as missing configuration files)
                       07h (if application program error)
                       08h (if file or item not found)
                       09h (if file or item of invalid type or
                            format)
                       0Ah (10) (if file or item interlocked)
                       0Bh (11) (if wrong disk in drive, bad spot on
                                 disk, or storage medium problem)
                       0Ch (12) (if other error)
                  BL = Recommended action
                       01h Retry reasonable number of times,
                           then prompt user to select abort or
                           ignore
                       02h Retry reasonable number of times
                           with delay between retries, then
                           prompt user to select abort or
                           ignore
                       03h Get corrected information from user
                           (typically caused by incorrect
                            filename or drive specification)
                       04h Abort application with cleanup
                           (terminate the program in as
                            orderly a manner as possible,
                            releasing locks, closing files,
                            ...)
                       05h Perform immediate exit without
                           cleanup
                       06h Ignore error
                       07h Retry after user intervention to
                           remove cause of error
                  CH = Error locus
                       01h Unknown
                       02h Block device (disk or disk
                           emulator)
                       03h Network
                       04h Serial device
                       05h Memory
                  And for MS-DOS versions 3.0+
               ES:DI = ASCIIZ volume label of disk to insert, if
                       AX = 0022h (invalid disk change)

.context @21h.59h.des
.freeze 3
.topic Int 21h Function 59h
 \i\p\aSummary\v@21h.59h\v\i\p                                   \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function may be called after any other Int 21h function call
     that returned an error status, in order to obtain more detailed
     information about the error type and the recommended action. If
     the previous Int 21h function call had no error, 0000h is returned
     in register AX. This function may also be called during the
     execution of a critical-error (Int 24h) handler.

     The contents of registers CL, DX, SI, DI, BP, DS, and ES are
     destroyed by this function.

     Note that extended error codes 13h-1Fh (19-31) and 22h (34)
     correspond exactly to the error codes 0-0Ch (0-12) and 0Fh (15)
     returned by Int 24h.

     You should not code your programs to recognize only specific error
     numbers if you want to ensure upward compatibility, because new
     error codes are added in each new version of MS-DOS.

     Under DOS 3.1, an application can use function 59h to preserve
     current extended error information and to later restore the
     information to DOS with function 5D0Ah. After calling function
     59h, the application copies registers AX, BX, CX, DX, SI, DI, DX,
     and ES in the order given to an 11-word data structure. The last
     three words of the structure should each be set to zero.

     The following defines the extended error structure:

       EXTEND_ERR   STRUCT
         rAx        WORD    ?               ; AX
         rBx        WORD    ?               ; BX
         rCx        WORD    ?               ; CX
         rDx        WORD    ?               ; DX
         rSi        WORD    ?               ; SI
         rDi        WORD    ?               ; DI
         rDs        WORD    ?               ; DS
         rEs        WORD    ?               ; ES
         Pad        WORD    3 DUP(0)
       EXTEND_ERR   ENDS
.context @21h.5Ah
.freeze 3
.topic Int 21h Function 5Ah
 \i\p\aDetail\v@21h.5Ah.des\v\i\p \i\p\aExample\v@UniqueFi.asx\v\i\p                          \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   5Ah

  \bTitle:\p       Create Temporary File [Version 3.0+]

  \bSee also:\p    \aCreate File\v@21h.3Ch\v, @MakeFile

  \bDescription:\p

     Creates a file with a unique name, in the current or specified
     directory on the default or specified disk drive, and returns a
     handle that can be used by the program for subsequent access to
     the file. The name generated for the file is also returned in a
     buffer specified by the program.

     \bInput                                     Output\p

     AH = 5Ah                                  If function successful
     CX = Attribute (bits can be combined)       Carry flag: clear
                                                 AX = Handle
          \bBits     Significance (if set)\p         DS:DX = segment:offset of
                                                         complete ASCIIZ
          0        Read-only                             path name
          1        Hidden
          2        System                      If function unsuccessful
          3-4      Reserved (0)                  Carry flag: set
          5        Archive                       AX = Error code (03h,
          6-15     Reserved (0)                       04h, or 05h)
                                                 See: \i\p\aError codes\v@errcod\v\i\p
     DS:DX = segment:offset of ASCIIZ path
             name
.context @21h.5Ah.des
.freeze 3
.topic Int 21h Function 5Ah
 \i\p\aSummary\v@21h.5Ah\v\i\p \i\p\aExample\v@UniqueFi.asx\v\i\p                         \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The ASCIIZ path supplied to this function should be followed by at
     least 13 additional bytes of buffer space. MS-DOS adds a backslash
     (\\) to the supplied path if necessary, then appends a
     null-terminated filename that is a function of the current time.

     Files created with this function are not automatically deleted
     when the calling program terminates.

     The function fails if

        ş Any element of the path name does not exist.
        ş The file is being created in the root directory and the root
          directory is full.

     [Version 3.0+]
     If the program is running on a network, the file is created and
     opened for read/write access in compatibility sharing mode.
.context @21h.5Bh
.freeze 3
.topic Int 21h Function 5Bh
 \i\p\aDetail\v@21h.5Bh.des\v\i\p \i\p\aExample\v@CreateNe.asx\v\i\p                          \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   5Bh

  \bTitle:\p       Create New File [Version 3.0+]

  \bSee also:\p    \aCreate File\v@21h.3Ch\v, @MakeFile

  \bDescription:\p

     Given an ASCIIZ path name, creates a file in the designated or
     default directory on the designated or default drive and returns a
     handle that can be used by the program for subsequent access to
     the file. If a file with the same name already exists, the
     function fails.

     \bInput                                     Output\p

     AH = 5Bh
     CX = Attribute (bits can be combined)     If function successful
                                                 Carry flag: clear
          \bBits     Significance (if set)\p         AX = Handle

          0        Read-only                   If function unsuccessful
          1        Hidden                        Carry flag: set
          2        System                        AX = Error code (03h, 04h,
          3        Volume label                       05h, or 50h)
          4        Reserved (0)                  See: \i\p\aError codes\v@errcod\v\i\p
          5        Archive
          6-15     Reserved (0)

     DS:DX = segment:offset of ASCIIZ
             path name
.context @21h.5Bh.des
.freeze 3
.topic Int 21h Function 5Bh
 \i\p\aSummary\v@21h.5Bh\v\i\p \i\p\aExample\v@CreateNe.asx\v\i\p                         \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The function fails if

        ş Any element of the specified path does not exist.
        ş A file with the identical path name (the same filename
          and extension in the same location in the directory
          structure) already exists.
        ş The file is being created in the root directory and the root
          directory is full.
        ş [Version 3.0+] The program is running on a network and the
          user has insufficient access rights to the directory that
          will contain the file.

     The file is usually given the normal attribute (0) when it is
     created, and is opened for both read and write operations. The
     attribute can subsequently be modified with Int 21h Function 43h.

     See also Int 21h Functions 3Ch, 5Ah, and 6Ch, which provide
     alternative ways of creating files.

     This function may be used to implement semaphores in a network or
     multitasking environment. If the function succeeds, the program
     has acquired the semaphore. To release the semaphore, the program
     simply deletes the file.
.context @21h.5Ch
.freeze 3
.topic Int 21h Function 5Ch
 \i\p\aDetail\v@21h.5Ch.des\v\i\p                                    \i\p\aUp\v@21.rec\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   5Ch

  \bTitle:\p       Lock or Unlock File Region [Version 3.0+]

  \bSee also:\p    \aSet File Pointer\v@21h.42h\v

  \bDescription:\p

     Locks or unlocks a specified region of a file that was previously
     opened or created with Int 21h Functions 3Ch, 3Dh, 5Ah, or 5Bh.
     This function is not available unless the file-sharing module
     (SHARE.EXE) is loaded.

     \bInput                               Output\p

     AH = 5Ch                            If function successful
     AL = 00h (if locking region)          Carry flag: clear
        = 01h (if unlocking region)
     BX = Handle                         If function unsuccessful
     CX = High part of region offset       Carry flag: set
     DX = Low part of region offset        AX = Error code (01h, 06h,
     SI = High part of region length            21h, or 24h)
     DI = Low part of region length        See: \i\p\aError codes\v@errcod\v\i\p

.context @21h.5Ch.des
.freeze 3
.topic Int 21h Function 5Ch
 \i\p\aSummary\v@21h.5Ch\v\i\p                                   \i\p\aUp\v@21.rec\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function is useful for file and record synchronization in a
     multitasking environment or network. Access to the file as a whole
     is controlled by the attribute and file-sharing parameters passed
     in open or create calls, and by the file's attributes, which are
     stored in its directory entry.

     The beginning location in the file to be locked or unlocked is
     supplied as a positive double-precision integer, which is a byte
     offset into the file. The length of the region to be locked or
     unlocked is similarly supplied as a positive double-precision
     integer.

     For every call to lock a region of a file, there must be a
     subsequent unlock call with exactly the same file offset and
     length.

     Locking beyond the current end-of-file is not an error.

     If a process terminates without releasing active locks on a file,
     the result is undefined. Therefore, programs using this function
     should install their own Int 23h and Int 24h handlers so the
     processes cannot be terminated unexpectedly.

     Programs that are loaded with the EXEC call (Int 21h Function 4Bh)
     inherit the handles of their parent but not any active locks.

     Duplicate handles created with Int 21h Function 45h, or handles
     redirected to the file with Int 21h Function 46h, are allowed
     access to locked regions within the same process.
.context @21h.5Eh.00h
.freeze 3
.topic Int 21h Function 5Eh Subfunction 00h
 \i\p\aDetail\v@21h.5Eh.00h.des\v\i\p                                    \i\p\aUp\v@21h.5Eh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   5Eh     \bSubfunction:\p   00h

  \bTitle:\p       Get Machine Name [Version 3.1+]

  \bDescription:\p

     Returns the address of an ASCIIZ (null-terminated) string
     identifying the local computer. This function call is only
     available when Microsoft Networks is running.

     \bInput                      Output\p

     AH = 5Eh                   If function successful
     AL = 00h                     Carry flag: clear
     DS:DX = segment:offset       CH =  00h (if name not defined)
             of buffer to            <> 00h (if name defined)
             receive string       CL =  NetBIOS name number (if Ch <> 0)
                                  DX:DX = segment:offset of identifier
                                          (if Ch <> 0)

                                If function unsuccessful
                                  Carry flag: set
                                  AX = Error code (01h)
                                  See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.5Eh.00h.des
.freeze 3
.topic Int 21h Function 5Eh Subfunction 00h
 \i\p\aSummary\v@21h.5Eh.00h\v\i\p                                   \i\p\aUp\v@21h.5Eh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The computer identifier is a 15-byte string, padded with spaces
     and terminated with a null (00h) byte.

     The effect of this call is unpredictable if the file-sharing
     support module is not loaded.
.context @21h.5Eh.02h
.freeze 3
.topic Int 21h Function 5Eh Subfunction 02h
                                             \i\p\aUp\v@21h.5Eh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   5Eh     \bSubfunction:\p   02h

  \bTitle:\p       Set Printer Setup String [Version 3.1+]

  \bSee also:\p    \aGet Printer Setup String\v@21h.5Eh.03h\v

  \bDescription:\p

     Specifies a string to be sent in front of all files directed to a
     particular network printer, allowing users at different network
     nodes to specify individualized operating modes on the same
     printer. This function call is only available when Microsoft
     Networks is running. The redirection list index passed in register
     BX is obtained with Function 5Fh Subfunction 02h (Get Redirection
     List Entry).

     \bInput                           Output\p

     AH = 5Eh                        If function successful
     AL = 02h                          Carry flag: clear
     BX = Redirection list index
     CX = Length of setup string     If function unsuccessful
     DS:SI = segment:offset of         Carry flag: set
             setup string              AX = Error code (01h)
                                       See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.5Eh.03h
.freeze 3
.topic Int 21h Function 5Eh Subfunction 03h
                                             \i\p\aUp\v@21h.5Eh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   5Eh     \bSubfunction:\p   03h

  \bTitle:\p       Get Printer Setup String [Version 3.1+]

  \bSee also:\p    \aSet Printer Setup String\v@21h.5Eh.02h\v

  \bDescription:\p

     Obtains the printer setup string for a particular network
     printer. This function call is only available when Microsoft
     Networks is running. The redirection list index passed in
     register BX is obtained with Function 5Fh Subfunction 02h (Get
     Redirection List Entry).

     \bInput                           Output\p

     AH = 5Eh                        If function successful
     AL = 03h                          Carry flag: clear
     BX = Redirection list index       CX = Length of printer setup
     ES:DI = segment:offset of              string
             buffer to receive
             setup string            If function unsuccessful
                                       Carry flag: set
                                       AX = Error code (01h)
                                       See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.5Fh.02h
.freeze 3
.topic Int 21h Function 5Fh Subfunction 02h
 \i\p\aDetail\v@21h.5Fh.02h.des\v\i\p                                    \i\p\aUp\v@21h.5Eh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   5Fh     \bSubfunction:\p   02h

  \bTitle:\p       Get Redirection List Entry [Version 3.1+]

  \bDescription:\p

     Allows inspection of the system redirection list, which associates
     local logical names with network files, directories, or printers.
     This function call is only available when Microsoft Networks is
     running and the file-sharing module (SHARE.EXE) has been loaded.

     \bInput                             Output\p

     AH = 5Fh                          If function successful
     AL = 02h                            Carry flag: clear
     BX = Redirection list index         BH = Device status flag
     DS:SI = segment:offset of                Bit 0 = 0 (if device valid)
             16-byte buffer                         = 1 (if not valid)
             to receive local            BL = Device type
             device name                    = 03h (if printer)
     ES:DI = segment:offset of              = 04h (if drive)
             128-byte buffer to          CX = Stored parameter value
             receive network name        DX = Destroyed
                                         BP = Destroyed
                                         DS:SI = segment:offset of ASCIIZ
                                                 local device name
                                         ES:DI = segment:offset of ASCIIZ
                                                 network name

                                         If function unsuccessful
                                           Carry flag: set
                                           AX = Error code (01h or 12h)
                                           See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.5Fh.02h.des
.freeze 3
.topic Int 21h Function 5Fh Subfunction 02h
 \i\p\aSummary\v@21h.5Fh.02h\v\i\p                                   \i\p\aUp\v@21h.5Eh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The parameter returned in CX is a value that was previously passed
     to MS-DOS in register CX with Int 21h Function 5Fh Subfunction 03h
     (Redirect Device). It represents data that is private to the
     applications which store and retrieve it, and has no meaning to
     MS-DOS.
.context @21h.5Fh.03h
.freeze 3
.topic Int 21h Function 5Fh Subfunction 03h
 \i\p\aDetail\v@21h.5Fh.03h.des\v\i\p                                    \i\p\aUp\v@21h.5Eh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   5Fh     \bSubfunction:\p   03h

  \bTitle:\p       Redirect Device [Version 3.1+]

  \bDescription:\p

     Establishes redirection across the network by associating a local
     device name with a network name. This function call is available
     only when Microsoft Networks is running and the file-sharing
     module (SHARE.EXE) has been loaded.

     \bInput                                 Output\p

     AH = 5Fh                              If function successful
     AL = 03h                                Carry flag: clear
     BL = Device type
        = 03h (if printer)                 If function unsuccessful
        = 04h (if drive)                     Carry flag: set
     CX = Parameter to save for caller       AX = Error code (01h, 03h,
     DS:SI = segment:offset of ASCIIZ             05h, 08h, 0Fh, or 12h)
             local device name               See: \i\p\aError codes\v@errcod\v\i\p
     ES:DI = segment:offset of ASCIIZ
             network name, followed by
             ASCIIZ password
.context @21h.5Fh.03h.des
.freeze 3
.topic Int 21h Function 5Fh Subfunction 03h
 \i\p\aSummary\v@21h.5Fh.03h\v\i\p                                   \i\p\aUp\v@21h.5Eh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The local name can be a drive designator (a letter followed by a
     colon, such as "D:"), a printer name, or a null string. Printer
     names must be one of the following: PRN, LPT1, LPT2, or LPT3. If a
     null string followed by a password is used, MS-DOS attempts to
     grant access to the network directory with the specified password.

     The parameter passed in CX can be retrieved by later calls to Int
     21h Function 5Fh Subfunction 02h. It represents data that is
     private to the applications that store and retrieve it, and has
     no meaning to MS-DOS.
.context @21h.5Fh.04h
.freeze 3
.topic Int 21h Function 5Fh Subfunction 04h
 \i\p\aDetail\v@21h.5Fh.04h.des\v\i\p                                    \i\p\aUp\v@21h.5Eh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   5Fh     \bSubfunction:\p   04h

  \bTitle:\p       Cancel Device Redirection [Version 3.1+]

  \bDescription:\p

     Cancels a previous redirection request by removing the association
     of a local device name with a network name. This function call is
     only available when Microsoft Networks is running and the
     file-sharing module (SHARE.EXE) has been loaded.

     \bInput                       Output\p

     AH = 5Fh                    If function successful
     AL = 04h                      Carry flag: clear
     DS:SI = segment:offset
             of ASCIIZ local     If function unsuccessful
             device name           Carry flag: set
                                   AX = Error code (01h, 03h, 05h, 08h,
                                        0Fh, or 12h)
                                        See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.5Fh.04h.des
.freeze 3
.topic Int 21h Function 5Fh Subfunction 04h
 \i\p\aSummary\v@21h.5Fh.04h\v\i\p                                   \i\p\aUp\v@21h.5Eh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The supplied name can be a drive designator (a letter followed by
     a colon, such as "D:"), a printer name, or a string starting with
     two backslashes (\\\\). Printer names must be one of the
     following: PRN, LPT1, LPT2, or LPT3. If the string with two
     backslashes is used, the connection between the local machine and
     the network directory is terminated.
.context @21h.62h
.freeze 3
.topic Int 21h Function 62h
 \i\p\aDetail\v@21h.62h.des\v\i\p \i\p\aExample\v@GetPSP.asx\v\i\p                          \i\p\aUp\v@21.process\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   62h

  \bTitle:\p       Get PSP Address [Version 3.0+]

  \bSee also:\p    \aCreate New PSP\v@21h.26h\v

  \bDescription:\p

     Obtains the segment (paragraph) address of the program segment
     prefix (PSP) for the currently executing program.

     \bInput        Output\p

     AH = 62h     BX = Segment address
                       of PSP
.context @21h.62h.des
.freeze 3
.topic Int 21h Function 62h
 \i\p\aSummary\v@21h.62h\v\i\p \i\p\aExample\v@GetPSP.asx\v\i\p                         \i\p\aUp\v@21.process\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Before a program receives control from MS-DOS, its program segment
     prefix (PSP) is set up to contain certain vital information, such
     as:

        ş The segment address of the program's environment block
        ş The command line originally entered by the user
        ş The original contents of the terminate, CTRL+C, and critical-
          error handler vectors
        ş The top address of available RAM

     The segment address of the PSP is normally passed to the program
     in registers DS and ES when it initially receives control from
     MS-DOS. This function allows a program to conveniently recover the
     PSP address at any point during its execution, without having to
     save it at program entry.
.context @21h.63h
.freeze 3
.topic Int 21h Function 63h
 \i\p\aDetail\v@21h.63h.des\v\i\p                                    \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   63h

  \bTitle:\p       Get Lead Byte Table [Version 2.25 only]

  \bDescription:\p

     Obtains the address of the system table of legal lead byte ranges
     for extended character sets, or obtains or sets the interim
     console flag. Int 21h Function 63h is available only in MS-DOS
     version 2.25; it is not supported in MS-DOS versions 3.0 and
     later.

     \bInput                                 Output\p

     AH = 63h                              If function successful
     AL = Subfunction                        Carry flag: clear
        = 00h (if getting address of       And if called with AL = 00h
               system lead byte table)       DS:SI = segment:offset of
        = 01h (if setting or clearing                lead byte table
               interim console flag)       Or if called with AL = 02h
        = 02h (if obtaining value of         DL = Value of interim
               interim console flag)              console flag
     If AL = 01h
        DL = 00h (if clearing interim      If function unsuccessful
                  console flag)              Carry flag: set
           = 01h (if setting interim         AX = Error code (01h)
                  console flag)              See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.63h.des
.freeze 3
.topic Int 21h Function 63h
 \i\p\aSummary\v@21h.63h\v\i\p                                   \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The lead byte table consists of a variable number of 2-byte
     entries, terminated by 2 null (00h) bytes. Each pair defines the
     beginning and ending value for a range of lead bytes. The value of
     a legal lead byte is always in the range 80-0FFh.

     Entries in the lead byte table must be in ascending order. If no
     legal lead bytes are defined in a given system, the table consists
     only of the two null bytes.

     If the interim console flag is set, \aInt 21h Functions 07h\v@21h.01h\v
     (Unfiltered Character Input), \a08h (Character Input without Echo)\v@21h.01h\v,
     and \a0Bh (Keyboard Status)\v@21h.0Bh\v will support interim characters.

     Unlike most other MS-DOS services, this function call does not
     necessarily preserve any registers except SS:SP.

     [Version 4.0]
     The address of the DBCS lead byte table can also be obtained with
     \aInt 21h Function 65h\v@21h.65h\v.
.context @21h.65h
.freeze 3
.topic Int 21h Function 65h
 \i\p\aDetail\v@21h.65h.des\v\i\p                                    \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   65h

  \bTitle:\p       Get Extended Country Information [Version 3.3+]

  \bSee also:\p    \aGet or Set Country Information\v@21h.38h\v

  \bDescription:\p

     Obtains information about the specified country and/or code page.

     \bInput                                           Output\p

     AH = 65h                                        If function
     AL = Subfunction                                successful
          01h = Get General Internationalization       Carry flag: clear
                Information                          And requested data
          02h = Get Pointer to Uppercase Table       placed in calling
          04h = Get Pointer to Filename Uppercase    program's buffer
                Table
          06h = Get Pointer to Collating Table       If function
          07h = Get Pointer to DBCS Vector           unsuccessful
                [Version 4.0+]                         Carry flag: set
     BX = Code page of interest                        AX = Error code
          (-1 = active CON device)                          (02h)
     CX = Length of buffer to receive information      See: \i\p\aError codes\v@errcod\v\i\p
     DX = Country ID (-1 = default)
     ES:DI = Address of buffer to
             receive information
.context @21h.65h.des
.freeze 3
.topic Int 21h Function 65h
 \i\p\aSummary\v@21h.65h\v\i\p                                   \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The information returned by this function is a superset of the
     information returned by Int 21h Function 38h.

     This function may fail if either the country code or the code page
     number is invalid or if the code page does not match the country
     code.

     The function fails if the specified buffer length is less than
     five bytes. If the buffer to receive the information is at least
     five bytes long but is too short for the requested information,
     the data is truncated and no error is returned.

     The format of the data returned by Subfunction 01h is:

     \bBytes       Contents\p

     00h         Information ID code (1)
     01h-02h     Length of following buffer
     03h-04h     Country ID
     05h-06h     Code page number
     07h-08h     Date format
                 0 = USA    (m d y)
                 1 = Europe (d m y)
                 2 = Japan  (y m d)
     09h-0Dh     ASCIIZ currency symbol
     0Eh-0Fh     ASCIIZ thousands separator
     10h-11h     ASCIIZ decimal separator
     12h-13h     ASCIIZ date separator
     14h-15h     ASCIIZ time separator
     16h         Currency format flags
                 Bit 0 = 0 (if currency symbol precedes value)
                       = 1 (if currency symbol follows value)
                 Bit 1 = 0 (if no space between value and
                            currency symbol)
                       = 1 (if one space between value and
                            currency symbol)
                 Bit 2 = 0 (if currency symbol and decimal
                            are separate)
                       = 1 (if currency symbol replaces
                            decimal separator)
     17h         Number of digits after decimal in
                 currency
     18h         Time format
                 Bit 0 = 0 (if 12-hour clock)
                       = 1 (if 24-hour clock)
     19h-1Ch     Case-map routine call address
     1Dh-1Eh     ASCIIZ data list separator
     1Fh-28h     Reserved

     The format of the data returned by Subfunctions 02h, 04h, 06h, and
     07h is:

     Bytes       Contents

     00h         Information ID code (2, 4, 6, or 7)
     01h-04h     Double-word pointer to table

     The uppercase and filename uppercase tables are a maximum of 130
     bytes long. The first two bytes contain the size of the table; the
     following bytes contain the uppercase equivalents, if any, for
     character codes 80h-FFh. The main use of these tables is to map
     accented or otherwise modified vowels to their plain vowel
     equivalents. Text translated with the help of this table can be
     sent to devices that do not support the IBM graphics character
     set, or used to create filenames that do not require a special
     keyboard configuration for entry.

     The collating table is a maximum of 258 bytes long. The first two
     bytes contain the table length, and the subsequent bytes contain
     the values to be used for the corresponding character codes
     (0-FFh) during a sort operation. This table maps uppercase and
     lowercase ASCII characters to the same collating codes so that
     sorts will be case insensitive, and it maps accented vowels to
     their plain vowel equivalents.

     [Version 4.0+]
     Subfunction 07h returns a pointer to a variable-length table that
     defines ranges for double-byte character set (DBCS) lead bytes.
     The table is terminated by a pair of zero bytes, unless it must be
     truncated to fit in the buffer, and has the following format:

       WORD   length
       BYTE   start1, end1
       BYTE   start2, end2
       .
       .
       .
       BYTE   0, 0

       For example:

       WORD   4
       BYTE   81h, 9fh
       BYTE   0e0h, 0fch
       BYTE   0, 0

     In some cases a truncated translation table may be presented to
     the program by MS-DOS. Applications should always check the length
     at the beginning of the table to ensure that it contains a
     translation code for the particular character of interest.
.context @21h.66h
.freeze 3
.topic Int 21h Function 66h
 \i\p\aDetail\v@21h.66h.des\v\i\p                                    \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   66h

  \bTitle:\p       Get or Set Code Page [Version 3.3+]

  \bDescription:\p

     Obtains or selects the current code page.

     \bInput                           Output\p

     AH = 66h                        If function successful
     AL = Subfunction                  Carry flag: clear
          01h = Get Code Page        And if called with AL = 01h
          02h = Select Code Page       BX = Active code page
     BX = Code page to select          DX = Default code page
          if AL = 02h
                                     If function unsuccessful
                                       Carry flag: set
                                       AX = Error code (02h or 65h)
                                       See: \i\p\aError codes\v@errcod\v\i\p
.context @21h.66h.des
.freeze 3
.topic Int 21h Function 66h
 \i\p\aSummary\v@21h.66h\v\i\p                                   \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     When the Select Code Page subfunction is used, MS-DOS gets the new
     code page from the COUNTRY.SYS file. The device must be previously
     prepared for code page switching with the appropriate DEVICE=
     directive in the CONFIG.SYS file and NLSFUNC and MODE CP PREPARE
     commands (usually placed in the AUTOEXEC.BAT file).
.context @21h.67h
.freeze 3
.topic Int 21h Function 67h
 \i\p\aDetail\v@21h.67h.des\v\i\p                                    \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   67h

  \bTitle:\p       Set Handle Count [Version 3.3+]

  \bDescription:\p

     Sets the maximum number of files and devices that may be opened
     simultaneously using handles by the current process.

     \bInput                              Output\p

     AH = 67h                           If function successful
     BX = Number of desired handles       Carry flag: clear

                                        If function unsuccessful
                                          Carry flag: set
                                          AX = Error code
.context @21h.67h.des
.freeze 3
.topic Int 21h Function 67h
 \i\p\aSummary\v@21h.67h\v\i\p                                   \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function call controls the size of the table that relates
     handle numbers for the current process to MS-DOS's internal
     global table for all of the open files and devices in the system.
     The default table is located in the reserved area of the process
     PSP and is large enough for 20 handles.

     The function fails if the requested number of handles is greater
     than 20 and there is not sufficient free memory in the system to
     allocate a new block to hold the enlarged table.

     If the number of handles requested is larger than the available
     entries in the system's global table for file and device handles
     (controlled by the FILES entry in CONFIG.SYS), no error is
     returned. However, a subsequent attempt to open a file or device,
     or to create a new file, will fail if all of the entries in the
     system's global file table are in use, even if the requesting
     process has not used up all of its own handles.
.context @21h.68h
.freeze 3
.topic Int 21h Function 68h
 \i\p\aDetail\v@21h.68h.des\v\i\p                                    \i\p\aUp\v@21.rec\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   68h

  \bTitle:\p       Commit File [Version 3.3+]

  \bSee also:\p    \aDisk Reset\v@21h.0Dh\v

  \bDescription:\p

     Forces all data in MS-DOS's internal buffers associated with a
     specified handle to be physically written to the device. If the
     handle refers to a file, and the file has been modified, the time
     and date stamp and file size in the file's directory entry are
     updated.

     \bInput           Output\p

     AH = 68h        If function successful
     BX = Handle       Carry flag: clear

                     If function unsuccessful
                       Carry flag: set
                       AX = Error code
.context @21h.68h.des
.freeze 3
.topic Int 21h Function 68h
 \i\p\aSummary\v@21h.68h\v\i\p                                   \i\p\aUp\v@21.rec\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The effect of this function is equivalent to closing and reopening
     a file, or to duplicating a handle for the file with Int 21h
     Function 45h and then closing the duplicate. However, this
     function has the advantage that it will not fail due to lack of
     handles, and the application does not risk losing control of the
     file in multitasking or network environments.

     If this function is requested for a handle associated with a
     character device, a success flag is returned but there is no other
     effect.
.context @21h.6Ch
.freeze 3
.topic Int 21h Function 6Ch
 \i\p\aDetail\v@21h.6Ch.des\v\i\p                                    \i\p\aUp\v@21.file\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   6Ch

  \bTitle:\p       Extended Open File [Version 4.0+]

  \bSee also:\p    \aOpen File\v@21h.3Dh\v

  \bDescription:\p

     Given an ASCIIZ path name, opens, creates, or replaces a file in
     the designated or default directory on the designated or default
     disk drive. Returns a handle that can be used by the program for
     subsequent access to the file.

     \bInput                            Output\p

     AH = 6Ch                           If function successful
     AL = 00h                             Carry flag: clear
     BX = Open mode                       AX = Handle
                                          CX = Action taken
          Bits   Significance                  1 = File existed and
                                                   was opened
          0-2    Access type                   2 = File did not exist
                 000 = read-only                   and was created
                 001 = write-only
                 010 = read/write       If function unsuccessful
          3      Reserved (0)           Carry flag: set
                                        AX = Error code
          Bits  Significance (if set)

          4-6   Sharing mode
                000 = compatibility
                001 = deny read/write
                      (deny all)
                010 = deny write
                011 = deny read
                100 = deny none
          7     Inheritance
                0 = child process
                    inherits handle
                1 = child does not
                    inherit handle
          8-12  Reserved (0)
          13    Critical error
                handling
                0 = execute Int 24h
                1 = return error
                    to process
          14    Write-through
                0 = writes may be
                    buffered and
                    deferred
                1 = physical write at
                    request time
          15    Reserved (0)

     CX = File attribute (bits may be
          combined; ignored if open)

          \bBits   Significance (if set)\p

          0      Read-only
          1      Hidden
          2      System
          3      Volume label
          4      Reserved (0)
          5      Archive
          6-15   Reserved (0)

     DX = Open flag

          \bBits   Significance\p

          0-3    Action if file exists
                 0000 = fail
                 0001 = open file
                 0010 = replace file
          4-7    Action if file
                 doesn't exist
                 0000 = fail
                 0001 = create file
          8-15   Reserved (0)

     DS:SI = segment:offset of ASCIIZ
             path name
.context @21h.6Ch.des
.freeze 3
.topic Int 21h Function 6Ch
 \i\p\aSummary\v@21h.6Ch\v\i\p                                   \i\p\aUp\v@contents\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The function fails if

        ş Any element of the path name does not exist.
        ş The file is being created in the root directory and the root
          directory is full.
        ş The file is being created and a file with the same name and
          the read-only attribute already exists in the specified
          directory.
        ş The program is running on a network and the user running the
          program has insufficient access rights.

     A file is usually given a normal (0) attribute when it is created.

     The file's attribute can subsequently be modified with Int 21h
     Function 43h. This function combines the capabilities of Int 21h
     Functions 3Ch, 3Dh, and 5Bh. It was added to MS-DOS for
     compatibility with the DosOpen function of OS/2.
.context @21h.5D0Ah
.freeze 3
.topic Set Extended Error Information Interrupt
 \i\p\aDetail\v@21h.5D0Ah.des\v\i\p                                     \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   21h     \bFunction:\p   5D0Ah

  \bTitle:\p       Set Extended Error Information [Version 3.1+]

  \bSee also:\p    \aGet Extended Error Information\v@21h.59h\v

  \bDescription:\p

     Restores extended error information to a prior state. Function 59h
     must be called first to initialize 11-word data structure with
     error information. Function 5D0Ah restores error data from the
     structure.

     \bInput                            Output\p

     AX = 5D0Ah                       None
     DS:DX = segment:offsetof
             structure
.context @21h.5D0Ah.des
.freeze 3
.topic Set Extended Error Information Interrupt
 \i\p\aSummary\v@21h.5D0Ah\v\i\p                                   \i\p\aUp\v@21.sysfun\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Functions 59h and 5D0Ah enable a process such as a TSR to freely
     use DOS services that may overwrite existing error information
     belonging to another process. The TSR stores existing error data,
     makes calls to DOS, then restores the original error data before
     terminating. This ensures the interrupted process retrieves its
     own error information if it subsequently calls Function 59h.

     The following defines the extended error structure:

       EXTEND_ERR   STRUCT
         rAx        WORD    ?               ; AX
         rBx        WORD    ?               ; BX
         rCx        WORD    ?               ; CX
         rDx        WORD    ?               ; DX
         rSi        WORD    ?               ; SI
         rDi        WORD    ?               ; DI
         rDs        WORD    ?               ; DS
         rEs        WORD    ?               ; ES
         Pad        WORD    3 DUP(0)
       EXTEND_ERR   ENDS
.context @22h
.context 22h
.context 022h
.context 34
.freeze 3
.topic Interrupt 22h
                                             \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   22h

  \bTitle:\p       Terminate Handler Address

  \bSee also:\p    \aProgram Segment Prefix Chart\v@SegmentPrefix\v

  \bDescription:\p

     The machine interrupt vector for Int 22h (memory locations
     0000:0088h through 0000:008Bh) contains the address of the routine
     that receives control when the currently executing program
     terminates via Int 20h, Int 27h, or Int 21h Functions 00h, 31h, or
     4Ch. The address in this vector is also copied into offsets 0Ah
     through 0Dh of the program segment prefix (PSP) when a program is
     loaded but before it begins executing, and is restored from the
     PSP (in case it was modified by the application) as part of
     MS-DOS's termination handling.

     This interrupt should never be issued directly.
.context @23h
.context 23h
.context 023h
.context 35
.freeze 3
.topic Interrupt 23h
 \i\p\aDetail\v@23h.des\v\i\p \i\p\aExample\v@NewCtrlC.asx\v\i\p                          \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   23h

  \bTitle:\p       CTRL+C Handler Address

  \bSee also:\p    \aProgram Segment Prefix\v@SegmentPrefix\v, \aCTRL+Break Handler\v@1Bh\v

  \bDescription:\p

     The machine interrupt vector for Int 23h (memory locations
     0000:008Ch through 0000:008Fh) contains the address of the routine
     which receives control when a CTRL+C is detected during any
     character I/O function and, if the Break flag is ON, during most
     other MS-DOS function calls. The address in this vector is also
     copied into locations 0Eh through 11h of the program segment
     prefix (PSP) when a program is loaded but before it begins
     executing, and is restored from the PSP (in case it was modified
     by the application) as part of MS-DOS's termination handling.

     This interrupt should never be issued directly.
.context @23h.des
.freeze 3
.topic Int 23h
 \i\p\aSummary\v@23h\v\i\p \i\p\aExample\v@NewCtrlC.asx\v\i\p                         \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The initialization code for an application can use Int 21h
     Function 25h to reset the Interrupt 23h vector to point to its own
     routine for CTRL+C handling. In this way, the program can avoid
     being terminated unexpectedly as the result of the user's entry of
     CTRL+C or CTRL+Break.

     When CTRL+C is detected and the program's Int 23h handler
     receives control, all registers are set to their values at the
     point of the original function call. The handler can then do any
     of the following:

        ş Set a local flag for later inspection by the application, or
          take any other appropriate action, and perform an IRET. All
          registers must be preserved. The MS-DOS function in progress
          will be restarted from scratch and will proceed to
          completion, control finally returning to the application in
          the normal manner.
        ş Take appropriate action and then perform a RET FAR to give
          control back to MS-DOS. The state of the carry flag is used
          by MS-DOS to determine what action to take. If the carry flag
          is set, the application will be terminated; if the carry flag
          is clear, the application will continue in the normal manner.
        ş Retain control by transferring to an error-handling routine
          within the application and then resume execution or take
          other appropriate action, never performing a RET FAR or an
          IRET to end the interrupt-handling sequence. This option will
          cause no harm to the system.

     Any MS-DOS function call may be used within the body of an Int 23h
     handler.
.context @24h
.context 24h
.context 024h
.context 36
.freeze 3
.topic Interrupt 24h
 \i\p\aDetail\v@24h.des\v\i\p \i\p\aExample\v@NewCritE.asx\v\i\p                          \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   24h

  \bTitle:\p       Critical-Error Handler Address

  \bSee also:\p    \aProgram Segment Prefix\v@SegmentPrefix\v, \aCTRL+C Handler\v@22h\v

  \bDescription:\p

     The machine interrupt vector for Int 24h (memory locations
     0000:0090h through 0000:0093h) contains the address of the routine
     that receives control when a critical error (usually a hardware
     error) is detected. This address is also copied into locations 12h
     through 15h of the program segment prefix (PSP) when a program is
     loaded but before it begins executing, and is restored from the
     PSP (in case it was modified by the application) as part of
     MS-DOS's termination handling.

     When a disk I/O error occurs, MS-DOS automatically retries the
     operation before issuing a critical-error Int 24h. The number of
     retries varies in different versions of MS-DOS but is typically in
     the range three to five.

     On entry to the critical-error interrupt handler, bit 7 of
     register AH is clear (0) if the error was a disk I/O error;
     otherwise, it is set (1). BP:SI contains the address of a
     device-driver header from which additional information can be
     obtained. Interrupts are disabled. The registers will be set up
     for a retry operation, and an error code will be in the lower half
     of the DI register, with the upper half undefined.

     If the Int 24h handler returns control directly to the application
     program rather than to MS-DOS, it must restore the program's
     registers, removing all but the last three words from the stack,
     and issue an IRET. Control returns to the instruction immediately
     following the function call that caused the error. This option
     leaves MS-DOS in an unstable state until a call to an Int 21h
     function higher than Function 0Ch is made.

     COMMAND.COM provides the default critical-error handler,
     which displays a message about the error and, after displaying a
     question such as ABORT, RETRY, FAIL, or IGNORE?, prompts
     the user for a response.

     This interrupt should never be issued directly.
.context @24h.des
.freeze 3
.topic Interrupt 24h
 \i\p\aSummary\v@24h\v\i\p \i\p\aExample\v@NewCritE.asx\v\i\p                         \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Before issuing Int 24h, MS-DOS does the following:
     Sets the AX, DI, BP, and SI registers with information about the
     error (location of the error, error value, type of device, and type
     of operation, respectively)

     Sets the program's stack to be the current stack. Upon entry, the
     stack is set up as follows:

     ÚÄÄÄÄÄÄÄÄÄ¿
     ³  Flags  ³ ¿
     ÃÄÄÄÄÄÄÄÄÄ´ ³
     ³   CS    ³ ÃÄÄFlags and CS:IP pushed on stack
     ÃÄÄÄÄÄÄÄÄÄ´ ³  by original Int 21h call
     ³   IP    ³ Ù
     ÃÄÄÄÄÄÄÄÄÄ´
     ³   ES    ³ ¿
     ÃÄÄÄÄÄÄÄÄÄ´ ³
     ³   DS    ³ ³
     ÃÄÄÄÄÄÄÄÄÄ´ ³
     ³   BP    ³ ³
     ÃÄÄÄÄÄÄÄÄÄ´ ³
     ³   DI    ³ ³
     ÃÄÄÄÄÄÄÄÄÄ´ ³
     ³   SI    ³ ÃÄÄRegisters at point of
     ÃÄÄÄÄÄÄÄÄÄ´ ³  original Int 21h call
     ³   DX    ³ ³
     ÃÄÄÄÄÄÄÄÄÄ´ ³
     ³   CX    ³ ³
     ÃÄÄÄÄÄÄÄÄÄ´ ³
     ³   BX    ³ ³
     ÃÄÄÄÄÄÄÄÄÄ´ ³
     ³   AX    ³ Ù
     ÃÄÄÄÄÄÄÄÄÄ´
     ³  Flags  ³ ¿
     ÃÄÄÄÄÄÄÄÄÄ´ ³
     ³   CS    ³ ÃÄÄReturn address for Int 24h handler
     ÃÄÄÄÄÄÄÄÄÄ´ ³
     ³   IP    ³ Ù
     ÀÄÄÄÄÄÄÄÄÄÙ  SS:SP on entry to Int 24h handler


     Sets internal system variables, such as InDOS and ErrorMode
     (also called Critical Error Flag). InDOS is set to zero to permit
     the handler to call system functions. ErrorMode is set to 1 to
     prevent the system from issuing Int 24h again before the handler
     returns. (MS-DOS issues only one Int 24h at a time)

     MS-DOS passes information about the error to the handler by using
     the following registers:

AH     Specifies information about when and where the error occurred,
       as well as how the critical-error handler can respond to the error.
       The bits in this register can have the following values:

     0    Specifies the operation that caused the error. If this bit is 0,
          the error occurred during a read. Otherwise, the error occurred
          during a write.

     1,2  Specifiy the location of the error, but only if the error occurred
          on a block device. These bits can have the following values:

          00 = error in reserved (MS-DOS area) sector

          01 = error in FAT
          10 = error in directory
          11 = error in data area

     3    Specifies whether the handler can terminate the
          function. If 1, it can. Otherwise, it must not.

     4    Specifies whether the handler can retry the function.
          If 1, it can. Otherwise, it must not.

     5    Specifies whether the handler can ignore the error. If 1, it
          can. Otherwise, it must not.

     6    Reserved

     7    Specifies the type of device on which the error occurred.

          If 0, the error was a block device.

          If 1, character device or memory image of the FAT; the handler
          must check bit 15 in the dhAttributes field (offset 04h) of the
          DEVICEHEADER structure to determine the exact location. If
          bit 15 is set, the error occurred on a character device. Otherwise,
          in the memory image of the FAT.

AL     Specifies the drive number (0=A, 1=B, 2=C, etc) if the error
         occurred on a block device. Not used for errors that
         occur on character devices.

DI     Specifies the error value, in the lower byte can be:

     Byte   Description

     00h    Write-protect error
     01h    Unknown unit
     02h    Drive not ready
     03h    Unknown command
     04h    Data error (CRC)
     05h    Bad request structure length
     06h    Seek error
     07h    Unknown media type
     08h    Sector not found
     09h    Printer out of paper
     0Ah    Write fault
     0Bh    Read fault
     0Ch    General failure
     0Dh    Reserved
     0Eh    Reserved
     0Fh    Invalid disk change (MS-DOS 3.0 and later)

     Note that these are the same error codes returned by the device
     driver in the request header. The upper byte of DI is undefined.

BP:SI     Points to the DEVICEHEADER structure that contains
              information about the device on which the error occurred.
             The structure has the following form:
                     
      DEVICEHEADER STRUC
          dhLink          dd ?       ; link to next driver
          dhAttributes     dw ?       ; device attribute
          dhStrategy       dw ?       ; strat-routine offset
          dhInterrupt      dw ?       ; intrpt-routine offset
          dhNameOrUnits    db '????????'
          ; dhNameOrUnits = logical-device name (char device only)
          ;                 or number of units (block device only)
      DEVICEHEADER ENDS

          The handler must not change the contents of the
          DEVICEHEADER structure.

     Int 24h handlers must preserve the SS, SP, DS, ES, BX, CX, and DX
     registers and restore the preserved values before returning to the
     system.

     The critical-error handler must determine what action to take in res-
     ponse to the error. For example, the default handler displays informa-
     tion about the error and prompts the user for input on how to proceed.

     The Int 24h handler can call the following 21h functions:

          01h through 0Ch, 3300h, 3301h, 3305h, 3306h, 50h, 51h,
          62h, and 59h.

     Other function calls will destroy the MS-DOS stack and its
     ability to retry or ignore an error.

     The Int 24h handler returns to the system using the IRET instruction.
     When the Int 24h handler issues an IRET, it should return an
     action code in AL that will be interpreted by DOS as follows:

     Code   Description

     0      Ignore the error
     1      Retry the operation
     2      Terminate the program
     3      [Version 3.0+] Fail the function call in progress
.context @25h
.context 25h
.context 025h
.context 37
.freeze 3
.topic Interrupt 25h
 \i\p\aDetail\v@25h.des\v\i\p                                    \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   25h

  \bTitle:\p       Absolute Disk Read

  \bDescription:\p

     Provides a direct linkage to the MS-DOS BIOS module to read data
     from a logical disk sector into memory.

     \bInput                                   Output\p

     For access to partitions                If function successful
     <= 32 megabytes                           Carry flag: clear
       AL = Drive number
            (0 = A, 1 = B,...)               If function unsuccessful
       CX = Number of sectors to read          Carry flag: set
       DX = Starting sector number             AX = Error code
       DS:BX = segment:offset of buffer        See: \i\p\aDetail\v@25h.des\v\i\p

     For access to partitions
     > 32 megabytes [Version 4.0+]
       AL = Drive number
            (0 = A, 1 = B,...)
       CX = -1
       DS:BX = segment:offset of
               parameter block
.context @25h.des
.freeze 3
.topic Interrupt 25h
 \i\p\aSummary\v@25h\v\i\p                                   \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     All registers except the segment registers may be destroyed.

     When this function returns, the CPU flags originally pushed on the
     stack by the Int 25h instruction are still on the stack. The stack
     must be cleared by a POPF or ADD SP,2 to prevent uncontrolled
     stack growth and to make accessible any other values that were
     pushed on the stack before the call to Int 25h.

     Logical sector numbers are obtained by numbering each disk sector
     sequentially from track 0, head 0, sector 1, and continuing until
     the last sector on the disk is counted. The head number is
     incremented before the track number. Logically adjacent sectors
     may not be physically adjacent due to interleaving that occurs at
     the device-driver level for some disk types.

     The error code is interpreted as follows: The lower byte (AL) is
     the same error code that is returned in the lower byte of DI when
     an Int 24h is issued. The upper byte (AH) contains:

     \bError     Description\p

     80h       If attachment failed to respond
     40h       If seek operation failed
     20h       If controller failed
     10h       Data error (bad CRC)
     08h       If direct memory access (DMA) failed
     04h       If requested sector not found
     02h       If bad address mark
     01h       If bad command

     [Version 4.0+]
     When accessing partitions larger than 32 megabytes under MS-DOS
     version 4.0, this function uses a parameter block with the
     following format:

     \bBytes       Description\p

     00h-03h     32-bit sector number
     04h-05h     Number of sectors to read
     06h-07h     Offset of buffer
     08h-09h     Segment of buffer
.context @26h
.context 26h
.context 026h
.context 38
.freeze 3
.topic Interrupt 26h
 \i\p\aDetail\v@26h.des\v\i\p                                    \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   26h

  \bTitle:\p       Absolute Disk Write

  \bDescription:\p

     Provides a direct linkage to the MS-DOS BIOS module to write data
     from memory to a logical disk sector.

     \bInput                                  Output\p

     For access to partitions               If function successful
     <= 32 megabytes                          Carry flag: clear
       AL = Drive number
            (0 = A, 1 = B,...)              If function unsuccessful
       CX = Number of sectors to write        Carry flag: set
       DX = Starting sector number            AX = Error code
       DS:BX = segment:offset of buffer       See: \i\p\aDetail\v@26h.des\v\i\p

     For access to partitions
     > 32 megabytes [Version 4.0+]
       AL = Drive number
            (0 = A, 1 = B,...)
       CX = -1
       DS:BX = segment:offset of
               parameter block
.context @26h.des
.freeze 3
.topic Interrupt 26h
 \i\p\aSummary\v@26h\v\i\p                                   \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     All registers except the segment registers may be destroyed.

     When this function returns, the CPU flags originally pushed onto
     the stack by the Int 26h instruction are still on the stack. The
     stack must be cleared by a POPF or ADD SP,2 to prevent
     uncontrolled stack growth and to make accessible any other values
     that were pushed on the stack before the call to Int 26h.

     Logical sector numbers are obtained by numbering each disk sector
     sequentially from track 0, head 0, sector 1, and continuing until
     the last sector on the disk is counted. The head number is
     incremented before the track number. Logically adjacent sectors
     may not be physically adjacent, due to interleaving that occurs at
     the device-driver level for some disk types.

     The error code is interpreted as follows: The lower byte (AL) is
     the same error code that is returned in the lower byte of DI when
     an Int 24h is issued. The upper byte (AH) contains:

     \bError     Description\p

     80h       If attachment failed to respond
     40h       If seek operation failed
     20h       If controller failed
     10h       If data error (bad CRC)
     08h       If direct memory access (DMA) failed
     04h       If requested sector not found
     03h       If write-protect fault
     02h       If bad address mark
     01h       If bad command

     [Version 4.0+]
     When accessing partitions larger than 32 megabytes under MS-DOS
     version 4.0, this function uses a parameter block with the
     following format:

     \bBytes       Description\p

     00h-03h     32-bit sector number
     04h-05h     Number of sectors to read
     06h-07h     Offset of buffer
     08h-09h     Segment of buffer
.context @27h
.context 27h
.context 027h
.context 39
.freeze 3
.topic Interrupt 27h
 \i\p\aDetail\v@27h.des\v\i\p                                    \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   27h

  \bTitle:\p       Terminate and Stay Resident

  \bSee also:\p    \aTerminate and Stay Resident (DOS)\v@21h.31h\v

  \bDescription:\p

     Terminates execution of the currently executing program, but
     reserves part or all of its memory so that it will not be overlaid
     by the next transient program to be loaded.

     \bInput                                        Output\p

     DX = Offset of the last byte plus one        None
          (relative to the program segment
          prefix) of program to be protected
     CS = Segment of program segment prefix
.context @27h.des
.freeze 3
.topic Interrupt 27h
 \i\p\aSummary\v@27h\v\i\p                                   \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
     This function performs the following actions:

        ş File buffers are flushed and any open handles for files or
          devices owned by the process are closed.

        ş The termination handler vector (Int 22h) is restored from
          PSP:000Ah.

        ş The CTRL+C handler vector (Int 23h) is restored from
          PSP:000Eh.

        ş The critical-error handler vector (Int 24h) is restored from
          PSP:0012h.

        ş Control is transferred to the termination handler.

     If the program is returning to COMMAND.COM, control transfers to
     the resident portion and the transient portion is reloaded if
     necessary. If a batch file is in progress, the next line of the
     file is fetched and interpreted; otherwise a prompt is issued for
     the next user command.

     This function call is typically used to allow user-written
     utilities, drivers, or interrupt handlers to be loaded as ordinary
     .COM or .EXE programs, and then remain resident. Subsequent
     entrance to the code is via a hardware or software interrupt.

     This function attempts to set the initial memory allocation block
     to the length in bytes specified in register DX. If other memory
     blocks have been requested by the application via Int 21h Function
     48h, they will not be released by this function.

     Other methods of performing a final exit are \aInt 20h\v@20h\v,
     \aInt 21h Function 00h\v@21h.00h\v, \aInt 21h Function 31h\v@21h.31h\v, and \aInt 21h\v@21h.4Ch\v
     \aFunction 4Ch\v@21h.4Ch\v.

     This function should not be called by .EXE programs that are
     loaded at the high end of the transient program area (linked with
     the /HIGH switch) because doing so reserves the memory that is
     normally used by the transient part of COMMAND.COM. If COMMAND.COM
     cannot be reloaded, the system will fail.

     This function does not work correctly when DX contains values in
     the range 0FFF1h-0FFFFh. In this case, MS-DOS discards the high
     bit of the value in DX, resulting in the reservation of 32K less
     memory than was requested by the program.

     Int 21h Function 31h should be used instead of this function
     because it supports return codes, allows larger amounts of memory
     to be reserved, and does not require CS to contain the segment of
     the program segment prefix.

     [Version 3.0+]
     If the program is running on a network, it should remove all locks
     it has placed on file regions before terminating.
.context @28h
.context 28h
.context 028h
.context 40
.freeze 3
.topic DOS Idle Interrupt
 \i\p\aDetail\v@28h.des\v\i\p \i\p\aExample\v@StrInput.asx\v\i\p                           \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   28h

  \bTitle:\p       DOS Idle Interrupt

  \bSee also:\p    \aTerminate and Stay Resident\v@21h.31h\v

  \bDescription:\p

     Signals that DOS is in an idle state and may be interrupted provided
     the following functions are not called:

     01h-0Ch  [All versions]
     50h-51h  [Version 2.0+]
     59h      [Version 3.0+]

     Serviced by DOS with an interrupt return (IRET). To gain control
     when DOS is idle, a program must set up a handler routine for
     Int 28h.

     \bInput     Output\p

     None      None
.context @28h.des
.freeze 3
.topic DOS Idle Interrupt
\i\p\aSummary\v@28h.des\v\i\p \i\p\aExample\v@StrInput.asx\v\i\p                           \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Int 28h allows TSRs that call DOS to safely interrupt
     certain DOS functions. These functions set up a stack that the
     TSR must preserve by not calling any of the functions listed on
     the Summary screen. However, the TSR may call other DOS services.
.context @2Fh
.context 2Fh
.context 02Fh
.context 47
..index Int 2Fh functions
.freeze 3
.topic Multiplex Interrupt
 \i\p\aDetail\v@2Fh.des\v\i\p                                     \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   2Fh

  \bTitle:\p       Multiplex Interrupt

  \bSee also:\p    \aTerminate and Stay Resident\v@21h.31h\v

  \bDescription:\p

     Allows multiple resident processes to communicate with other
     processes through a single interrupt. A caller initiates
     communication by invoking Int 2Fh with a unique identity number in
     AH. Each resident process receives the call through its Int 2Fh
     handler. A handler that does not recognize its identity number
     passes control to the previous handler until control reaches the
     intended recipient.

     \bFunction\p     \bDescription\p

     \a01h          Print Spooler\v@2Fh.01h\v
     \a06h          Resident ASSIGN command\v@2Fh.06h\v
     \a10h          Resident SHARE command\v@2Fh.10h\v
     \aB7h          Resident APPEND command\v@2Fh.B7h\v

     Input                                Output

     AH = Identity number                 AL = 0FFh if input AL = 0
     AL = Function number                 Otherwise, depends on handler
.context @2Fh.des
.freeze 3
.topic Multiplex Interrupt
 \i\p\aSummary\v@2Fh\v\i\p                                   \i\p\aUp\v@21.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Through an Int 2Fh multiplex handler, a TSR can communicate its
     location in memory to a calling program. This allows the calling
     program to

        ş Verify the TSR's presence in memory
        ş Read or write resident data
        ş Deinstall the TSR from memory

     DOS version 2.0 does not provide a Multiplex Interrupt except when
     the print spooler PRINT is resident. A program that sets up a
     multiplex handler under version 2.0 must first inspect the Int 2Fh
     vector. If the vector is null, the handler must terminate with an
     IRET to avoid passing control to a nonexistent routine.
     Furthermore, if PRINT is used under version 2.0, it must be
     installed before all other programs that chain to Int 2Fh.
.context @2Fh.01h
.freeze 3
.topic Int 2Fh Function 01h
 \i\p\aDetail\v@2Fh.01h.des\v\i\p                                    \i\p\aUp\v@2Fh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   2Fh     \bFunction:\p   01h

  \bTitle:\p       Print Spooler [Version 3.0+]

  \bDescription:\p

     Submits a file to the print spooler, removes a file from the print
     spooler's queue of pending files, or obtains the status of the
     printer. The print spooler, which is contained in the file
     PRINT.COM, was first added to MS-DOS in version 2.0, but the
     application program interface to the spooler was not documented
     until MS-DOS version 3.0.

     \bInput                                     Output\p

     AH = 01h                                  If function successful
     AL = Subfunction                            Carry flag: clear
          00h = Get Installed State            And if called with
          01h = Submit File to be Printed      AL = 00h
          02h = Remove File from Print Queue     AL = Print spooler state
          03h = Cancel All Files in Queue           = 00h (if not installed,
          04h = Hold Print Jobs for Status                 OK to install)
                Read                                = 01h (if not installed,
          05h = Release Hold                               not OK to install)
     DS:DX = segment:offset of packet               = FFh (if installed)
             (Subfunction 01h)                 Or if called with AL = 04h
           = segment:offset of ASCIIZ            DX = Error count
             path name (Subfunction 02h)         DS:SI = segment:offset of
                                                         print queue file
                                                         list

                                                 If function unsuccessful
                                                   Carry flag: set
                                                   AX = Error code (01h,
                                                        02h, 03h, 04h,
                                                        05h, 08h, 09h,
                                                        0Ch, or 0Fh)
                                                   See: \i\p\aError codes\v@errcod\v\i\p
.context @2Fh.01h.des
.freeze 3
.topic Int 2Fh Function 01h
 \i\p\aSummary\v@2Fh.01h\v\i\p                                   \i\p\aUp\v@2Fh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The packet passed to Subfunction 01h consists of five bytes. The
     first byte contains the level, which should be 00h for MS-DOS
     versions 2.0 and 3.0. The following four bytes contain the
     segment:offset of an ASCIIZ path name, which may not include
     wildcard characters. If the specified file exists, it is added to
     the print queue.

     The * and ? wildcard characters may be included in a path name
     passed to Subfunction 02h, making it possible to delete multiple
     files from the print queue with one call.

     The address returned by Subfunction 04h points to a list of
     64-byte entries, each containing an ASCIIZ path name. The first
     pathname in the list is the file currently being printed. The last
     entry in the list is a null string (a single 00h byte).
.context @2Fh.06h
.freeze 3
.topic Int 2Fh Function 06h
 \i\p\aExample\v@VeriAnsi.asx\v\i\p                                   \i\p\aUp\v@2Fh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   2Fh     \bFunction:\p   06h

  \bTitle:\p       ASSIGN [Version 3.0+]

  \bDescription:\p

     Returns a code indicating whether the resident portion of the
     ASSIGN utility has been loaded.

     \bInput                        Output\p

     AH = 06h                     If function successful
     AL = Subfunction               Carry flag: clear
          00h = Get Installed       AL = ASSIGN installed status
                State                  = 00h (if not installed, OK to
                                              install)
                                       = 01h (if not installed, not OK
                                              to install)
                                       = FFh (if installed)

                                  If function unsuccessful
                                    Carry flag: set
                                    AX = Error code
.context @2Fh.10h
.freeze 3
.topic Int 2Fh Function 10h
                                             \i\p\aUp\v@2Fh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   2Fh     \bFunction:\p   10h

  \bTitle:\p       SHARE [Version 3.0+]

  \bDescription:\p

     Returns a code indicating whether the SHARE.EXE file-sharing
     module has been loaded.

     \bInput                      Output\p

     AH = 10h                   If function successful
     AL = Subfunction             Carry flag: clear
          00h = Get Installed     AL = SHARE installation status
                State                = 00h (if not installed, OK to
                                            install)
                                     = 01h (if not installed, not OK to
                                            install)
                                     = FFh (if installed)

                                If function unsuccessful
                                  Carry flag: set
                                  AX = Error code
.context @2Fh.B7h
.freeze 3
.topic Int 2Fh Function B7h
 \i\p\aDetail\v@2Fh.B7h.des\v\i\p                                     \i\p\aUp\v@2Fh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   2Fh     \bFunction:\p   B7h

  \bTitle:\p       APPEND [Version 3.0+]

  \bDescription:\p

     Allows an application to test whether APPEND has been installed.
     If APPEND is resident, returns the APPEND version, state, and the
     path used to search for data files.

     \bInput                                   Output\p

     AH = B7h                                If function successful
     AL = Subfunction                          Carry flag: clear
          00h = Get Installed State          And if called with AL = 00h
          02h = Get Append Version             AL = APPEND installed status
                [Version 4.0+]                    = 00h (if not installed,
          04h = Get Append Path Pointer                  OK to install)
                [Version 4.0+]                    = 01h (if not installed,
          06h = Get Append Function                      not OK to install)
                State [Version 4.0+]              = FFh (if installed)
          07h = Set Append Function          Or if called with AL=02h
                State [Version 4.0+]         [Version 4.0+]
          11h = Set Return Found Name          AX = FFFFh if MS-DOS 4.0
                State [Version 4.0+]           APPEND
                                             Or if called with AL = 04h
     BX = APPEND state (if AL = 07h)         [Version 4.0+]
                                               ES:DI = segment:offset of
          \bBits   Significance (if set)\p             active APPEND path
                                             Or if called with AL=06h
          0        APPEND enabled            [Version 4.0+]
          1-12     Reserved (0)                BX = APPEND state (see above)
          13       /PATH switch active
          14       /E switch active          If function unsuccessful
          15       /X switch active            AX = Error code
.context @2Fh.B7h.des
.freeze 3
.topic Int 2Fh Function B7h
 \i\p\aSummary\v@2Fh.B7h\v\i\p                                   \i\p\aUp\v@2Fh\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If the Return Found Name State is set with Subfunction 11h, the
     fully qualified filename is returned to the next application to
     call Int 21h Function 3Dh, 43h, or 6Ch. The name is placed at the
     same address as the ASCIIZ parameter string for the Int 21h
     function, so the application must be sure to provide a buffer of
     adequate size. The Return Found Name State is reset after APPEND
     processes one Int 21h function call.
