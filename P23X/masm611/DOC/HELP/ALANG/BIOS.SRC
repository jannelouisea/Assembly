.context @BIOSCalls
..index BIOS interrupts, BIOS Function Calls
..index interrupts,, BIOS, BIOS Function Calls
.freeze 3
.topic BIOS Interrupts
                                             \i\p\aUp\v@contents\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  ÚÄÄBIOS InterruptsÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ¿
  ³                                     ³
  ³ \i\p\a10h-Video Services\v@10h\v\i\p                ³
  ³ \i\p\a13h-Direct Disk Services\v@13h\v\i\p          ³
  ³ \i\p\a14h-Serial Port Services\v@14h\v\i\p          ³
  ³ \i\p\a15h-Miscellaneous System Services\v@15h\v\i\p ³
  ³ \i\p\a16h-Keyboard Services\v@16h\v\i\p             ³
  ³ \i\p\a17h-Parallel Port Services\v@17h\v\i\p        ³
  ³ \i\p\a1Ah-Clock Services\v@1Ah\v\i\p                ³
  ³ \i\p\aDirect System Services\v@bios.misc\v\i\p            ³
  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÙ
.context @bios.misc
..index system services interrupts, Direct System Services
..index interrupts,, system services, Direct System Services Interrupts
.freeze 3
.topic Direct System Services Interrupts
                                             \i\p\aUp\v@BIOSCalls\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bTitle:\p       Direct System Services Interrupts

  \bInterrupt\p     \bName\p

  \a00h           Divide by Zero Error\v@0h\v
  \a01h           Single Step\v@1h\v
  \a02h           Nonmaskable Interrupt (NMI)\v@2h\v
  \a03h           Breakpoint\v@3h\v
  \a04h           Arithmetic Overflow Error\v@4h\v
  \a05h           Print Screen and BOUND Range Exceeded\v@5h\v
  \a06h           Illegal Instruction Error\v@6h\v
  \a07h           Processor Extension Not Available\v@7h\v
  \a08h           Timer Tick\v@8h\v
  \a09h           Keyboard I/O\v@9h\v
  \a0Bh           Secondary Communications Port (COM2:)\v@Bh\v
  \a0Ch           Primary Communications Port (COM1:)\v@Ch\v
  \a0Eh           Disk Drive I/O\v@Eh\v
  \a11h           Get Equipment Configuration\v@11h\v
  \a12h           Get Conventional Memory Size\v@12h\v
  \a18h           ROM BASIC\v@18h\v
  \a19h           Reboot System\v@19h\v
  \a1Bh           CTRL+BREAK Handler\v@1Bh\v
  \a1Ch           User Timer Service\v@1Ch\v
  \a1Dh           Pointer to Video Parameter Table\v@1Dh\v
  \a1Eh           Pointer to Disk Drive Parameter Table\v@1Eh\v
  \a1Fh           Pointer to Graphics Character Pattern Table\v@1Fh\v
.context @0h
.context 0h
.context 00h
.context 0
..index Int 00h, Divide by Zero Error
.freeze 3
.topic Int 00h
                                             \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   00h

  \bTitle:\p       Divide by Zero Error

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Invoked by the processor when an instruction divides by zero or
     produces a result that does not fit into the destination operand
     (divide overflow).

     This interrupt should not be called directly. Default service is
     interrupt return (IRET). To trap divide-by-zero errors, a program
     must set up a handler routine to gain control when the interrupt
     occurs.

     \bInput\p     \bOutput\p

     None      None
.context @1h
.context 1h
.context 01h
.context 1
..index Int 01h, Single Step
.freeze 3
.topic Int 01h
 \i\p\aDetail\v@1h.des\v\i\p                                    \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   01h

  \bTitle:\p       Single Step

  \bDescription:\p                                          [PC] [AT] [PS/2]

     When trap flag is set, the processor invokes Int 01h after
     executing each instruction.

     This interrupt should not be called directly. Default service is
     interrupt return (IRET). To trap Int 01h calls, a program must set
     up a handler routine to gain control when the interrupt occurs.

     \bInput\p     \bOutput\p

     None      None
.context @1h.des
.freeze 3
.topic Single Step Interrupt
 \i\p\aSummary\v@1h\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Debugger programs set the trap flag (also called the "trace
     flag"), then trap calls to Int 01h with an interrupt handler. By
     gaining control after each executed instruction, the debugger can
     single-step through an executing program.
.context @2h
.context 2h
.context 02h
.context 2
..index Int 02h, Nonmaskable Interrupt (NMI)
.freeze 3
.topic Int 02h
                                             \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   02h

  \bTitle:\p       Nonmaskable Interrupt (NMI)

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Invoked when the system detects a memory parity error. Int 02h is
     nonmaskable because it can occur regardless of the value of the
     interrupt enable flag.

     This interrupt should not be called directly.

     \bInput\p     \bOutput\p

     None      Displays "PARITY CHECK" message
.context @3h
.context 3h
.context 03h
.context 3
..index Int 03h, Breakpoint
.freeze 3
.topic Int 03h
 \i\p\aDetail\v@3h.des\v\i\p                                    \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   03h

  \bTitle:\p       Breakpoint

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Invoked when the processor executes machine instructions CCh
     (byte) or CDh 03h (word).

     This interrupt should not be called directly. Default service is
     interrupt return (IRET). To trap Int 03h calls, a program must set
     up a handler routine to gain control when the interrupt occurs.

     \bInput\p     \bOutput\p

     None      None
.context @3h.des
.freeze 3
.topic Breakpoint Interrupt
 \i\p\aSummary\v@3h\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The single-byte instruction CCh enables a debugger to establish a
     breakpoint in an executing program. The debugger writes CCh to the
     first byte of the instruction at the desired breakpoint, then
     allows the program to run. By trapping the call to Int 03h
     triggered when the processor executes the breakpoint instruction,
     the debugger recovers control from the executing program.
.context @4h
.context 4h
.context 04h
.context 4
..index Int 04h, Arithmetic Overflow Error
.freeze 3
.topic Int 04h
                                             \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   04h

  \bTitle:\p       Arithmetic Overflow Error

  \bSee also:\p    INTO

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Invoked when the processor executes the INTO instruction
     (Interrupt on Overflow) when the overflow flag is set. If the
     overflow flag is clear, this instruction has no effect.

     This interrupt should not be called directly. Default service is
     interrupt return (IRET). To trap overflow errors, a program must
     set up a handler routine to gain control when the interrupt
     occurs.

     \bInput     Output\p

     None      None

.context @5h
.context 5h
.context 05h
.context 5
..index Int 05h, Print Screen and BOUND Overflow
.freeze 3
.topic Int 05h
 \i\p\aDetail\v@5h.des\v\i\p                                    \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   05h

  \bTitle:\p       (1)  Print Screen
               (2)  BOUND Range Exceeded

  \bSee also:\p    BOUND, \aSelect Alternate PrintScreen\v@10h.12h.20h\v,
                          \aPrint Screen Status Byte\v@MiscMem\v

  \bDescription:\p                                   [PC] [AT] [PS/2] [186+]

     1. Copies current screen to printer. BIOS keyboard routine
        (Int 09h) calls Int 05h when it detects SHIFT+PRINT SCREEN
        combination or PRINT SCREEN key.

     2. Invoked by the 80x86 processor when conditions of BOUND
        instruction are not met. This interrupt should not be called
        directly. To trap BOUND errors, a program must set up a handler
        routine to gain control when the interrupt occurs.

     \bInput\p       \bOutput\p

     1. None     1. Printed copy of screen text
     2. None     2. None

.context @5h.des
.freeze 3
.topic Print Screen and BOUND Overflow Interrupt
 \i\p\aSummary\v@5h\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     A handler for Int 05h can distinguish between BOUND errors and
     print screen requests with the following steps:

       1. Read the return address from the stack.
       2. Examine the two bytes immediately preceding the instruction
          at the return address.
       3. If the two bytes equal CDh 05h (Int 05h instruction), the
          call is a request for PRINT SCREEN. In this case, the handler
          should pass control to the BIOS routine to service the
          interrupt.
.context @6h
.context 6h
.context 06h
.context 6
..index Int 06h, Illegal Instruction Error
.freeze 3
.topic Int 06h
                                             \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   06h

  \bTitle:\p       Illegal Instruction Error

  \bDescription:\p                                                    [186+]

     Invoked when the 80x86 processor attempts to

        ş Decode a bit pattern not recognized as a valid instruction
        ş Execute an instruction with invalid operands
        ş Execute a protected-mode instruction in real mode

     This interrupt should not be called directly. Default service is
     interrupt return (IRET). To trap invalid opcode errors, a program
     must set up a handler routine to gain control when the interrupt
     occurs.

     \bInput\p     \bOutput\p

     None      None
.context @7h
.context 7h
.context 07h
.context 7
..index Int 07h, Unavailable Processor Extension
.freeze 3
.topic Int 07h
 \i\p\aDetail\v@7h.des\v\i\p                                    \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   07h

  \bTitle:\p       Processor Extension Not Available

  \bDescription:\p                                                    [186+]

     Invoked when the 80x86 processor encounters a coprocessor
     instruction while EM (Emulate Math) bit is set in Control Register
     0. This indicates that the coprocessor is not present.

     This interrupt should not be called directly. Default service is
     interrupt return (IRET). To trap Int 07h calls, a program must set
     up a handler routine to gain control when the interrupt occurs.

     \bInput\p     \bOutput\p

     None      None
.context @7h.des
.freeze 3
.topic Unavailable Processor Extension Interrupt
 \i\p\aSummary\v@7h\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Int 07h is also invoked when the MP (Math Present) bit is set in
     Control Register 0 and the processor executes a WAIT or
     floating-point instruction after switching tasks.

     This interrupt allows the programmer to use floating-point
     instructions in an application without having to code tests for
     the presence of a coprocessor. If a coprocessor is present at
     run time, it receives instructions normally since the EM bit is
     clear. Otherwise, each floating-point instruction triggers Int
     07h, giving control to the application's interrupt handler. The
     handler can then emulate the instruction.
.context @8h
.context 8h
.context 08h
.context 8
..index Int 08h, Timer Tick
.freeze 3
.topic Int 08h
 \i\p\aDetail\v@8h.des\v\i\p                                    \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   08h

  \bTitle:\p       Timer Tick

  \bSee also:\p    \aUser Timer Service\v@1Ch\v, \aDiskette Data\v@DiskData\v
                   \aMemory\v@DiskData\v, \aTimer Data Memory\v@TimerData\v

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Invoked when timer chip decrements an internal counter to zero.
     Normally, this occurs an average of 18.2065 times per second.

     This interrupt should not be called directly. To trap Int 08h
     calls, a program must set up a handler routine to gain control
     when the interrupt occurs.

     \bInput\p     \bOutput\p

     None      None
.context @8h.des
.freeze 3
.topic Timer Tick Interrupt
 \i\p\aSummary\v@8h\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The rate at which Int 08h occurs can be adjusted by reprogramming
     the timer chip. A program that adjusts the timer tick rate must
     also include an Int 08h handler that passes control to the BIOS
     service routine only 18.2065 times each second. The handler must
     service all other ticks itself.

     For example, if a program increases the timer rate by four, its
     handler must pass control to BIOS every fourth timer tick. This
     ensures that various BIOS tasksÄÄsuch as maintenance of the tick
     accumulator and diskette motor shutoff counterÄÄare carried out at
     the normal rate.

     Int 08h is often used by TSR programs, which trap the interrupt
     with a handler to gain periodic control. A TSR should not adjust
     the timer rate as described above, since its handler cannot be
     assured of receiving control before other handlers.
.context @9h
.context 9h
.context 09h
.context 9
..index Int 09h, Keyboard
.freeze 3
.topic Int 09h
 \i\p\aDetail\v@9h.des\v\i\p                                    \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   09h

  \bTitle:\p       Keyboard I/O

  \bSee also:\p    \aKeyboard Interrupts\v@16h\v, \aKey Scan Chart\v@KeyChart101\v,
               \aExtended Key Codes\v@XKeyChart\v, \aKeyboard Data Memory\v@Keydata\v

  \bDescription:\p                                            [PC] [AT] [PS/2]

     Invoked when a key is pressed or released while the interrupt
     enable flag is set. BIOS routine reads the key scan code sent from
     the keyboard and places in the circular keyboard buffer a word
     containing the key's scan and ASCII codes. Applications request
     keyboard input through DOS or BIOS services that read the next
     scan/ASCII word pair from the buffer.

     This interrupt should not be called directly. To trap Int 09h
     calls, a program must set up a handler routine to gain control
     when the interrupt occurs.

     \bInput\p     \bOutput\p

     None      None
.context @9h.des
.freeze 3
.topic Keyboard Interrupt
 \i\p\aSummary\v@9h\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The BIOS Int 09h routine maintains the shift status word at memory
     address 0:417h. Bits of this word indicate status of shift keys
     such as SHIFT, ALT, CTRL, and CAPS LOCK. The routine also

        ş Invokes Int 05h if it detects a SHIFT+PRINT SCREEN
          combination or PRINT SCREEN key
        ş Invokes Int 1Bh if it detects a CTRL+BREAK combination
        ş Beeps the speaker if the keyboard buffer is full
.context @Bh
.context Bh
.context 0Bh
.context 11
..index Int 0Bh, Secondary Communications Port
.freeze 3
.topic Int 0Bh
 \i\p\aDetail\v@Bh.des\v\i\p                                    \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   0Bh

  \bTitle:\p       Secondary Communications Port (COM2:)

  \bSee also:\p    \aPrimary Communications Port\v@Ch\v, \aCOM Port Interrupt\v@14h\v

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Invoked when pulse is detected on hardware interrupt line IRQ3
     (Interrupt Request 3), signalling data received at COM2 serial
     port.

     This interrupt should not be called directly. Default service is
     interrupt return (IRET). To trap Int 0Bh calls, a program must set
     up a handler routine to gain control when the interrupt occurs.

     \bInput\p     \bOutput\p

     None      None
.context @Bh.des
.freeze 3
.topic Secondary Communications Interrupt
 \i\p\aSummary\v@Bh\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
     IRQ3 remains inactive until bit 3 is cleared in interrupt
     controller's mask register.

     To access data from the COM2 port directly, a program must set up
     a handler routine to read the port when the interrupt occurs. It
     must also program the Universal Asynchronous Receiver/Transmitter
     (UART).
.context @Ch
.context Ch
.context 0Ch
.context 13
..index Int 0Ch, Primary Communications Port
.freeze 3
.topic Int 0Ch
 \i\p\aDetail\v@Ch.des\v\i\p                                    \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   0Ch

  \bTitle:\p       Primary Communications Port (COM1:)

  \bSee also:\p    \aSecondary Communications Port\v@Bh\v, \aCOM Port Interrupt\v@14h\v

  \bDescription:\p                                            [PC] [AT] [PS/2]

     Invoked when pulse is detected on hardware interrupt line IRQ4
     (Interrupt Request 4), signalling data received at COM1 serial
     port.

     This interrupt should not be called directly. Default service is
     interrupt return (IRET). To trap Int 0Ch calls, a program must set
     up a handler routine to gain control when the interrupt occurs.

     \bInput\p     \bOutput\p

     None      None
.context @Ch.des
.freeze 3
.topic Secondary Communications Interrupt
 \i\p\aSummary\v@Ch\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     IRQ4 remains inactive until bit 4 is cleared in the interrupt
     controller's mask register.

     To access data from the COM1 port directly, a program must set up
     a handler routine to read the port when the interrupt occurs. It
     must also program the Universal Asynchronous Receiver/Transmitter
     (UART).
.context @Eh
.context Eh
.context 0Eh
.context 14
..index Int 0Eh, Disk Drive I/O
.freeze 3
.topic Int 0Eh
                                             \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   0Eh

  \bTitle:\p       Disk Drive I/O

  \bSee also:\p    \aDisk I/O Interrupts\v@13h\v

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Invoked by diskette drive controller when it completes a task. Not
     invoked by the hard disk or other disk controllers.

     This interrupt should not be called directly. To trap Int 0Eh
     calls, a program must set up a handler routine to gain control
     when the interrupt occurs.

     \bInput\p     \bOutput\p

     None      None
.context @10h
.context 10h
.context 010h
.context 16
..index video interrupts, Int 10h
..index Int 10h functions, Video Interrupts
.freeze 3
.topic Int 10h
                                             \i\p\aUp\v@BIOSCalls\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h

  \bTitle:\p       Video Interrupts

  \bSee also:\p    \aVideo Data Memory\v@VideoData\v

  \bFunction(s)\p  \bName\p

  \a00h          Set Video Mode\v@10h.00h\v
  \a01h          Set Cursor Type\v@10h.01h\v
  \a02h          Set Cursor Position\v@10h.02h\v
  \a03h          Get Cursor Information\v@10h.03h\v
  \a04h          Get Light Pen Position\v@10h.04h\v
  \a05h          Set Display Page\v@10h.05h\v
  \a06h, 07h     Initialize or Scroll Window\v@10h.06h\v
  \a08h          Read Character and Attribute at Cursor\v@10h.08h\v
  \a09h          Write Character and Attribute at Cursor\v@10h.09h\v
  \a0Ah          Write Character at Cursor\v@10h.0Ah\v
  \a0Bh          Set Palette, Background, or Border\v@10h.0Bh\v
  \a0Ch          Write Graphics Pixel\v@10h.0Ch\v
  \a0Dh          Read Graphics Pixel\v@10h.0Dh\v
  \a0Eh          Write Character in Teletype Mode\v@10h.0Eh\v
  \a0Fh          Get Video Mode\v@10h.0Fh\v
  \a10h          Color\v@10h.10h\v
  \a11h          Fonts\v@10h.11h\v
  \a12h          Video Configuration\v@10h.12h\v
  \a13h          Write String in Teletype Mode\v@10h.13h\v
  \a1Ah          Get or Set Display Combination Code\v@10h.1Ah\v
  \a1Bh          Get Functionality/State Information\v@10h.1Bh\v
  \a1Ch          Save or Restore Video State\v@10h.1Ch\v
.context @10h.00h
.freeze 3
.topic Int 10h, Function 00h
 \i\p\aDetail\v@10h.00h.des\v\i\p \i\p\aExample\v@GetVidCo.asx\v\i\p                          \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   00h

  \bTitle:\p       Set Video Mode

  \bSee also:\p    \aGet Video Mode\v@10h.0Fh\v, @SetMode

  \bDescription:\p                     [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Selects the current video display mode. Also selects the active
     video controller if more than one is present.

     \bInput\p                \bOutput\p

     AH = 00h             None
     AL = Video mode
.context @10h.00h.des
.freeze 3
.topic Int 10h Function 00h
 \i\p\aSummary\v@10h.00h\v\i\p \i\p\aExample\v@GetVidCo.asx\v\i\p                         \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The video modes applicable to the various machine models and
     video adapters are as follows:

     \bMode\p     \bResolution\p         \bColors\p     \bDisplay\p

     00h      40-by-25
              color burst off     16        Text
     01h      40-by-25            16        Text
     02h      80-by-25            ÄÄ        ÄÄ
              color burst off     16        Text
     03h      80-by-25            16        Text
     04h      320-by-200           4        Graphics
     05h      320-by-200
              color burst off      4        Graphics
     06h      640-by-200           2        Graphics
     07h      80-by-25             2*       Text
     08h      160-by-200          16        Graphics
     09h      320-by-200          16        Graphics
     0Ah      640-by-200           4        Graphics
     0Bh      Reserved
     0Ch      Reserved
     0Dh      320-by-200          16        Graphics
     0Eh      640-by-200          16        Graphics
     0Fh      640-by-350           2*       Graphics
     10h      640-by-350           4œ       Graphics
     10h      640-by-350          16       Graphics
     11h      640-by-480           2        Graphics
     12h      640-by-480          16        Graphics
     13h      320-by-200         256        Graphics

     *   Monochrome monitor only.
     œ   EGA with 64K of RAM.
        EGA with 128K or more of RAM.

     The presence or absence of color burst is only significant when a
     composite monitor is being used. For RGB monitors, there is no
     functional difference between modes 00h and 01h or modes 02h and
     03h. On the CGA, two palettes are available in mode 04h and one in
     mode 05h.

     On the PC/AT, PCjr, and PS/2, if bit 7 of AL is set, the display
     buffer is not cleared when a new mode is selected. On the PC or PC/XT,
     this capability is available only when an EGA (which has its own ROM
     BIOS) is installed.
.context @10h.01h
.freeze 3
.topic Int 10h Function 01h
 \i\p\aDetail\v@10h.01h.des\v\i\p \i\p\aExample\v@SetCurSi.asx\v\i\p                          \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   01h

  \bTitle:\p       Set Cursor Type

  \bSee also:\p    \aGet Cursor Information\v@10h.03h\v, \aSet Cursor Position\v@10h.02h\v,
               \aEnable/Disable Cursor Emulation\v@10h.12h.34h\v, @SetCsrSize

  \bDescription:\p                     [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Selects the starting and ending lines for the blinking hardware
     cursor in text display modes.

     \bInput\p                                      \bOutput\p

     AH = 01h                                   None
     CH Bits 0-4 = Starting line for cursor
     CL Bits 0-4 = Ending line for cursor


.context @10h.01h.des
.freeze 3
.topic Int 10h Function 01h
 \i\p\aSummary\v@10h.01h\v\i\p \i\p\aExample\v@SetCurSi.asx\v\i\p                         \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     In text display modes, the video hardware causes the cursor to
     blink, and the blink cannot be disabled. In graphics modes, the
     hardware cursor is not available.

     The default values set by the ROM BIOS are:

     \bDisplay\p                 \bStart\p         \bEnd\p

     Monochrome mode 07h     11            12
     Text modes 00h-03h       6             7

     In text modes 00h-03h on the EGA, MCGA, and VGA, the ROM BIOS
     accepts cursor start and end values as though the character cell
     were 8-by-8, and remaps the values as appropriate for the true
     character cell dimensions. This mapping is called cursor
     emulation.

     You can turn off the cursor in several ways. On the MDA, CGA, and
     VGA, setting register CH = 20h causes the cursor to disappear.
     Techniques that involve setting illegal starting and ending lines
     for the current display mode tend to be unreliable. An alternative
     method is to position the cursor to a nondisplayable address, such
     as (x, y)=(0, 25).
.context @10h.02h
.freeze 3
.topic Int 10h Function 02h
 \i\p\aDetail\v@10h.02h.des\v\i\p \i\p\aExample\v@SetCurPo.asx\v\i\p                          \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   02h

  \bTitle:\p       Set Cursor Position

  \bSee also:\p    \aGet Cursor Information\v@10h.03h\v, \aSet Cursor Type\v@10h.01h\v, @SetCsrPos

  \bDescription:\p                     [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Positions the cursor on the display, using text coordinates.

     \bInput\p                          \bOutput\p

     AH = 02h                       None
     BH = Page
     DH = Row (y coordinate)
     DL = Column (x coordinate)
.context @10h.02h.des
.freeze 3
.topic Int 10h Function 02h
 \i\p\aSummary\v@10h.02h\v\i\p \i\p\aExample\v@SetCurPo.asx\v\i\p                         \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     A separate cursor is maintained for each display page, and each
     can be set independently with this function regardless of the
     currently active page. The number of available display pages
     depends on the video adapter and current display mode.
     See Int 10h Function 05h:

     Text coordinates (x, y)=(0, 0) are the upper left corner of the
     screen.

     The maximum value for each text coordinate depends on the video
     adapter and current display mode, as follows:

     \bMode\p     \bMaximum x\p     \bMaximum y\p

     00h      39            24
     01h      39            24
     02h      79            24
     03h      79            24
     04h      39            24
     05h      39            24
     06h      79            24
     07h      79            24
     08h      19            24
     09h      39            24
     0Ah      79            24
     0Bh      Reserved      Reserved
     0Ch      Reserved      Reserved
     0Dh      39            24
     0Eh      79            24
     0Fh      79            24
     10h      79            24
     11h      79            29
     12h      79            29
     13h      39            24
.context @10h.03h
.freeze 3
.topic Int 10h Function 03h
 \i\p\aDetail\v@10h.03h.des\v\i\p \i\p\aExample\v@GetCurPo.asx\v\i\p                          \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   03h

  \bTitle:\p       Get Cursor Information

  \bSee also:\p    \aSet Cursor Position\v@10h.03h\v, \aSet Cursor Type\v@10h.01h\v, @GetCsr

  \bDescription:\p                     [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Obtains the current position of the cursor on the display, in text
     coordinates.

     \bInput\p         \bOutput\p

     AH = 03h      CH = Starting line for cursor
     BH = Page     CL = Ending line for cursor
                   DH = Row (y coordinate)
                   DL = Column (x coordinate)
.context @10h.03h.des
.freeze 3
.topic Int 10h Function 03h
 \i\p\aSummary\v@10h.03h\v\i\p \i\p\aExample\v@GetCurPo.asx\v\i\p                         \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     A separate cursor is maintained for each display page, and each
     can be inspected independently with this function regardless of
     the currently active page. The number of available display pages
     depends on the video adapter and current display mode.
.context @10h.04h
.freeze 3
.topic Int 10h Function 04h
 \i\p\aDetail\v@10h.04h.des\v\i\p                                    \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   04h

  \bTitle:\p       Get Light Pen Position

  \bDescription:\p                                        [CGA] [PCjr] [EGA]

     Obtains the current status and position of the light pen.

     \bInput\p        \bOutput\p

     AH = 04h     AH = 00h (if light pen not down/not triggered)
                     = 01h (if light pen down/triggered)
                  BX = Pixel column (graphics x coordinate)
                  CH = Pixel row
                       (graphics y coordinate, modes 04h-06h)
                  CX = Pixel row
                       (graphics y coordinate, modes 0Dh-10h)
                  DH = Character row (text y coordinate)
                  DL = Character column (text x coordinate)
.context @10h.04h.des
.freeze 3
.topic Int 10h Function 04h
 \i\p\aSummary\v@10h.04h\v\i\p                                   \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The range of text and graphics coordinates returned by this
     function depends on the current display mode.

     On the CGA, the graphics coordinates returned are not continuous.
     The y coordinate is always a multiple of two; the x coordinate is
     either a multiple of four (for 320-by-200 graphics modes) or a
     multiple of eight (for 640-by-200 graphics modes).

     Careful selection of background and foreground colors is necessary
     to obtain maximum sensitivity from the light pen across the full
     screen width.
.context @10h.05h
.freeze 3
.topic Int 10h Function 05h
 \i\p\aDetail\v@10h.05h.des\v\i\p                                    \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   05h

  \bTitle:\p       Set Display Page

  \bSee also:\p    \aGet Video Mode\v@10h.0Fh\v, @SetPage

  \bDescription:\p                           [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Selects the active display page for the video display.

     \bInput                                       Output\p

     For CGA, EGA, MCGA, VGA                     If CGA, EGA, MCGA, or
       AH = 05h                                  VGA adapter:
       AL = Page                                   None
            0-7 for modes 00h and 01h (CGA,
                EGA, MCGA, VGA)                  If PCjr and if
            0-3 for modes 02h and 03h (CGA)      function called with
            0-7 for modes 02h and 03h (EGA,      AL = 80h-83h
                MCGA, VGA)                         BH = CRT page register
            0-7 for mode 07h (EGA, VGA)            BL = CPU page register
            0-7 for mode 0Dh (EGA, VGA)
            0-3 for mode 0Eh (EGA, VGA)
            0-1 for mode 0Fh (EGA, VGA)
            0-1 or mode 10h (EGA, VGA)

     For PCjr only
       AH = 05h
       AL = Subfunction
            80h = Read CRT/CPU page registers
            81h = Set CPU page register
            82h = Set CRT page register
            83h = Set both CPU and CRT page
                  registers
       BH = CRT Page (Subfunctions 82h and 83h)
       BL = CPU Page (Subfunctions 81h and 83h)
.context @10h.05h.des
.freeze 3
.topic Int 10h Function 05h
 \i\p\aSummary\v@10h.05h\v\i\p                                   \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Video mode and adapter combinations not listed above support one
     display page (for example, a Monochrome Display Adapter (MDA) in
     mode 7).

     Switching between pages does not affect their contents. In
     addition, text can be written to any video page with Int 10h
     Functions 02h, 09h, and 0Ah, regardless of the page currently
     being displayed.

     On the PCjr, the CPU page determines the part of the physical
     memory region 00000h-1FFFFh that will be hardware mapped onto 16K
     of memory beginning at segment B800h. The CRT page determines the
     starting address of the physical memory used by the video
     controller to refresh the display. Smooth animation effects can be
     achieved by manipulation of these registers.

     Programs that write directly to the B800h segment can reach only
     the first 16K of the video-refresh buffer. Programs requiring
     direct access to the entire 32K buffer in modes 09h and 0Ah can
     obtain the current CRT page from the ROM BIOS variable PAGDAT at
     0040:008Ah.
.context @10h.06h
.freeze 3
.topic Int 10h Functions 06h and 07h
 \i\p\aDetail\v@10h.06h.des\v\i\p \i\p\aExample\v@ClearBox.asx\v\i\p                          \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunctions:\p  06h and 07h

  \bTitle:\p       Initialize or Scroll Window

  \bSee also:\p    @Scroll, @Cls

  \bDescription:\p                     [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Initializes a specified window of the display to ASCII blank
     characters with a given attribute, or scrolls the contents of
     a window by a specified number of lines.

     \bInput\p                               \bOutput\p

     AH = 06h to scroll up               None
        = 07h to scroll down
     AL = Number of lines to scroll
          (if zero, entire window is
          blanked)
     BH = Attribute to be used for
          blanked area
     CH = y coordinate, upper left
          corner of window
     CL = x coordinate, upper left
          corner of window
     DH = y coordinate, lower right
          corner of window
     DL = x coordinate, lower right
          corner of window
.context @10h.06h.des
.freeze 3
.topic Int 10h Functions 06h and 07h
 \i\p\aSummary\v@10h.06h\v\i\p \i\p\aExample\v@ClearBox.asx\v\i\p                         \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     In video modes that support multiple pages, these functions affect
     only the page currently being displayed.

     If AL contains a value other than 00h, the area within the
     specified window is scrolled by the requested number of lines.
     Text that is scrolled beyond the top or bottom of the window is
     lost. The new lines that appear at the bottom of the window are
     filled with ASCII blanks carrying the attribute specified by
     register BH.
.context @10h.08h
.context @10h.08h.des
.freeze 3
.topic Int 10h Function 08h
 \i\p\aExample\v@ReadChar.asx\v\i\p                                   \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   08h

  \bTitle:\p       Read Character and Attribute at Cursor

  \bSee also:\p    \aWrite Character and Attribute at Cursor\v@10h.09h\v,
               @GetCharAtr

  \bDescription:\p                     [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Obtains the ASCII character and its attribute at the current
     cursor position for the specified display page. In video modes
     that support multiple pages, characters and their attributes can
     be read from any page, regardless of the page currently being
     displayed.

     \bInput\p         \bOutput\p

     AH = 08h      AH = Attribute
     BH = Page     AL = Character
.context @10h.09h
.freeze 3
.topic Int 10h Function 09h
 \i\p\aDetail\v@10h.09h.des\v\i\p                                    \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   09h

  \bTitle:\p       Write Character and Attribute at Cursor

  \bSee also:\p    \aColor and Attributes\v@ColorAttr\v, \aWrite Character at Cursor\v@10h.0Ah\v,
               \aRead Character and Attribute at Cursor\v@10h.08h\v, @PutCharAtr,
               \aFont Interrupts\v@10h.11h\v

  \bDescription:\p                     [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Writes an ASCII character and its attribute to the display at the
     current cursor position.

     \bInput\p                                    \bOutput\p

     AH = 09h                                 None
     AL = Character
     BH = Page
     BL = Attribute (text modes) or color
          (graphics modes)
     CX = Count of characters to write
          (replication factor)
.context @10h.09h.des
.freeze 3
.topic Int 10h Function 09h
 \i\p\aSummary\v@10h.09h\v\i\p                                   \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     In graphics modes, the replication factor in CX produces a valid
     result only for the current row. If more characters are written
     than there are remaining columns in the current row, the result is
     unpredictable.

     All values of AL result in some sort of display; control
     characters, including bell, backspace, carriage return, and line
     feed, are not recognized as special characters and do not affect
     the cursor position.

     After a character is written, the cursor must be moved explicitly
     with Int 10h Function 02h to the next position.

     To write a character without changing the attribute at the current
     cursor position, use Int 10h Function 0Ah.

     If this function is used to write characters in graphics mode and
     bit 7 of BL is set, the character will be exclusive-OR'd (XOR)
     with the current display contents. This feature can be used to
     write characters and then erase them.

     For the CGA and PCjr in graphics modes 04h-06h, the bit patterns
     for character codes 80h-FFh are obtained from a table whose
     address is stored in the vector for Int 1Fh. On the PCjr, the
     address of the table for character codes 00-7Fh is stored in the
     vector for Int 44h. Alternative character sets can be installed by
     loading them into memory and updating this vector.

     For the EGA, MCGA, and VGA in graphics modes, the address of the
     character definition table is stored in the vector for Int 43h.
.context @10h.0Ah
.freeze 3
.topic Int 10h Function 0Ah
 \i\p\aDetail\v@10h.0Ah.des\v\i\p                                    \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   0Ah

  \bTitle:\p       Write Character at Cursor

  \bSee also:\p    \aWrite Character and Attribute at Cursor\v@10h.09h\v, \aCharacter Output\v@21h.02h\v,
               @PutChar, \aFont Interrupts\v@10h.11h\v

  \bDescription:\p                     [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Writes an ASCII character to the display at the current cursor
     position. The character receives the attribute of the previous
     character displayed at the same position.

     \bInput\p                                      \bOutput\p

     AH = 0Ah                                   None
     AL = Character
     BH = Page
     BL = Color (graphics modes, PCjr only)
     CX = Count of characters to write
          (replication factor)
.context @10h.0Ah.des
.freeze 3
.topic Int 10h Function 0Ah
 \i\p\aSummary\v@10h.0Ah\v\i\p                                   \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     In graphics modes, the replication factor in CX produces a valid
     result only for the current row. If more characters are written
     than there are remaining columns in the current row, the result is
     unpredictable.

     All values of AL result in some sort of display; control
     characters, including bell, backspace, carriage return, and line
     feed, are not recognized as special characters and do not affect
     the cursor position.

     After a character is written, the cursor must be moved explicitly
     with Int 10h Function 02h to the next position.

     To write a character and attribute at the current cursor position,
     use Int 10h Function 09h.

     If this function is used to write characters in graphics mode and
     bit 7 of BL is set, the character will be exclusive-OR'd (XOR)
     with the current display contents. This feature can be used to
     write characters and then erase them.

     For the CGA and PCjr in graphics modes 04h-06h, the bit patterns
     for character codes 80h-FFh are obtained from a table whose
     address is stored in the vector for Int 1Fh. On the PCjr, the
     address of the table for character codes 00-7Fh is stored in the
     vector for Int 44h. Alternative character sets can be installed by
     loading them into memory and updating this vector.

     For the EGA, MCGA, and VGA in graphics modes, the address of the
     character definition table is stored in the vector for Int 43h.
.context @10h.0Bh
.freeze 3
.topic Int 10h Function 0Bh
 \i\p\aDetail\v@10h.0Bh.des\v\i\p                                    \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   0Bh

  \bTitle:\p       Set Palette, Background, or Border

  \bSee also:\p    \aColor Summary\v@10h.10h\v, @SetColor, @SetPalette

  \bDescription:\p                           [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Selects a palette, background, or border color.

     \bInput                                                  Output\p

     To set the background color and border color for       None
     graphics modes or the border color for text modes
       AH = 0Bh
       BH = 00h
       BL = Color

     To select the palette (320-by-200 4-color
     graphics modes)
       AH = 0Bh
       BH = 01h
       BL = Palette
.context @10h.0Bh.des
.freeze 3
.topic Int 10h Function 0Bh
 \i\p\aSummary\v@10h.0Bh\v\i\p                                   \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     In text modes, this function selects only the border color. The
     background color of each individual character is controlled by
     the upper 4 bits of that character's attribute byte.

     On the CGA and EGA, this function is valid for palette selection
     only in 320-by-200 4-color graphics modes.

     In 320-by-200 4-color graphics modes, if register Bh = 01h, the
     following palettes may be selected:

     \bPalette\p     \bPixel value\p     \bColor\p

     0           0               Same as background
                 1               Green
                 2               Red
                 3               Brown or yellow
     1           0               Same as background
                 1               Cyan
                 2               Magenta
                 3               White

     On the CGA in 640-by-200 2-color graphics mode, the background
     color selected with this function actually controls the display
     color for nonzero pixels; zero pixels are always displayed as
     black.

     On the PCjr in 640-by-200 2-color graphics mode, if Bh = 00h and
     bit 0 of register BL is cleared, pixel value 1 is displayed as
     white; if bit 0 is set, pixel value 1 is displayed as black.
.context @10h.0Ch
.freeze 3
.topic Int 10h Function 0Ch
 \i\p\aDetail\v@10h.0Ch.des\v\i\p                                    \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   0Ch

  \bTitle:\p       Write Graphics Pixel

  \bSee also:\p    \aRead Graphics Pixel\v@10h.0Dh\v

  \bDescription:\p                           [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Draws a point on the display at the specified graphics
     coordinates.

     \bInput\p                                   \bOutput\p

     AH = 0Ch                                None
     AL = Pixel value
     BH = Page
     CX = Column (graphics x coordinate)
     DX = Row (graphics y coordinate)
.context @10h.0Ch.des
.freeze 3
.topic Int 10h Function 0Ch
 \i\p\aSummary\v@10h.0Ch\v\i\p                                   \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The range of valid pixel values and (x, y) coordinates depends on
     the current video mode.

     If bit 7 of AL is set, the new pixel value will be exclusive-OR'd
     (XOR) with the current contents of the pixel.

     Register BH is ignored for display modes that support only one
     page.
.context @10h.0Dh
.freeze 3
.topic Int 10h Function 0Dh
 \i\p\aDetail\v@10h.0Dh.des\v\i\p                                    \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   0Dh

  \bTitle:\p       Read Graphics Pixel

  \bSee also:\p    \aWrite Graphics Pixel\v@10h.0Ch\v

  \bDescription:\p                           [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Obtains the current value of the pixel on the display at the
     specified graphics coordinates.

     \bInput\p                                   \bOutput\p

     AH = 0Dh                                AL = Pixel value
     BH = Page
     CX = Column (graphics x coordinate)
     DX = Row (graphics y coordinate)
.context @10h.0Dh.des
.freeze 3
.topic Int 10h Function 0Dh
 \i\p\aSummary\v@10h.0Dh\v\i\p                                   \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The range of valid (x, y) coordinates and possible pixel values
     depends on the current video mode.

     Register BH is ignored for display modes that support only one
     page.
.context @10h.0Eh
.freeze 3
.topic Int 10h Function 0Eh
 \i\p\aDetail\v@10h.0Eh.des\v\i\p \i\p\aExample\v@WriteTTY.asx\v\i\p                          \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   0Eh

  \bTitle:\p       Write Character in Teletype Mode

  \bSee also:\p    \aCharacter Output\v@21h.02h\v, \aWrite String in Teletype Mode\v@10h.13h\v

  \bDescription:\p                     [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Writes an ASCII character to the display at the current cursor
     position, using the specified color (if in graphics modes), and
     then increments the cursor position appropriately.

     \bInput\p                                      \bOutput\p

     AH = 0Eh                                   None
     AL = Character
     BH = Page
     BL = Foreground color (graphics modes)

.context @10h.0Eh.des
.freeze 3
.topic Int 10h Function 0Eh
 \i\p\aSummary\v@10h.0Eh\v\i\p \i\p\aExample\v@WriteTTY.asx\v\i\p                         \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The special ASCII codes for bell (07h), backspace (08h), carriage
     return (0Dh), and line feed (0Ah) are recognized, and the
     appropriate action is taken. All other characters are written to
     the display (even if they are control characters), and the cursor
     is moved to the next position.

     In video modes that support multiple pages, characters can be
     written to any page, regardless of the page currently being
     displayed.

     Line wrapping and scrolling are provided. If the cursor is at the
     end of a line, it is moved to the beginning of the next line. If
     the cursor reaches the end of the last line on the screen, the
     screen is scrolled up by one line and the cursor is placed at the
     beginning of a new blank line. The attribute for the entire new
     line is taken from the last character that was written on the
     preceding line.

     The default MS-DOS console driver (CON) uses this function to
     write text to the screen. You cannot use this function to specify
     the attribute of a character. One method of writing a character to
     the screen with a specific attribute is to first write an ASCII
     blank (20h) with the desired attribute at the current cursor
     location using Int 10h Function 09h, then write the actual
     character with Int 10h Function 0Eh. This technique, although
     somewhat clumsy, does not require the program to explicitly handle
     line wrapping and scrolling.
.context @10h.0Fh
.context @10h.0Fh.des
.freeze 3
.topic Int 10h Function 0Fh
 \i\p\aExample\v@GetVidCo.asx\v\i\p                                   \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   0Fh

  \bTitle:\p       Get Video Mode

  \bSee also:\p    \aSet Video Mode\v@10h.00h\v, \aGet Configuration Information\v@10h.12h.10h\v, @GetMode

  \bDescription:\p                     [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Obtains the current display mode of the active video controller.
     This function can be called to obtain the screen width before
     clearing the screen with \aInt 10h Functions 06h or 07h\v@10h.06h\v.

     \bInput\p        \bOutput\p

     AH = 0Fh     AH = Number of character columns on screen
                  AL = Display mode
                       See: \aInt 10h Function 00h\v@10h.00h\v
                  BH = Active display page
.context @10h.10h
.freeze 3
.topic Interrupt 10h, Function 10h (Colors)
                                             \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h

  \bTitle:\p       Color Interrupts

  \bSee also:\p    \aGet Palette, Background, or Border\v@10h.0Bh\v

  \bSubfunction\p     \bName\p

  \a00h             Set Palette Register\v@10h.10h.00h\v
  \a01h             Set Border Color\v@10h.10h.01h\v
  \a02h             Set Palette and Border\v@10h.10h.02h\v
  \a03h             Toggle Blink/Intensity Bit\v@10h.10h.03h\v
  \a07h             Get Palette Register\v@10h.10h.07h\v
  \a08h             Get Border Color\v@10h.10h.08h\v
  \a09h             Get Palette and Border\v@10h.10h.09h\v
  \a10h             Set Color Register\v@10h.10h.10h\v
  \a12h             Set Block of Color Registers\v@10h.10h.12h\v
  \a13h             Set Color Page State\v@10h.10h.13h\v
  \a15h             Get Color Register\v@10h.10h.15h\v
  \a17h             Get Block of Color Registers\v@10h.10h.17h\v
  \a1Ah             Get Color Page State\v@10h.10h.1Ah\v
  \a1Bh             Set Gray-Scale Values\v@10h.10h.1Bh\v
.context @10h.10h.00h
.context @10h.10h.00h.des
.freeze 3
.topic Int 10h Function 10h Subfunction 00h
                                             \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h     \bSubfunction:\p   00h

  \bTitle:\p       Set Palette Register

  \bSee also:\p    \aGet Palette Register\v@10h.10h.07h\v

  \bDescription:\p                                 [PCjr] [EGA] [MCGA] [VGA]

     Sets the correspondence of a palette register to a displayable
     color. On the MCGA, this function can be called only with
     BX = 0712h and selects a color register set with eight consistent
     colors.

     \bInput\p                            \bOutput\p

     For PCjr, EGA, or VGA            None
       AH = 10h
       AL = 00h
       BH = Color value
       BL = Palette register (00-0Fh)

     For MCGA
       AH = 10h
       AL = 00h
       BX = 0712h
.context @10h.10h.01h
.freeze 3
.topic Int 10h Function 10h Subfunction 01h
                                             \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h     \bSubfunction:\p   01h

  \bTitle:\p       Set Border Color

  \bSee also:\p    \aGet Border Color\v@10h.10h.08h\v

  \bDescription:\p                                        [PCjr] [EGA] [VGA]

     Controls the color of the screen border (overscan).

     \bInput\p                \bOutput\p

     AH = 10h             None
     AL = 01h
     BH = Color value
.context @10h.10h.02h
.freeze 3
.topic Int 10h Function 10h Subfunction 02h
 \i\p\aDetail\v@10h.10h.02h.des\v\i\p                                    \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h     \bSubfunction:\p   02h

  \bTitle:\p       Set Palette and Border

  \bSee also:\p    \aGet Palette and Border\v@10h.10h.09h\v

  \bDescription:\p                                        [PCjr] [EGA] [VGA]

     Sets all palette registers and the border color (overscan) in one
     operation.

     \bInput\p                                    \bOutput\p

     AH = 10h                                 None
     AL = 02h
     ES:DX = segment:offset of color list
.context @10h.10h.02h.des
.freeze 3
.topic Int 10h Function 10h Subfunction 02h
 \i\p\aSummary\v@10h.10h.02h\v\i\p                                   \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The color list is 17 bytes long. The first 16 bytes are the color
     values to be loaded into palette registers 0-15, and the last byte
     is stored in the border color register.

     In 16-color graphics modes, the following default palette is set
     up:

     \bPixel value\p     \bColor\p

     01h             Blue
     02h             Green
     03h             Cyan
     04h             Red
     05h             Magenta
     06h             Brown
     07h             White
     08h             Gray
     09h             Light blue
     0Ah             Light green
     0Bh             Light cyan
     0Ch             Light red
     0Dh             Light magenta
     0Eh             Yellow
     0Fh             Intense white
.context @10h.10h.03h
.freeze 3
.topic Int 10h Function 10h Subfunction 03h
                                             \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h     \bSubfunction:\p   03h

  \bTitle:\p       Toggle Blink/Intensity Bit

  \bDescription:\p                                 [PCjr] [EGA] [MCGA] [VGA]

     Determines whether the most significant bit of a character
     attribute will select blinking or intensified display.

     \bInput                           Output\p

     AH = 10h                        None
     AL = 03h
     BL = Blink/intensity toggle
          0 = Enable intensity
          1 = Enable blinking
.context @10h.10h.07h
.freeze 3
.topic Int 10h Function 10h Subfunction 07h
                                             \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h     \bSubfunction:\p   07h

  \bTitle:\p       Get Palette Register

  \bSee also:\p    \aSet Palette Register\v@10h.10h.00h\v

  \bDescription:\p                                                     [VGA]

     Returns the color associated with the specified palette
     register.

     \bInput\p                     \bOutput\p

     AH = 10h                  BH = Color
     AL = 07h
     BL = Palette register
.context @10h.10h.08h
.freeze 3
.topic Int 10h Function 10h Subfunction 08h
                                             \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h     \bSubfunction:\p   08h

  \bTitle:\p       Get Border Color

  \bSee also:\p    \aSet Border Color\v@10h.10h.01h\v

  \bDescription:\p                                                     [VGA]

     Returns the current border color (overscan).

     \bInput\p        \bOutput\p

     AH = 10h     BH = Color
     AL = 08h
.context @10h.10h.09h
.freeze 3
.topic Int 10h Function 10h Subfunction 09h
                                             \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h     \bSubfunction:\p   09h

  \bTitle:\p       Get Palette and Border

  \bSee also:\p    \aSet Palette and Border\v@10h.10h.02h\v

  \bDescription:\p                                                     [VGA]

     Gets the contents of all palette registers and the border color
     (overscan) in one operation.

     \bInput\p                         \bOutput\p

     AH = 10h                      ES:DX = segment:offset of buffer
     AL = 09h                      (buffer contains palette values
     ES:DX = segment:offset of     in bytes 00h-0Fh and border color
             17-byte buffer        in byte 10h)
.context @10h.10h.10h
.freeze 3
.topic Int 10h Function 10h Subfunction 10h
 \i\p\aDetail\v@10h.10h.10h.des\v\i\p                                    \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h     \bSubfunction:\p   10h

  \bTitle:\p       Set Color Register

  \bSee also:\p    \aGet Color Register\v@10h.10h.15h\v, \aSet Block of Color Registers\v@10h.10h.12h\v,
               \aSet Gray-Scale Values\v@10h.10h.1Bh\v

  \bDescription:\p                                              [MCGA] [VGA]

     Programs an individual color register with a red-green-blue (RGB)
     combination.

     \bInput\p                   \bOutput\p

     AH = 10h                None
     AL = 10h
     BX = Color register
     CH = Green value
     CL = Blue value
     DH = Red value
.context @10h.10h.10h.des
.freeze 3
.topic Int 10h Function 10h Subfunction 10h
 \i\p\aSummary\v@10h.10h.10h\v\i\p                                   \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If gray-scale summing is enabled, the weighted gray-scale value is
     calculated as described under Int 10h Function 10h Subfunction 1Bh
     and is stored into all three components of the color register.
.context @10h.10h.12h
.freeze 3
.topic Int 10h Function 10h Subfunction 12h
 \i\p\aDetail\v@10h.10h.12h.des\v\i\p                                    \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h     \bSubfunction:\p   12h

  \bTitle:\p       Set Block of Color Registers

  \bSee also:\p    \aGet Block of Color Registers\v@10h.10h.17h\v, \aSet Color Register\v@10h.10h.10h\v,
               \aSet Gray-Scale Values\v@10h.10h.1Bh\v

  \bDescription:\p                                              [MCGA] [VGA]

     Programs a group of consecutive color registers in one operation.

     \bInput\p                                     \bOutput\p

     AH = 10h                                  None
     AL = 12h
     BX = First color register
     CX = Number of color registers
     ES:DX = segment:offset of color table
.context @10h.10h.12h.des
.freeze 3
.topic Int 10h Function 10h Subfunction 12h
 \i\p\aSummary\v@10h.10h.12h\v\i\p                                   \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The color register table consists of a series of 3-byte entries,
     one entry per color register to be programmed. The bytes of an
     individual entry specify the red, green, and blue values (in that
     order) for the associated color register.
.context @10h.10h.13h
.context @10h.10h.13h.des
.freeze 3
.topic Int 10h Function 10h Subfunction 13h
                                             \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h     \bSubfunction:\p   13h

  \bTitle:\p       Set Color Page State

  \bSee also:\p    \aGet Color Page State\v@10h.10h.1Ah\v

  \bDescription:\p                                                     [VGA]

     Selects the paging mode for the color registers, or selects an
     individual page of color registers. This function is not valid
     in mode 13h (320-by-200 256-color graphics).

     \bInput\p                                     \bOutput\p

     To select the paging mode                 None
       AH = 10h
       AL = 13h
       BH = Paging mode
          = 00h for 4 pages of 64 registers
          = 01h for 16 pages of 16 registers
       BL = 00h

     To select a color register page
       AH = 10h
       AL = 13h
       BH = Page
       BL = 01h
.context @10h.10h.15h
.freeze 3
.topic Int 10h Function 10h Subfunction 15h
                                             \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h     \bSubfunction:\p   15h

  \bTitle:\p       Get Color Register

  \bSee also:\p    \aSet Color Register\v@10h.10h.10h\v, \aGet Block of Color Registers\v@10h.10h.17h\v

  \bDescription:\p                                              [MCGA] [VGA]

     Returns the contents of a color register as its red, green, and
     blue components.

     \bInput\p                   \bOutput\p

     AH = 10h                CH = Green value
     AL = 15h                CL = Blue value
     BX = Color register     DH = Red value
.context @10h.10h.17h
.context @10h.10h.17h.des
.freeze 3
.topic Int 10h Function 10h Subfunction 17h
                                             \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h     \bSubfunction:\p   17h

  \bTitle:\p       Get Block of Color Registers

  \bSee also:\p    \aSet Block of Color Registers\v@10h.10h.12h\v, \aGet Color Register\v@10h.10h.15h\v

  \bDescription:\p                                              [MCGA] [VGA]

     Allows the red, green, and blue components associated with each of
     a set of color registers to be read in one operation. The color
     list returned in the caller's buffer consists of a series of
     3-byte entries corresponding to the color registers. Each 3-byte
     entry contains the register's red, green, and blue components in
     that order.

     \bInput\p                                 \bOutput\p

     AH = 10h                              ES:DX = segment:offset of buffer
     AL = 17h                              (Buffer contains color list)
     BX = First color register
     CX = Number of color registers
     ES:DX = segment:offset of buffer
             to receive color list
.context @10h.10h.1Ah
.context @10h.10h.1Ah.des
.freeze 3
.topic Int 10h Function 10h Subfunction 1Ah
                                             \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h     \bSubfunction:\p   1Ah

  \bTitle:\p       Get Color Page State

  \bSee also:\p    \aSet Color Page State\v@10h.10h.13h\v

  \bDescription:\p                                                     [VGA]

     Returns the color register paging mode and current color page. See
     Int 10h Function 10h Subfunction 13h, which allows selection of
     the paging mode or current color page.

     \bInput\p        \bOutput\p

     AH = 10h     BH = Color page
     AL = 1Ah     BL = Paging mode
                     = 00h (if 4 pages of 64 registers)
                     = 01h (if 16 pages of 16 registers)
.context @10h.10h.1Bh
.context @10h.10h.1Bh.des
.freeze 3
.topic Int 10h Function 10h Subfunction 1Bh
                                             \i\p\aUp\v@10h.10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   10h     \bSubfunction:\p   1Bh

  \bTitle:\p       Set Gray-Scale Values

  \bSee also:\p    \aEnable/Disable Gray-Scale Summing\v@10h.12h.33h\v

  \bDescription:\p                                              [MCGA] [VGA]

     Transforms the red, green, and blue values of one or more color
     registers into the gray-scale equivalents. For each color
     register, the weighted sum of its red, green, and blue values is
     calculated (30% red + 59% green + 11% blue) and written back into
     all three components of the color register. The original red,
     green, and blue values are lost.

     \bInput\p                              \bOutput\p

     AH = 10h                           None
     AL = 1Bh
     BX = First color register
     CX = Number of color registers
.context @10h.11h
.freeze 3
.topic Interrupt 10h, Function 11h (Fonts)
                                             \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   11h

  \bTitle:\p       Font Interrupts

     \bSubfunction\p     \bName\p

     \a00h             Load User Font and Reprogram Controller\v@10h.11h.00h\v
     \a10h             Load User Font and Reprogram Controller\v@10h.11h.00h\v
     \a01h             Load ROM 8-by-14 Font and Reprogram Controller\v@10h.11h.01h\v
     \a11h             Load ROM 8-by-14 Font and Reprogram Controller\v@10h.11h.01h\v
     \a02h             Load ROM 8-by-8 Font and Reprogram Controller\v@10h.11h.02h\v
     \a12h             Load ROM 8-by-8 Font and Reprogram Controller\v@10h.11h.02h\v
     \a03h             Set Block Specifier\v@10h.11h.03h\v
     \a04h             Load ROM 8-by-16 Font and Reprogram Controller\v@10h.11h.04h\v
     \a14h             Load ROM 8-by-16 Font and Reprogram Controller\v@10h.11h.04h\v
     \a20h             Set Int 1Fh Font Pointer\v@10h.11h.20h\v
     \a21h             Set Int 43h for User's Font\v@10h.11h.21h\v
     \a22h             Set Int 43h for ROM 8-by-14 Font\v@10h.11h.22h\v
     \a23h             Set Int 43h for ROM 8-by-8 Font\v@10h.11h.23h\v
     \a24h             Set Int 43h for ROM 8-by-16 Font\v@10h.11h.24h\v
     \a30h             Get Font Information\v@10h.11h.30h\v
.context @10h.11h.00h
.freeze 3
.topic Int 10h Function 11h Subfunction 00h/10h
 \i\p\aDetail\v@10h.11h.00h.des\v\i\p \i\p\aExample\v@SetLineM.asx\v\i\p                          \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   11h     \bSubfunction:\p   00h/10h

  \bTitle:\p       Load User Font and Reprogram Controller

  \bDescription:\p                                        [EGA] [MCGA] [VGA]

     Loads the user's font (character definition) table into the
     specified block of character generator RAM.

     \bInput\p                                          \bOutput\p

     AH = 11h                                       None
     AL = 00h or 10h
     BH = Points (bytes per character)
     BL = Block
     CX = Number of characters defined by table
     DX = First character code in table
     ES:BP = segment:offset of font table
.context @10h.11h.00h.des
.freeze 3
.topic Int 10h Function 11h Subfunction 00h/11h
 \i\p\aSummary\v@10h.11h.00h\v\i\p \i\p\aExample\v@SetLineM.asx\v\i\p                         \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function provides font selection in text (alphanumeric)
     display modes. For font selection in graphics (all-points-
     addressable) modes, see Int 10h Function 11h Subfunctions 20h-24h.

     If AL = 10h, page 0 must be active. The points (bytes per
     character), rows, and length of the refresh buffer are
     recalculated. The controller is reprogrammed with the maximum
     scan line (points - 1), cursor start (points - 2), cursor end
     (points - 1), vertical display end ((rows * points) - 1), and
     underline location (points - 1, mode 7 only).

     If Subfunction 10h is called at any time other than immediately
     after a mode set, the results are unpredictable.

     On the MCGA, a Subfunction 00h call should be followed by a
     Subfunction 03h call so that the ROM BIOS will load the font into
     the character generator's internal font pages.

     Subfunction 10h is reserved on the MCGA. If it is called,
     Subfunction 00h is executed.

     Subfunction 10h acts like Subfunction 00h, but it also adjusts
     character height according to the height of characters being
     loaded.
.context @10h.11h.01h
.freeze 3
.topic Int 10h Function 11h Subfunction 01h/11h
 \i\p\aDetail\v@10h.11h.01h.des\v\i\p                                    \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   11h     \bSubfunction:\p   01h/11h

  \bTitle:\p       Load ROM 8-by-14 Font and Reprogram Controller

  \bDescription:\p                                               [EGA] [VGA]

     Loads the ROM BIOS default 8-by-14 font table into the specified
     block of character generator RAM.

     \bInput\p               \bOutput\p

     AH = 11h            None
     AL = 01h or 11h
     BL = Block
.context @10h.11h.01h.des
.freeze 3
.topic Int 10h Function 11h Subfunction 01h/11h
 \i\p\aSummary\v@10h.11h.01h\v\i\p                                   \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function provides font selection in text (alphanumeric)
     display modes. For font selection in graphics (all-points-
     addressable) modes, see Int 10h Function 11h Subfunctions 20h-24h.

     If AL = 11h, page 0 must be active. The points (bytes per
     character), rows, and length of the refresh buffer are
     recalculated. The controller is reprogrammed with the maximum
     scan line (points - 1), cursor start (points - 2), cursor end
     (points - 1), vertical display end ((rows * points) - 1), and
     underline location (points - 1, mode 7 only).

     If Subfunction 11h is called at any time other than
     immediately after a mode set, the results are unpredictable.

     Subfunctions 01h and 11h are reserved on the MCGA. If either is
     called, Subfunction 04h is executed.

     Subfunction 11h acts like Subfunction 01h, but it also adjusts
     character height according to the height of characters being
     loaded.
.context @10h.11h.02h
.freeze 3
.topic Int 10h Function 11h Subfunction 02h/12h
 \i\p\aDetail\v@10h.11h.02h.des\v\i\p                                    \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   11h     \bSubfunction:\p   02h/12h

  \bTitle:\p       Load ROM 8-by-8 Font and Reprogram Controller

  \bDescription:\p                                        [EGA] [MCGA] [VGA]

     Loads the ROM BIOS default 8-by-8 font table into the specified
     block of character generator RAM.

     \bInput\p               \bOutput\p

     AH = 11h            None
     AL = 02h or 12h
     BL = Block
.context @10h.11h.02h.des
.freeze 3
.topic Int 10h Function 11h Subfunction 02h/12h
 \i\p\aSummary\v@10h.11h.02h\v\i\p                                   \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function provides font selection in text (alphanumeric)
     display modes. For font selection in graphics
     (all-points-addressable) modes, see Int 10h Function 11h
     Subfunctions 20h-24h.

     If AL = 12h, page 0 must be active. The points (bytes per
     character), rows, and length of the refresh buffer are
     recalculated. The controller is reprogrammed with the maximum
     scan line (points - 1), cursor start (points - 2), cursor end
     (points - 1), vertical display end ((rows * points) - 1), and
     underline location (points - 1, mode 7 only).

     If Subfunction 12h is called at any time other than immediately
     after a mode set, the results are unpredictable.

     On the MCGA, a Subfunction 02h call should be followed by a
     Subfunction 03h call, so that the ROM BIOS will load the font into
     the character generator's internal font pages.

     Subfunction 12h is reserved on the MCGA. If it is called,
     Subfunction 02h is executed.

     Subfunction 12h acts like Subfunction 02h, but it also adjusts
     character height according to the height of characters being
     loaded.
.context @10h.11h.03h
.freeze 3
.topic Int 10h Function 11h Subfunction 03h
 \i\p\aDetail\v@10h.11h.03h.des\v\i\p                                    \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   11h     \bSubfunction:\p   03h

  \bTitle:\p       Set Block Specifier

  \bDescription:\p                                        [EGA] [MCGA] [VGA]

     Determines the character blocks selected by bit 3 of character
     attribute bytes in alphanumeric (text) display modes.

     \bInput\p                              \bOutput\p

     AH = 11h                           None
     AL = 03h
     BL = Character generator block
          select code
.context @10h.11h.03h.des
.freeze 3
.topic Int 10h Function 11h Subfunction 03h
 \i\p\aSummary\v@10h.11h.03h\v\i\p                                   \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     On the EGA and MCGA, the bits of BL are used as follows:

     \bBits\p     \bSignificance\p

     0-1      Character block selected by attribute bytes with bit 3 = 0
     2-3      Character block selected by attribute bytes with bit 3 = 1
     4-7      Not used (should be 0)

     On the VGA, the bits of BL are used as follows:

     \bBits\p      \bSignificance\p

     0, 1, 4   Character block selected by attribute bytes with bit 3 = 0
     2, 3, 5   Character block selected by attribute bytes with bit 3 = 1
     6-7       Not used (should be 0)

     When using a 256-character set, both fields of BL should select
     the same character block. In such cases, character attribute bit 3
     controls the foreground intensity.

     When using 512-character sets, the fields of BL designate the
     blocks holding each half of the character set, and bit 3 of the
     character attribute selects the upper or lower half of the
     character set.

     When using a 512-character set, a call to Int 10h Function 10h
     Subfunction 00h with BX = 0712h is recommended to set the color
     planes to eight consistent colors.
.context @10h.11h.04h
.freeze 3
.topic Int 10h Function 11h Subfunction 04h/14h
 \i\p\aDetail\v@10h.11h.04h.des\v\i\p                                    \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   11h     \bSubfunction:\p   04h/14h

  \bTitle:\p       Load ROM 8-by-16 Font and Reprogram Controller

  \bDescription:\p                                               [MCGA] [VGA]

     Loads the ROM BIOS default 8-by-16 font table into the specified
     block of character generator RAM.

     \bInput\p               \bOutput\p

     AH = 11h            None
     AL = 04h or 14h
     BL = Block
.context @10h.11h.04h.des
.freeze 3
.topic Int 10h Function 11h Subfunction 04h
 \i\p\aSummary\v@10h.11h.04h\v\i\p                                   \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function provides font selection in text (alphanumeric)
     display mode. For font selection in graphics (all-points-
     addressable) modes, see Int 10h Function 11h Subfunctions 20h-24h.

     If AL = 14h, page 0 must be active. The points (bytes per
     character), rows, and length of the refresh buffer are
     recalculated. The controller is reprogrammed with the maximum scan
     line (points - 1), cursor start (points - 2), cursor end
     (points - 1), vertical display end ((rows * points - 1) for 350
     and 400 line modes or (rows * points * 2 - 1) for 200 line modes),
     and underline location (points - 1, mode 7 only).

     If Subfunction 14h is called at any time other than immediately
     after a mode set, the results are unpredictable.

     On the MCGA, a Subfunction 04h call should be followed by a
     Subfunction 03h call so that the ROM BIOS will load the font into
     the character generator's internal font pages.

     Subfunction 14h is reserved on the MCGA. If it is called,
     Subfunction 04h is executed.

     Subfunction 14h acts like Subfunction 04h, but it also adjusts
     character height according to the height of characters being
     loaded.
.context @10h.11h.20h
.freeze 3
.topic Int 10h Function 11h Subfunction 20h
 \i\p\aDetail\v@10h.11h.20h.des\v\i\p                                    \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   11h     \bSubfunction:\p   20h

  \bTitle:\p       Set Int 1Fh Font Pointer

  \bSee also:\p    \aPointer to Graphics Character Pattern Table\v@1Fh\v

  \bDescription:\p                                        [EGA] [MCGA] [VGA]

     Sets the Int 1Fh pointer to the user's font table. This table is
     used for character codes 80h-FFh in graphics modes 04h-06h.

     \bInput\p                                    \bOutput\p

     AH = 11h                                 None
     AL = 20h
     ES:BP = segment:offset of font table
.context @10h.11h.20h.des
.freeze 3
.topic Int 10h Function 11h Subfunction 20h
 \i\p\aSummary\v@10h.11h.20h\v\i\p                                   \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function provides font selection in graphics (all-points-
     addressable) display modes. For font selection in text
     (alphanumeric) modes, see Int 10h Function 11h Subfunctions
     00h-14h.

     If this subfunction is called at any time other than immediately
     after a mode set, the results are unpredictable.
.context @10h.11h.21h
.freeze 3
.topic Int 10h Function 11h Subfunction 21h
 \i\p\aDetail\v@10h.11h.21h.des\v\i\p                                    \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   11h     \bSubfunction:\p   21h

  \bTitle:\p       Set Int 43h for User's Font

  \bDescription:\p                                        [EGA] [MCGA] [VGA]

     Sets the vector for Int 43h to point to the user's font table and
     updates the video ROM BIOS data area. The video controller is not
     reprogrammed.

     \bInput\p                                            \bOutput\p

     AH = 11h                                         None
     AL = 21h
     BL = Character rows specifier
          00h (if user-specified in DL)
          01h = 14 (0Eh) rows
          02h = 25 (19h) rows
          03h = 43 (2Bh) rows
     CX = Points (bytes per character)
     DL = Character rows per screen (if BL = 00h)
     ES:BP = segment:offset of user font table

.context @10h.11h.21h.des
.freeze 3
.topic Int 10h Function 11h Subfunction 21h
 \i\p\aSummary\v@10h.11h.21h\v\i\p                                   \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function provides font selection in graphics (all-points-
     addressable) display modes. For font selection in text
     (alphanumeric) modes, see Int 10h Function 11h Subfunctions
     00h-14h.

     If this subfunction is called at any time other than immediately
     after a mode set, the results are unpredictable.
.context @10h.11h.22h
.freeze 3
.topic Int 10h Function 11h Subfunction 22h
 \i\p\aDetail\v@10h.11h.22h.des\v\i\p                                    \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   11h     \bSubfunction:\p   22h

  \bTitle:\p       Set Int 43h for ROM 8-by-14 Font

  \bDescription:\p                                          [EGA] [MCGA] [VGA]

     Sets the vector for Int 43h to point to the ROM BIOS default
     8-by-14 font and updates the video ROM BIOS data area. The video
     controller is not reprogrammed.

     \bInput\p                                            \bOutput\p

     AH = 11h                                         None
     AL = 22h
     BL = Character rows specifier
          00h (if user-specified in DL)
          01h = 14 (0Eh) rows
          02h = 25 (19h) rows
          03h = 43 (2Bh) rows
     DL = Character rows per screen (if BL = 00h)

.context @10h.11h.22h.des
.freeze 3
.topic Int 10h Function 11h Subfunction 22h
 \i\p\aSummary\v@10h.11h.22h\v\i\p                                   \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function provides font selection in graphics (all-points-
     addressable) display modes. For font selection in text
     (alphanumeric) modes, see Int 10h Function 11h Subfunctions
     00h-14h.

     If this subfunction is called at any time other than immediately
     after a mode set, the results are unpredictable.

     When this subfunction is called on the MCGA, Subfunction 24h is
     substituted.
.context @10h.11h.23h
.freeze 3
.topic Int 10h Function 11h Subfunction 23h
 \i\p\aDetail\v@10h.11h.23h.des\v\i\p                                    \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   11h     \bSubfunction:\p   23h

  \bTitle:\p       Set Int 43h for ROM 8-by-8 Font

  \bDescription:\p                                        [EGA] [MCGA] [VGA]

     Sets the vector for Int 43h to point to the ROM BIOS default
     8-by-8 font and updates the video ROM BIOS data area. The video
     controller is not reprogrammed.

     \bInput\p                                            \bOutput\p

     AH = 11h                                         None
     AL = 23h
     BL = Character rows specifier
          00h (if user-specified in DL)
          01h = 14 (0Eh) rows
          02h = 25 (19h) rows
          03h = 43 (2Bh) rows
     DL = Character rows per screen (if BL = 00h)
.context @10h.11h.23h.des
.freeze 3
.topic Int 10h Function 11h Subfunction 23h
 \i\p\aSummary\v@10h.11h.23h\v\i\p                                   \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function provides font selection in graphics (all-points-
     addressable) display modes. For font selection in text
     (alphanumeric) modes, see Int 10h Function 11h Subfunctions
     00h-14h.

     If this subfunction is called at any time other than immediately
     after a mode set, the results are unpredictable.
.context @10h.11h.24h
.freeze 3
.topic Int 10h Function 11h Subfunction 24h
 \i\p\aDetail\v@10h.11h.24h.des\v\i\p                                    \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   11h     \bSubfunction:\p   24h

  \bTitle:\p       Set Int 43h for ROM 8-by-16 Font

  \bDescription:\p                                              [MCGA] [VGA]

     Sets the vector for Int 43h to point to the ROM BIOS default
     8-by-16 font and updates the video ROM BIOS data area. The video
     controller is not reprogrammed.

     \bInput\p                                            \bOutput\p

     AH = 11h                                         None
     AL = 24h
     BL = Row specifier
          00h (if user-specified in DL)
          01h = 14 (0Eh) rows
          02h = 25 (19h) rows
          03h = 43 (2Bh) rows
     DL = Character rows per screen (if BL = 00h)

.context @10h.11h.24h.des
.freeze 3
.topic Int 10h Function 11h Subfunction 24h
 \i\p\aSummary\v@10h.11h.24h\v\i\p                                   \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function provides font selection in graphics (all-points-
     addressable) display modes. For font selection in text
     (alphanumeric) modes, see Int 10h Function 11h Subfunctions
     00h-14h.

     If this subfunction is called at any time other than immediately
     after a mode set, the results are unpredictable.
.context @10h.11h.30h
.freeze 3
.topic Int 10h Function 11h Subfunction 30h
 \i\p\aExample\v@setlinem.asx\v\i\p                                   \i\p\aUp\v@10h.11h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   11h     \bSubfunction:\p   30h

  \bTitle:\p       Get Font Information

  \bDescription:\p                                        [EGA] [MCGA] [VGA]

     Returns a pointer to the character definition table for a font,
     and the points (bytes per character) and rows for that font. The
     point size (CX) and number of rows (DL) are not changed by this
     function. To change the point size, use \aInt 10h Function\v@10h.11h.00h\v
     \a11h Subfunction 00h\v@10h.11h.00h\v. To change the number of rows, use \aInt\v@10h.00h\v
     \a10h Function 00h\v@10h.00h\v.

     \bInput\p                                   \bOutput\p

     AH = 11h                                CX = Points (bytes per
     AL = 30h                                     character)
     BH = Font code                          DL = Character rows - 1
          00h = Current Int 1Fh contents     ES:BP = segment:offset of
          01h = Current Int 43h contents             font table
          02h = ROM 8-by-14 font
                (EGA, VGA only)
          03h = ROM 8-by-8 font
                (characters 00h-7Fh)
          04h = ROM 8-by-8 font
                (characters 80h-FFh)
          05h = ROM alternate 9-by-14 font
                (EGA, VGA only)
          06h = ROM 8-by-16 font
                (MCGA, VGA only)
          07h = ROM alternate 9-by-16 font
                (VGA only)
.context @10h.12h
.freeze 3
.topic Interrupt 10h, Function 12h (Video Config.)
                                             \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   12h
  \bTitle:\p        Video Configuration Interrupts

     \bSubfunction\p     \bName\p

     \a10h             Get Configuration Information\v@10h.12h.10h\v
     \a20h             Select Alternate PrintScreen\v@10h.12h.20h\v
     \a30h             Set Scan Lines\v@10h.12h.30h\v
     \a31h             Enable/Disable Default Palette Loading\v@10h.12h.31h\v
     \a32h             Enable/Disable Video\v@10h.12h.32h\v
     \a33h             Enable/Disable Gray-Scale Summing\v@10h.12h.33h\v
     \a34h             Enable/Disable Cursor Emulation\v@10h.12h.34h\v
     \a35h             Switch Active Display\v@10h.12h.35h\v
     \a36h             Enable/Disable Screen Refresh\v@10h.12h.36h\v
.context @10h.12h.10h
.freeze 3
.topic Int 10h Function 12h Subfunction 10h
 \i\p\aDetail\v@10h.12h.10h.des\v\i\p                                    \i\p\aUp\v@10h.12h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   12h     \bSubfunction:\p   10h

  \bTitle:\p       Get Configuration Information

  \bSee also:\p    \aGet Video Mode\v@10h.0Fh\v, \aGet Functionality/State Information\v@10h.1Bh\v

  \bDescription:\p                                               [EGA] [VGA]

     Obtains configuration information for the active video subsystem.

     \bInput\p        \bOutput\p

     AH = 12h     BH = Display type
     BL = 10h        = 0h (if color display)
                     = 1h (if monochrome display)
                  BL = Memory installed on EGA board
                     = 00h (if 64K)
                     = 01h (if 128K)
                     = 03h (if 256K)
                  CH = Feature bits
                  CL = Switch setting
.context @10h.12h.10h.des
.freeze 3
.topic Int 10h Function 12h Subfunction 10h
 \i\p\aSummary\v@10h.12h.10h\v\i\p                                   \i\p\aUp\v@10h.12h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The feature bits are set from Input Status register 0 in response
     to an output on the specified Feature Control register bits:

     \bFeature\p     \bFeature Control\p     \bInput Status\p
     \bBit(s)\p      \bOutput Bit\p          \bBit\p

     0           0                   5
     1           0                   6
     2           1                   5
     3           1                   6
     4-7         Not used            ÄÄ
 
     The bits in the switch settings byte indicate the state of the
     EGA's configuration DIP switch (1 = off, 0 = on).

     \bBit\p     \bSignificance\p

     0       Configuration switch 1
     1       Configuration switch 2
     2       Configuration switch 3
     3       Configuration switch 4
     4-7     Not used
.context @10h.12h.20h
.freeze 3
.topic Int 10h Function 12h Subfunction 20h
 \i\p\aExample\v@SetLineM.asx\v\i\p                                   \i\p\aUp\v@10h.12h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   12h     \bSubfunction:\p   20h

  \bTitle:\p       Select Alternate PrintScreen

  \bSee also:\p    \aPrint Screen\v@5h\v

  \bDescription:\p                                               [EGA] [VGA]

     Selects an alternate print-screen routine for the EGA and VGA that
     works properly if the screen length is not 25 lines. The ROM BIOS
     default print-screen routine always prints 25 lines.

     \bInput\p        \bOutput\p

     AH = 12h     None
     BL = 20h

.context @10h.12h.30h
.freeze 3
.topic Int 10h Function 12h Subfunction 30h
 \i\p\aExample\v@SetLineM.asx\v\i\p                                   \i\p\aUp\v@10h.12h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   12h     \bSubfunction:\p   30h

  \bTitle:\p       Set Scan Lines

  \bSee also:\p    \aSet Video Mode\v@10h.00h\v

  \bDescription:\p                                                     [VGA]

     Selects the number of scan lines for alphanumeric modes. The
     selected value takes effect the next time \aInt 10h Function 00h\v@10h.00h\v
     is called to select the display mode.

     \bInput\p                         \bOutput\p

     AH = 12h                      If the VGA is active
     AL = Scan line code             AL = 12h
          00h = 200 scan lines
          01h = 350 scan lines     If the VGA is not active
          02h = 400 scan lines       AL = 00h
          03h = 480 scan lines
     BL = 30h
.context @10h.12h.31h
.freeze 3
.topic Int 10h Function 12h Subfunction 31h
                                             \i\p\aUp\v@10h.12h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   12h     \bSubfunction\p   31h

  \bTitle:\p       Enable/Disable Default Palette Loading

  \bDescription:\p                                              [MCGA] [VGA]

     Enables or disables loading of a default palette when a video
     display mode is selected.

     \bInput\p                                          \bOutput\p

     AH = 12h                                       If function supported
     AL = 00h to enable default palette loading       AL = 12h
        = 01h to disable default palette loading
     BL = 31h
.context @10h.12h.32h
.freeze 3
.topic Int 10h Function 12h Subfunction 32h
                                             \i\p\aUp\v@10h.12h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   12h     \bSubfunction:\p   32h

  \bTitle:\p       Enable/Disable Video

  \bDescription:\p                                              [MCGA] [VGA]

     Enables or disables CPU access to the video adapter's I/O ports
     and video refresh buffer.

     \bInput\p                          \bOutput\p

     AH = 12h                       If function supported
     AL = 00h to enable access        AL = 12h
        = 01h to disable access
     BL = 32h
.context @10h.12h.33h
.context @10h.12h.33h.des
.freeze 3
.topic Int 10h Function 12h Subfunction 33h
                                             \i\p\aUp\v@10h.12h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   12h     \bSubfunction:\p   33h

  \bTitle:\p       Enable/Disable Gray-Scale Summing

  \bSee also:\p    \aSet Gray-Scale Values\v@10h.10h.1Bh\v

  \bDescription:\p                                              [MCGA] [VGA]

     Enables or disables gray-scale summing for the currently active
     display. When enabled, gray-scale summing occurs during display
     mode selection, palette programming, and color register loading.

     \bInput\p                                      \bOutput\p

     AH = 12h                                   If function supported
     AL = 00h to enable gray-scale summing        AL = 12h
        = 01h to disable gray-scale summing
     BL = 33h
.context @10h.12h.34h
.freeze 3
.topic Int 10h Function 12h Subfunction 34h
                                             \i\p\aUp\v@10h.12h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   12h     \bSubfunction:\p  34h

  \bTitle:\p       Enable/Disable Cursor Emulation

  \bSee also:\p    \aSet Cursor Type\v@10h.01h\v

  \bDescription:\p                                                     [VGA]

     Enables or disables cursor emulation for the currently active
     display. When cursor emulation is enabled, the ROM BIOS
     automatically remaps Int 10h Function 01h cursor starting and
     ending lines for the current character cell dimensions.

     \bInput\p                                    \bOutput\p

     AH = 12h                                 If function supported
     AL = 00h to enable cursor emulation        AL = 12h
        = 01h to disable cursor emulation
     BL = 34h

.context @10h.12h.35h
.freeze 3
.topic Int 10h Function 12h Subfunction 35h
  \i\p\aDetail\v@10h.12h.35h.des\v\i\p                                   \i\p\aUp\v@10h.12h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   12h     \bSubfunction:\p   35h

  \bTitle:\p       Switch Active Display

  \bDescription:\p                                              [MCGA] [VGA]

     Allows selection of one of two video adapters in the system, when
     memory use or port addresses conflict between the two adapters.

     \bInput\p                                 \bOutput\p

     AH = 12h                              If function supported
     AL = Switching function                 AL = 12h
        = 00h to disable initial           And if called with AL = 00h
          video adapter                    or 02h
        = 01h to enable system board         Video adapter state information
          video adapter                      saved in caller's buffer
        = 02h to disable active            Or if called with AL = 03h
          video adapter                      Video adapter state restored
        = 03h to enable inactive             from information in caller's
          video adapter                      buffer
     BL = 35h
     ES:DX = segment:offset of 128-byte
             buffer (if AL = 00h,
             02h, or 03h)
.context @10h.12h.35h.des
.freeze 3
.topic Int 10h Function 12h Subfunction 35h
 \i\p\aSummary\v@10h.12h.35h\v\i\p                                   \i\p\aUp\v@10h.12h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This subfunction cannot be used unless both video adapters have a
     disable capability (Int 10h Function 12h Subfunction 32h).

     If there is no conflict between the system board video and the
     adapter board video in memory or port use, both video
     controllers can be active simultaneously and this subfunction is
     not required.
.context @10h.12h.36h
.freeze 3
.topic Int 10h Function 12h Subfunction 36h
                                             \i\p\aUp\v@10h.12h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   12h     \bSubfunction:\p   36h

  \bTitle:\p       Enable/Disable Screen Refresh

  \bDescription:\p                                                     [VGA]

     Enables or disables the video refresh for the currently active
     display.

     \bInput\p                           \bOutput\p

     AH = 12h                        If function supported
     AL = 00h to enable refresh        AL = 12h
        = 01h to disable refresh
     BL = 36h
.context @10h.13h
.freeze 3
.topic Int 10h Function 13h
 \i\p\aDetail\v@10h.13h.des\v\i\p                                    \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   13h

  \bTitle:\p       Write String in Teletype Mode

  \bSee also:\p    \aWrite Character in Teletype Mode\v@10h.0Eh\v

  \bDescription:\p                     [MDA] [CGA] [PCjr] [EGA] [MCGA] [VGA]

     Transfers a string to the video buffer for the currently active
     display, starting at the specified position.

     \bInput\p                                             \bOutput\p

     AH = 13h                                          None
     AL = Write mode
        = 0  Attribute in BL;
             string contains character codes only;
             and cursor position is not updated
             after write
        = 1  Attribute in BL; string contains
             character codes only; and cursor
             position is updated after write
        = 2  String contains alternating character
             codes and attribute bytes; and cursor
             position is not updated after write
        = 3  String contains alternating character
             codes and attribute bytes; and cursor
             position is updated after write
     BH = Page
     BL = Attribute (if AL = 00h or 01h)
     CX = Length of character string
     DH = y coordinate (row)
     DL = x coordinate (column)
     ES:BP = segment:offset of string
.context @10h.13h.des
.freeze 3
.topic Int 10h Function 13h
 \i\p\aSummary\v@10h.13h\v\i\p                                   \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function is not available on the original IBM PC or PC/XT
     unless an EGA video adapter (which contains its own ROM BIOS) is
     installed.

     This function can be thought of as an extension to Int 10h
     Function 0Eh. The control characters bell (07h), backspace (08h),
     line feed (0Ah), and carriage return (0Dh) are recognized and
     handled appropriately.

.context @10h.1Ah
.freeze 3
.topic Int 10h Function 1Ah
 \i\p\aDetail\v@10h.1Ah.des\v\i\p \i\p\aExample\v@GetVidCo.asx\v\i\p                          \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   1Ah

  \bTitle:\p       Get or Set Display Combination Code

  \bDescription:\p                                                    [PS/2]

     Returns a code describing the installed display adapter(s), or
     updates the ROM BIOS's variable describing the installed
     adapter(s).

     \bInput\p                                  \bOutput\p

     AH = 1Ah                               If function supported
     AL = Subfunction                         AL = 1Ah
          00h = Get display                 And if called with AL = 00h
                combination code              BH = Inactive display code
          01h = Set display                   BL = Active display code
                combination code
     BH = Inactive display
          code (if AL = 01h)
     BL = Active display
          code (if AL = 01h)
.context @10h.1Ah.des
.freeze 3
.topic Int 10h Function 1Ah
 \i\p\aSummary\v@10h.1Ah\v\i\p \i\p\aExample\v@GetVidCo.asx\v\i\p                         \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The display codes are interpreted as follows:

     \bCode\p        \bVideo Subsystem Type\p

     00h         No display
     01h         MDA with 5151 monitor
     02h         CGA with 5153 or 5154 monitor
     03h         Reserved
     04h         EGA with 5153 or 5154 monitor
     05h         EGA with 5151 monitor
     06h         PGA with 5175 monitor
     07h         VGA with analog monochrome monitor
     08h         VGA with analog color monitor
     09h         Reserved
     0Ah         MCGA with digital color monitor
     0Bh         MCGA with analog monochrome monitor
     0Ch         MCGA with analog color monitor
     0Dh-FEh     Reserved
     FFh         Unknown
.context @10h.1Bh
.freeze 3
.topic Int 10h Function 1Bh
 \i\p\aDetail\v@10h.1Bh.des\v\i\p                                    \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   1Bh

  \bTitle:\p       Get Functionality/State Information

  \bSee also:\p    \aGet Configuration Information\v@10h.12h.10h\v

  \bDescription:\p                                                    [PS/2]

     Obtains information about the current display mode, as well as a
     pointer to a table describing the characteristics and capabilities
     of the video adapter and monitor.

     \bInput\p                                        \bOutput\p

     AH = 1Bh                                     If function supported
     BX = Implementation type (always 00h)          AL = 1Bh
     ES:DI = segment:offset of 64-byte buffer     And information placed
                                                  in caller's buffer
.context @10h.1Bh.des
.freeze 3
.topic Int 10h Function 1Bh
 \i\p\aSummary\v@10h.1Bh\v\i\p                                   \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The caller's buffer is filled in with information that depends on
     the current video display mode:

     \bBytes\p       \bContents\p

     00h-03h     Pointer to functionality information
     04h         Current video mode
     05h-06h     Number of character columns
     07h-08h     Length of video refresh buffer (bytes)
     09h-0Ah     Starting address in buffer of upper left corner of
                 display
     0Bh-1Ah     Cursor position for video pages 0-7 as eight 2-byte
                 entries; first byte of each pair is y coordinate,
                 second byte is x coordinate
     1Bh         Cursor starting line
     1Ch         Cursor ending line
     1Dh         Active display page
     1Eh-1Fh     Adapter base port address (3BXH monochrome,
                 3DXH color)
     20h         Current setting of register 3B8h or 3D8h
     21h         Current setting of register 3B9h or 3D9h
     22h         Number of character rows
     23h-24h     Character height in scan lines
     25h         Active display code
                 See: \aInt 10h Function 1Ah\v@10h.1ah\v
     26h         Inactive display code
                 See: \aInt 10h Function 1Ah\v@10h.1ah\v
     27h-28h     Number of displayable colors (0 for monochrome)
     29h         Number of display pages
     2Ah         Number of scan lines
                 00h = 200 scan lines
                 01h = 350 scan lines
                 02h = 400 scan lines
                 03h = 480 scan lines
                 04h-FFh = Reserved
     2Bh         Primary character block
                 See: \aInt 10h Function 11h Subfunction 03h\v@10h.11h.03h\v
     2Ch         Secondary character block
     2Dh         Miscellaneous state information

                 \bBits\p          \bSignificance\p

                 0             = 1 if all modes on all displays active
                                 (always 0 on MCGA)
                 1             = 1 if gray-scale summing active
                 2             = 1 if monochrome display attached
                 3             = 1 if mode set default palette
                                 loading disabled
                 4             = 1 if cursor emulation active
                                 (always 0 on MCGA)
                 5             = State of I/B toggle (0 = intensity,
                                 1 = blink)
                 6-7           = Reserved
     2Eh-30h     Reserved
     31h         Video memory available
                 00h = 64K
                 01h = 128K
                 02h = 192K
                 03h = 256K
     32h         Save pointer state information

                 \bBits\p     \bSignificance\p

                 0        = 1 if 512-character set active
                 1        = 1 if dynamic save area active
                 2        = 1 if alpha font override active
                 3        = 1 if graphics font override active
                 4        = 1 if palette override active
                 5        = 1 if display combination code (DCC)
                            extension active
                 6-7      = Reserved

     33h-3Fh     Reserved

     Bytes 0-3 of the caller's buffer contain a DWORD pointer (offset
     in lower word, segment in upper word) to the following information
     about the display adapter and monitor:

     \bBytes\p       \bContents\p

     00h         Video modes supported

                 \bBits\p     \bSignificance\p

                 0        = 1 if mode 00h supported
                 1        = 1 if mode 01h supported
                 2        = 1 if mode 02h supported
                 3        = 1 if mode 03h supported
                 4        = 1 if mode 04h supported
                 5        = 1 if mode 05h supported
                 6        = 1 if mode 06h supported
                 7        = 1 if mode 07h supported

     01h         Video modes supported

                 \bBits\p     \bSignificance\p

                 0        = 1 if mode 08h supported
                 1        = 1 if mode 09h supported
                 2        = 1 if mode 0Ah supported
                 3        = 1 if mode 0Bh supported
                 4        = 1 if mode 0Ch supported
                 5        = 1 if mode 0Dh supported
                 6        = 1 if mode 0Eh supported
                 7        = 1 if mode 0Fh supported

     02h         Video modes supported

                 \bBits\p     \bSignificance\p

                 0        = 1 if mode 10h supported
                 1        = 1 if mode 11h supported
                 2        = 1 if mode 12h supported
                 3        = 1 if mode 13h supported
                 4-7      = Reserved

     03h-06h     Reserved
     07h         Scan lines available in text modes

                 \bBits\p     \bSignificance\p

                 0        = 1 if 200 scan lines
                 1        = 1 if 350 scan lines
                 2        = 1 if 400 scan lines
                 3-7      = Reserved

     08h         Character blocks available in text modes
                 See: \aInt 10h Function 11h\v@10h.11h\v
     09h         Maximum number of active character blocks in text modes
     0Ah         Miscellaneous BIOS capabilities

                 \bBits\p     \bSignificance\p

                 0        = 1 if all modes active on all displays
                            (always 0 for MCGA)
                 1        = 1 if gray-scale summing available
                 2        = 1 if character font loading available
                 3        = 1 if mode set default palette
                            loading available
                 4        = 1 if cursor emulation available
                 5        = 1 if EGA (64-color) palette available
                 6        = 1 if color register loading available
                 7        = 1 if color register paging mode
                            select available

     0Bh         Miscellaneous BIOS capabilities

                 \bBits\p     \bSignificance\p

                 0        = 1 if light pen available
                 1        = 1 if save/restore video state available
                            (always 0 on MCGA)
                 2        = 1 if background intensity/blinking
                            control available
                 3        = 1 if get/set display combination
                            code available
                 4-7      = Reserved

     0Ch-0Dh     Reserved
     0Eh         Save area capabilities

                 \bBits\p     \bSignificance\p

                 0        = 1 if supports 512-character sets
                 1        = 1 if dynamic save area available
                 2        = 1 if alpha font override available
                 3        = 1 if graphics font override available
                 4        = 1 if palette override available
                 5        = 1 if display combination code
                            extension available
                 6-7      = Reserved

     0Fh         Reserved
.context @10h.1Ch
.freeze 3
.topic Int 10h Function 1Ch
 \i\p\aDetail\v@10h.1Ch.des\v\i\p                                    \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   10h     \bFunction:\p   1Ch

  \bTitle:\p       Save or Restore Video State

  \bDescription:\p                                                    [PS/2]

     Saves or restores the digital-to-analog converter (DAC) state and
     color registers, ROM BIOS video driver data area, or video
     hardware state.

     \bInput\p                                 \bOutput\p

     AH = 1Ch                              If function supported
     AL = Subfunction                        AL = 1Ch
        = 00h to get state buffer size     And if called with AL = 00h
        = 01h to save state                  BX = buffer block count
        = 02h to restore state               (64 bytes per block)
     CX = Requested states                 Or if called with AL = 01h
                                             State information placed
          \bBits\p     \bSignificance\p              in caller's buffer
                                           Or if called with AL = 02h
          0        Save/restore video        Requested state restored
                   hardware state            according to contents of
          1        Save/restore video        caller's buffer
                   BIOS data area
          2        Save/restore video
                   DAC state and color
                   registers
          3-15     Reserved

     ES:BX = segment:offset of buffer
.context @10h.1Ch.des
.freeze 3
.topic Int 10h Function 1Ch
 \i\p\aSummary\v@10h.1Ch\v\i\p                                   \i\p\aUp\v@10h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Subfunction 00h is used to determine the size of buffer that will
     be necessary to contain the specified state information. The
     caller must supply the buffer.

     The current video state is altered during a save state operation
     (AL = 01h). If the requesting program needs to continue in the same
     video state, it can follow the save state request with an
     immediate call to restore the video state.

     This function is supported on the VGA only.
.context @11h
.context 11h.des
.context 11h
.context 011h
.context 17
.freeze 3
.topic Int 11h
 \i\p\aExample\v@VeriCop.asx\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   11h

  \bTitle:\p       Get Equipment Configuration

  \bSee also:\p    \aConfiguration Data Memory\v@ConfigData\v

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Obtains the equipment list code word from the ROM BIOS. Bits 2-3
     of the returned value are used only in the ROM BIOS for the
     original IBM PC with the 64K system board and on the PCjr.

     \bInput\p       \bOutput\p

     None        AX = Equipment list code word

                 \bBits\p      \bSignificance\p

                 14-15     Number of printers installed
                 13        = 1 (if internal modem installed
                             (PC and XT only))
                           = 1 (if serial printer attached (PCjr))
                 12        = 1 (if game adapter installed)
                 9-11      Number of RS-232 ports installed
                 8         Reserved
                 6-7       Number of floppy disk drives
                           (if bit 0 = 1)
                           00 = 1
                           01 = 2
                           10 = 3
                           11 = 4
                 4-5       Initial video mode
                           00  reserved
                           01  40-by-25 color text
                           10  80-by-25 color text
                           11  80-by-25 monochrome
                 2-3       System board RAM size (PC)
                           00 = 16K
                           01 = 32K
                           10 = 48K
                           11 = 64K
                 2         = 1 (if pointing device installed (PS/2))
                 1         = 1 (if math coprocessor installed)
                 0         = 1 (if floppy disk drive(s) installed)
.context @12h
.context 12h
.context 012h
.context 18
.freeze 3
.topic Int 12h
 \i\p\aDetail\v@12h.des\v\i\p \i\p\aExample\v@GetMem.asx\v\i\p                          \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   12h

  \bTitle:\p       Get Conventional Memory Size

  \bSee also:\p    \aConfiguration Data Memory\v@ConfigData\v

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Returns the amount of conventional memory available for use by
     MS-DOS and application programs.

     \bInput\p       \bOutput\p

     None        AX = Memory size (in kilobytes)
.context @12h.des
.freeze 3
.topic Int 12h
 \i\p\aSummary\v@12h\v\i\p \i\p\aExample\v@GetMem.asx\v\i\p                         \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     On some early PC models, the amount of memory returned by this
     function is controlled by the settings of the dip switches on the
     system board and may not reflect all the memory that is physically
     present.

     On the PC/AT, the value returned is the amount of functional
     memory found during the power-on self-test, regardless of the
     memory size configuration information stored in CMOS RAM.

     The value returned does not reflect any extended memory (above the
     1=megabyte boundary) that may be installed on 80286 or 80386
     machines such as the PC/AT or PS/2 (Models 50 and above).
.context @13h
.context 13h
.context 013h
.context 19
..index disk I/O, Int 13h
..index Int 13h functions, Disk I/O Interrupts
.freeze 3
.topic Int 13h
                                             \i\p\aUp\v@BIOSCalls\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h

  \bTitle:\p       Disk I/O Interrupts

  \bSee also:\p    \aDiskette Data Memory\v@DiskData\v

  \bFunction\p     \bName\p

  \a00h          Reset Disk System\v@13h.00h\v
  \a01h          Get Disk System Status\v@13h.01h\v
  \a02h          Read Sector\v@13h.02h\v
  \a03h          Write Sector\v@13h.03h\v
  \a04h          Verify Sector\v@13h.04h\v
  \a05h          Format Track\v@13h.05h\v
  \a06h          Format Bad Track\v@13h.06h\v
  \a07h          Format Drive\v@13h.07h\v
  \a08h          Get Drive Parameters\v@13h.08h\v
  \a09h          Initialize Fixed Disk Characteristics\v@13h.09h\v
  \a0Ah          Read Sector Long\v@13h.0Ah\v
  \a0Bh          Write Sector Long\v@13h.0Bh\v
  \a0Ch          Seek\v@13h.0Ch\v
  \a0Dh          Reset Fixed Disk System\v@13h.0Dh\v
  \a0Eh          Read Sector Buffer\v@13h.0Eh\v
  \a0Fh          Write Sector Buffer\v@13h.0Fh\v
  \a10h          Get Drive Status\v@13h.10h\v
  \a11h          Recalibrate Drive\v@13h.11h\v
  \a12h          Controller RAM Diagnostic\v@13h.12h\v
  \a13h          Controller Drive Diagnostic\v@13h.13h\v
  \a14h          Controller Internal Diagnostic\v@13h.14h\v
  \a15h          Get Disk Type\v@13h.15h\v
  \a16h          Get Disk Change Status\v@13h.16h\v
  \a17h          Set Disk Type\v@13h.17h\v
  \a18h          Set Media Type for Format\v@13h.18h\v
  \a19h          Park Heads\v@13h.19h\v
  \a1Ah          Format ESDI Drive\v@13h.1Ah\v
.context @13h.00h
.freeze 3
.topic Int 13h Function 00h
 \i\p\aDetail\v@13h.00h.des\v\i\p                                    \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   00h

  \bTitle:\p       Reset Disk System

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Resets the disk controller, recalibrates its attached drives (the
     read/write arm is moved to cylinder 0), and prepares for disk I/O.

     \bInput\p                              \bOutput\p

     AH = 00h                           If function successful
     DL = Drive                           Carry flag: clear
        = 00h-7Fh floppy disk             AH = 00h
        = 80h-FFh fixed disk
                                        If function unsuccessful
                                          Carry flag: set
                                          AH = Status
                                          See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.00h.des
.freeze 3
.topic Int 13h Function 00h
 \i\p\aSummary\v@13h.00h\v\i\p                                   \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function should be called after a failed floppy disk Read,
     Write, Verify, or Format request before retrying the operation.

     If called with DL >= 80h (i.e., selecting a fixed disk drive), the
     floppy disk controller and then the fixed disk controller are
     reset. See also Int 13h Function 0Dh, which allows the fixed disk
     controller to be reset without affecting the floppy disk
     controller.
.context @13h.01h.des
.context @13h.01h
.freeze 3
.topic Int 13h Function 01h
                                             \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   01h

  \bTitle:\p       Get Disk System Status

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Returns the status of the most recent disk operation. On fixed
     disks, error code 11h (ECC data error) indicates that a
     recoverable error was detected during a preceding Read Sector (Int
     13h Function 02h) function.

     \bInput\p                         \bOutput\p

     AH = 01h                      AH = 00h
     DL = Drive                    AL = Status of previous disk operation
        = 00h-7Fh  floppy disk        = 00h      No error
        = 80h-FFh  fixed disk         = 01h      Invalid command
                                      = 02h      Address mark not found
                                      = 03h      Disk write-protected (F)
                                      = 04h      Sector not found
                                      = 05h      Reset failed (H)
                                      = 06h      Floppy disk removed (F)
                                      = 07h      Bad parameter table (H)
                                      = 08h      DMA overrun (F)
                                      = 09h      DMA crossed 64K boundary
                                      = 0Ah      Bad sector flag (H)
                                      = 0Bh      Bad track flag (H)
                                      = 0Ch      Media type not found (F)
                                      = 0Dh      Invalid number of sectors
                                                 on format (H)
                                      = 0Eh      Control data address mark
                                                 detected (H)
                                      = 0Fh      DMA arbitration level out
                                                 of range (H)
                                      = 10h      Uncorrectable CRC* or ECCœ
                                                 data error
                                      = 11h      ECC corrected data error
                                                 (H)
                                      = 20h      Controller failed
                                      = 40h      Seek failed
                                      = 80h      Disk timed-out
                                                 (failed to respond)
                                      = AAh      Drive not ready (H)
                                      = BBh      Undefined error (H)
                                      = CCh      Write fault (H)
                                      = E0h      Status register error (H)
                                      = FFh      Sense operation failed (H)

     H = Fixed disk only
     F = Floppy disk only
     * Cyclic Redundancy Check code
     œ Error Checking and Correcting code
.context @13h.02h
.freeze 3
.topic Int 13h Function 02h
 \i\p\aDetail\v@13h.02h.des\v\i\p                                    \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   02h

  \bTitle:\p       Read Sector

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Reads one or more sectors from disk into memory.

     \bInput\p                                  \bOutput\p

     AH = 02h                               If function successful
     AL = Number of sectors                   Carry flag: clear
     CH = Cylinder                            AH = 00h
     CL = Sector                              AL = Number of sectors
     DH = Head                                     transferred
     DL = Drive
        = 00h-7Fh floppy disk               If function unsuccessful
        = 80h-FFh fixed disk                  Carry flag: set
     ES:BX = segment:offset of buffer         AH = Status
                                                   See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.02h.des
.freeze 3
.topic Int 13h Function 02h
 \i\p\aSummary\v@13h.02h\v\i\p                                   \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     On fixed disks, the upper 2 bits of the 10-bit cylinder number are
     placed in the upper 2 bits of register CL.

     On fixed disks, error code 11h indicates that a read error
     occurred that was corrected by the ECC algorithm; in this event,
     register AL contains the burst length. The data returned is
     probably good, although there is a small chance that the data was
     not corrected properly. If a multisector transfer was requested,
     the operation was terminated after the sector containing the read
     error.

     On floppy disk drives, an error may result from the drive motor
     being off at the time of the request. The ROM BIOS does not
     automatically wait for the drive to come up to speed before
     attempting the read operation. The requesting program should reset
     the floppy disk system (Int 13h Function 00h) and retry the
     operation three times before assuming that the error results from
     some other cause.
.context @13h.03h
.freeze 3
.topic Int 13h Function 03h
 \i\p\aDetail\v@13h.03h.des\v\i\p                                    \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   03h

  \bTitle:\p       Write Sector

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Writes one or more sectors from memory to disk.

     \bInput\p                                \bOutput\p

     AH = 03h                             If function successful
     AL = Number of sectors                 Carry flag: clear
     CH = Cylinder                          AH = 00h
     CL = Sector                            AL = Number of sectors
     DH = Head                                   transferred
     DL = Drive
        = 00h-7Fh floppy disk             If function unsuccessful
        = 80h-FFh fixed disk                Carry flag: set
     ES:BX = segment:offset of buffer       AH = Status
                                                 See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.03h.des
.freeze 3
.topic Int 13h Function 03h
 \i\p\aSummary\v@13h.03h\v\i\p                                   \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     On fixed disks, the upper 2 bits of the 10-bit cylinder number are
     placed in the upper 2 bits of register CL.

     On floppy disk drives, an error may result from the drive motor
     being off at the time of the request. The ROM BIOS does not
     automatically wait for the drive to come up to speed before
     attempting the write operation. The requesting program should
     reset the floppy disk system (Int 13h Function 00h) and retry the
     operation three times before assuming that the error results from
     some other cause.
.context @13h.04h
.freeze 3
.topic Int 13h Function 04h
 \i\p\aDetail\v@13h.04h.des\v\i\p                                    \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   04h

  \bTitle:\p       Verify Sector

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Verifies the address fields of one or more sectors. No data is
     transferred to or from memory by this operation.

     \bInput\p                                \bOutput\p

     AH = 04h                             If function successful
     AL = Number of sectors                 Carry flag: clear
     CH = Cylinder                          AH = 00h
     CL = Sector                            AL = Number of sectors verified
     DH = Head
     DL = Drive                           If function unsuccessful
        = 00h-7Fh floppy disk               Carry flag: set
        = 80h-FFh fixed disk                AH = Status
     ES:BX = segment:offset of buffer            See: \aInt 13h Function 01h\v@13h.01h\v

.context @13h.04h.des
.freeze 3
.topic Int 13h Function 04h
 \i\p\aSummary\v@13h.04h\v\i\p                                   \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     On PCs, PC/XTs, and PC/ATs with ROM BIOS dated earlier than
     11/15/85, ES:BX should point to a valid buffer.

     On fixed disks, the upper 2 bits of the 10-bit cylinder number are
     placed in the upper 2 bits of register CL.

     This function can be used to test whether a readable media is in a
     floppy disk drive. An error may result from the drive motor being
     off at the time of the request, because the ROM BIOS does not
     automatically wait for the drive to come up to speed before
     attempting the verify operation. The requesting program should
     reset the floppy disk system (Int 13h Function 00h) and retry the
     operation three times before assuming that a readable floppy disk
     is not present.
.context @13h.05h
.freeze 3
.topic Int 13h Function 05h
 \i\p\aDetail\v@13h.05h.des\v\i\p                                    \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   05h

  \bTitle:\p       Format Track

  \bDescription:\p                                           [P] [AT] [PS/2]

     Initializes disk sector and track address fields on the specified
     track.

     \bInput\p                                 \bOutput\p

     AH = 05h                              If function successful
     AL = Interleave                         Carry flag: clear
          (PC/XT fixed disks)                AH = 00h
     CH = Cylinder
     DH = Head                             If function unsuccessful
     DL = Drive                              Carry flag: set
        = 00h-7Fh floppy disk                AH = Status
        = 80h-FFh fixed disk                      See: \aInt 13h Function 01h\v@13h.01h\v
     ES:BX = segment:offset of address
             field list (except PC/XT
             fixed disk)
.context @13h.05h.des
.freeze 3
.topic Int 13h Function 05h
 \i\p\aSummary\v@13h.05h\v\i\p                                   \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     On floppy disks, the address field list consists of a series of
     4-byte entries, one entry per sector, in the following format:

     \bByte\p     \bContents\p

     0        Cylinder
     1        Head
     2        Sector
     3        Sector-size code
              00h (if 128 bytes per sector)
              01h (if 256 bytes per sector)
              02h (if 512 bytes per sector (standard))
              03h (if 1,024 bytes per sector)

     On floppy disks, the number of sectors per track is taken from the
     BIOS floppy disk parameter table whose address is stored in the
     vector for Int 1Eh.

     When this function is used for floppy disks on the PC/AT or PS/2,
     it should be preceded by a call to Int 13h Function 17h to select
     the type of medium to be formatted.

     On fixed disks, the upper 2 bits of the 10-bit cylinder number are
     placed in the upper 2 bits of register CL.

     On PC/XT-286, PC/AT, and PS/2 fixed disks, ES:BX points to a
     512-byte buffer containing byte pairs for each physical disk
     sector as follows:

     \bByte\p     \bContents\p

     0        00h for good sector
              80h for bad sector
     1        sector number

     For example, to format a track with 17 sectors and an interleave
     of two, ES:BX would point to the following 34-byte array at the
     beginning of a 512-byte buffer:

       BYTE   00h,01h,00h,0ah,00h,02h,00h,0bh,00h,03h,00h,0ch
       BYTE   00h,04h,00h,0dh,00h,05h,00h,0eh,00h,06h,00h,0fh
       BYTE   00h,07h,00h,10h,00h,08h,00h,11h,00h,09h
.context @13h.06h
.context @13h.06h.des
.freeze 3
.topic Int 13h Function 06h
                                             \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   06h

  \bTitle:\p       Format Bad Track

  \bDescription:\p                                                       [PC]

     Initializes a track, writing disk address fields and data sectors
     and setting bad sector flags. This function is defined for PC/XT
     fixed disk drives only.

     \bInput\p                        \bOutput\p

     AH = 06h                     If function successful
     AL = Interleave                Carry flag: clear
     CH = Cylinder                  AH = 00h
     DH = Head
     DL = Drive                   If function unsuccessful
        = 80h-FFh fixed disk        Carry flag: set
                                    AH = Status
                                         See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.07h
.context @13h.07h.des
.freeze 3
.topic Int 13h Function 07h
                                             \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   07h

  \bTitle:\p       Format Drive

  \bDescription:\p                                                      [PC]

     Formats the entire drive, writing disk address fields and data
     sectors, starting at the specified cylinder. This function is
     defined for PC/XT fixed disk drives only.

     \bInput\p                        \bOutput\p

     AH = 07h                     If function successful
     AL = Interleave                Carry flag: clear
     CH = Cylinder                  AH = 00h
     DL = Drive
        = 80h-FFh fixed disk      If function unsuccessful
                                    Carry flag: set
                                    AH = Status
                                         See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.08h.des
.context @13h.08h
.freeze 3
.topic Int 13h Function 08h
                                             \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   08h

  \bTitle:\p       Get Drive Parameters

  \bSee also:\p    \aGet Drive Data\v@21h.1Ch\v

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Returns various parameters for the specified drive. On the PC and
     PC/XT, this function is supported on fixed disks only.

     The value returned in register DL reflects the true number of
     physical drives attached to the adapter for the requested drive.

     \bInput\p                        \bOutput\p

     AH = 08h                     If function successful
     DL = Drive                     Carry flag: clear
        = 00h-7Fh floppy disk       BL = Drive type
        = 80h-FFh fixed disk             (PC/AT and PS/2 floppy disks)
                                         01h (if 360K, 40 track, 5.25")
                                         02h (if 1.2 megabytes,
                                              80 track, 5.25")
                                         03h (if 720K, 80 track, 3.5")
                                         04h (if 1.44 megabytes,
                                              80 track, 3.5")
                                    CH = Low 8 bits of maximum cylinder
                                         number
                                    CL = Bits 6-7 High-order 2 bits of
                                                  maximum cylinder number
                                       = Bits 0-5 Maximum sector number
                                    DH = Maximum head number
                                    DL = Number of drives
                                    ES:DI = segment:offset of disk drive
                                            parameter table

                                  If function unsuccessful
                                    Carry flag: Set
                                    AH = Status
                                         See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.09h
.freeze 3
.topic Int 13h Function 09h
 \i\p\aDetail\v@13h.09h.des\v\i\p                                    \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   09h

  \bTitle:\p       Initialize Fixed Disk Characteristics

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Initializes the fixed disk controller for subsequent I/O
     operations, using the values found in the ROM BIOS disk parameter
     block(s).

     \bInput\p                                     \bOutput\p

     AH = 09h                                  If function successful
     DL = Drive                                  Carry flag: clear
        = 80h-FFh fixed disk                     AH = 00h
     And on the PC/XT                          If function unsuccessful
       Vector for Int 41h must point to          Carry flag: set
       disk parameter block                      AH = Status
     Or on the PC/AT and PS/2                         See: \aInt 13h\v@13h.01h\v
       Vector for Int 41h must point to                    \aFunction 01h\v@13h.01h\v
       disk parameter block for drive 0

       Vector for Int 46h must point to
       disk parameter block for drive 1
.context @13h.09h.des
.freeze 3
.topic Int 13h Function 09h
 \i\p\aSummary\v@13h.09h\v\i\p                                   \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function is supported on fixed disks only.

     For PC and PC/XT fixed disks, the parameter block format is as
     follows:

     \bBytes\p       \bContents\p

     00h-01h     Maximum number of cylinders
     02h         Maximum number of heads
     03h-04h     Starting reduced write current cylinder
     05h-06h     Starting write precompensation cylinder
     07h         Maximum ECC burst length
     08h         Drive options
                 Bit 7    = 1 to disable disk-access retries
                 Bit 6    = 1 to disable ECC retries
                 Bits 3-5 = 0
                 Bits 0-2 = Drive option
     09h         Standard time-out value
     0Ah         Time-out value for format drive
     0Bh         Time-out value for check drive
     0Ch-0Fh     Reserved

     For PC/AT and PS/2 fixed disks, the parameter block format is as
     follows:

     \bBytes\p       \bContents\p

     00h-01h     Maximum number of cylinders
     02h         Maximum number of heads
     03h-04h     Reserved
     05h-06h     Starting write precompensation cylinder
     07h         Maximum ECC burst length
     08h         Drive options
                 Bits 6-7 = Nonzero (10, 01, or 11) to disable retries
                 Bit 5    = 1 if manufacturer's defect map present
                            at maximum cylinder + 1
                 Bit 4    = Not used
                 Bit 3    = 1 if more than 8 heads
                 Bits 0-2 = Not used
     09h-0Bh     Reserved
     0Ch-0Dh     Landing zone cylinder
     0Eh         Sectors per track
     0Fh         Reserved
.context @13h.0Ah
.freeze 3
.topic Int 13h Function 0Ah
 \i\p\aDetail\v@13h.0Ah.des\v\i\p                                    \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   0Ah

  \bTitle:\p       Read Sector Long

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Reads a sector or sectors from disk into memory, along with a
     4-byte ECC code for each sector.

     \bInput\p                                \bOutput\p

     AH = 0Ah                             If function successful
     AL = Number of sectors                 Carry flag: clear
     CH = Cylinder                          AH = 00h
     CL = Sector                            AL = Number of sectors
     DH = Head                                   transferred
     DL = Drive
        = 80h-FFh fixed disk              If function unsuccessful
     ES:BX = segment:offset of buffer       Carry flag: set
                                            AH = Status
                                                 See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.0Ah.des
.freeze 3
.topic Int 13h Function 0Ah
 \i\p\aSummary\v@13h.0Ah\v\i\p                                   \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function is supported on fixed disks only.

     The upper 2 bits of the 10-bit cylinder number are placed in the
     upper 2 bits of register CL.

     Unlike the normal Read Sector function (Int 13h Function 02h), ECC
     errors are not automatically corrected. Multisector transfers are
     terminated after any sector with a read error.
.context @13h.0Bh.des
.context @13h.0Bh
.freeze 3
.topic Int 13h Function 0Bh
                                               \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   0Bh

  \bTitle:\p       Write Sector Long

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Writes a sector or sectors from memory to disk. Each sector's
     worth of data must be followed by its 4-byte ECC code. This
     function is supported on fixed disks only.

     The upper 2 bits of the 10-bit cylinder number are placed in the
     upper 2 bits of register CL.

     \bInput\p                                \bOutput\p

     AH = 0Bh                             If function successful
     AL = Number of sectors                 Carry flag: clear
     CH = Cylinder                          AH = 00h
     CL = Sector                            AL = Number of sectors
     DH = Head                                   transferred
     DL = Drive
        = 80h-FFh fixed disk              If function unsuccessful
     ES:BX = segment:offset of buffer       Carry flag: set
                                            AH = Status
                                                 See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.0Ch
.freeze 3
.topic Int 13h Function 0Ch
 \i\p\aDetail\v@13h.0Ch.des\v\i\p                                    \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   0Ch

  \bTitle:\p       Seek

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Positions the disk read/write heads to the specified cylinder, but
     does not transfer any data.

     \bInput\p                             \bOutput\p

     AH = 0Ch                          If function successful
     CH = Lower 8 bits of cylinder       Carry flag: clear
     CL = Upper 2 bits of cylinder       AH = 00h
          in bits 6-7
     DH = Head                         If function unsuccessful
     DL = Drive                          Carry flag: set
        = 80h-FFh fixed disk             AH = Status
                                              See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.0Ch.des
.freeze 3
.topic Int 13h Function 0Ch
 \i\p\aSummary\v@13h.0Ch\v\i\p                                   \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function is supported on fixed disks only.

     The upper 2 bits of the 10-bit cylinder number are placed in the
     upper 2 bits of register CL.

     The Read Sector, Read Sector Long, Write Sector, and Write Sector
     Long functions include an implied seek operation and need not be
     preceded by an explicit call to this function.
.context @13h.0Dh.des
.context @13h.0Dh
.freeze 3
.topic Int 13h Function 0Dh
                                             \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   0Dh

  \bTitle:\p       Reset Fixed Disk System

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Resets the fixed disk controller, recalibrates attached drives
     (moves the read/write arm to cylinder 0), and prepares for
     subsequent disk I/O. This function is supported on fixed disks
     only. It differs from Int 13h Function 00h in that the floppy disk
     controller is not reset.

     \bInput\p                           \bOutput\p

     AH = 0Dh                        If function successful
     DL = Drive                        Carry flag: clear
        = 80h-FFh fixed disk           AH = 00h

                                     If function unsuccessful
                                       Carry flag: set
                                       AH = Status
                                            See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.0Eh
.context @13h.0Eh.des
.freeze 3
.topic Int 13h Function 0Eh
                                             \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   0Eh

  \bTitle:\p       Read Sector Buffer

  \bDescription:\p                                                      [PC]

     Transfers the contents of the fixed disk adapter's internal sector
     buffer to system memory. No data is read from the physical disk
     drive. This function is supported by the PC/XT's fixed disk
     adapter only. It is not defined for fixed disk adapter on the
     PC/AT or PS/2.

     \bInput\p                                \bOutput\p

     AH = 0Eh                             If function successful
     ES:BX = segment:offset of buffer       Carry flag: clear

                                          If function unsuccessful
                                            Carry flag: set
                                            AH = Status
                                                 See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.0Fh
.freeze 3
.topic Int 13h Function 0Fh
 \i\p\aDetail\v@13h.0Fh.des\v\i\p                                    \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   0Fh

  \bTitle:\p       Write Sector Buffer

  \bDescription:\p                                                      [PC]

     Transfers data from system memory to the fixed disk adapter's
     internal sector buffer. No data is written to the physical disk
     drive.

     \bInput\p                                \bOutput\p

     AH = 0Fh                             If function successful
     ES:BX = segment:offset of buffer       Carry flag: clear

                                          If function unsuccessful
                                            Carry flag: set
                                            AH = Status
                                                 See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.0Fh.des
.freeze 3
.topic Int 13h Function 0Fh
 \i\p\aSummary\v@13h.0Fh\v\i\p                                   \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function is supported by the PC/XT's fixed disk adapter only.
     It is not defined for fixed disk adapters on the PC/AT or PS/2.

     This function should be called to initialize the contents of the
     sector buffer before formatting the drive with Int 13h Function
     05h.
.context @13h.10h.des
.context @13h.10h
.freeze 3
.topic Int 13h Function 10h
                                             \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   10h

  \bTitle:\p       Get Drive Status

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Tests whether the specified fixed disk drive is operational and
     returns the drive's status. This function is supported on fixed
     disks only.

     \bInput\p                           \bOutput\p

     AH = 10h                        If function successful
     DL = Drive                        Carry flag: clear
        = 80h-FFh fixed disk           AH = 00h

                                     If function unsuccessful
                                       Carry flag: set
                                       AH = Status
                                            See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.11h.des
.context @13h.11h
.freeze 3
.topic Int 13h Function 11h
                                             \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p 11h

  \bTitle:\p       Recalibrate Drive

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Causes the fixed disk adapter to recalibrate itself for the
     specified drive, positioning the read/arm to cylinder 0, and
     returns the drive's status. This function is supported on fixed
     disks only.

     \bInput\p                           \bOutput\p

     AH = 11h                        If function successful
     DL = Drive                        Carry flag: clear
        = 80h-FFh fixed disk           AH = 00h

                                     If function unsuccessful
                                       Carry flag: set
                                       AH = Status
                                            See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.12h
.context @13h.12h.des
.freeze 3
.topic Int 13h Function 12h
                                             \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   12h

  \bTitle:\p       Controller RAM Diagnostic

  \bDescription:\p                                                      [PC]

     Causes the fixed disk adapter to carry out a built-in diagnostic
     test on its internal sector buffer, indicating whether the test
     was passed by the returned status. This function is supported on
     PC/XT fixed disks only.

     \bInput\p        \bOutput\p

     AH = 12h     If function successful
                    Carry flag: clear

                  If function unsuccessful
                    Carry flag: set
                    AH = Status
                         See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.13h
.context @13h.13h.des
.freeze 3
.topic Int 13h Function 13h
                                             \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   13h

  \bTitle:\p       Controller Drive Diagnostic

  \bDescription:\p                                                      [PC]

     Causes the fixed disk adapter to run internal diagnostic tests of
     the attached drive, indicating whether the test was passed by the
     returned status. This function is supported on PC/XT fixed disks
     only.

     \bInput\p        \bOutput\p

     AH = 13h     If function successful
                    Carry flag: clear

                  If function unsuccessful
                    Carry flag: set
                    AH = Status
                         See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.14h
.context @13h.14h.des
.freeze 3
.topic Int 13h Function 14h
                                             \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   14h

  \bTitle:\p       Controller Internal Diagnostic

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Causes the fixed-disk adapter to carry out a built-in diagnostic
     self-test, indicating whether the test was passed by the returned
     status. This function is supported on fixed disks only.

     \bInput\p        \bOutput\p

     AH = 14h     If function successful
                    Carry flag: clear
                    AH = 00h

                  If function unsuccessful
                    Carry flag: set
                    AH = Status
                         See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.15h
.context @13h.15h.des
.freeze 3
.topic Int 13h Function 15h
                                             \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   15h

  \bTitle:\p       Get Disk Type

  \bDescription:\p                                               [AT] [PS/2]

     Returns a code indicating the type of floppy or fixed disk
     referenced by the specified drive code. This function is not
     supported on the PC or PC/XT.

     \bInput\p                            \bOutput\p

     AH = 15h                         If function successful
     DL = Drive                         Carry flag: clear
        = 00h-7Fh floppy disk           AH = Drive type code
        = 80h-FFh fixed disk               = 00h (if no drive present)
                                           = 01h (if floppy disk drive
                                                  without change-line
                                                  support)
                                           = 02h (if floppy disk drive
                                                  with change-line
                                                  support)
                                           = 03h (if fixed disk)
                                      And if fixed disk (AH = 03h)
                                        CX:DX = number of 512-byte sectors

                                      If function unsuccessful
                                        Carry flag: set
                                        AH = Status
                                             See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.16h
.freeze 3
.topic Int 13h Function 16h
 \i\p\aDetail\v@13h.16h.des\v\i\p                                    \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   16h

  \bTitle:\p       Get Disk Change Status

  \bDescription:\p                                               [AT] [PS/2]

     Returns the status of the change line, indicating whether the disk
     in the drive may have been replaced since the last disk access.

     \bInput\p                            \bOutput\p

     AH = 16h                         If change line inactive
     DL = Drive                       (disk has not been changed)
        = 00h-7Fh floppy disk           Carry flag: clear
                                        AH = 00h

                                      If change line active
                                      (disk may have been changed)
                                        Carry flag: set
                                        AH = 06h
.context @13h.16h.des
.freeze 3
.topic Int 13h Function 16h
 \i\p\aSummary\v@13h.16h\v\i\p                                   \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     If this function returns with the carry flag set, the disk has not
     necessarily been changed; the change line can be activated by
     simply unlocking and locking the disk drive door without removing
     the floppy disk.

     This function is not supported for floppy disks on the PC or
     PC/XT.

.context @13h.17h
.freeze 3
.topic Int 13h Function 17h
 \i\p\aDetail\v@13h.17h.des\v\i\p                                    \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   17h

  \bTitle:\p       Set Disk Type

  \bDescription:\p                                               [AT] [PS/2]

     Selects a floppy disk type for the specified drive.

     \bInput\p                                 \bOutput\p

     AH = 17h                              If function successful
     AL = Floppy disk type code              Carry flag: clear
        = 00h (not used)                     AH = 00h
        = 01h (320/360K floppy disk
              in 360K drive)               If function unsuccessful
        = 02h (320/360K floppy disk          Carry flag: set
              in 1.2 megabyte drive          AH = Status
        = 03h (1.2 megabyte floppy disk           See: \aInt 13h\v@13h.01h\v
              in 1.2 megabyte drive)                   \aFunction 01h\v@13h.01h\v
        = 04h (720K floppy disk
              in 720K drive)
     DL = Drive
        = 00h-7Fh floppy disk
.context @13h.17h.des
.freeze 3
.topic Int 13h Function 17h
 \i\p\aSummary\v@13h.17h\v\i\p                                   \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function is not supported for floppy disks on the PC or
     PC/XT.

     If the change line is active for the specified drive, it is reset.
     The ROM BIOS then sets the data rate for the specified drive and
     media type.
.context @13h.18h
.freeze 3
.topic Int 13h Function 18h
 \i\p\aDetail\v@13h.18h.des\v\i\p                                    \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   18h

  \bTitle:\p       Set Media Type for Format

  \bDescription:\p                                               [AT] [PS/2]

     Selects media characteristics for the specified drive.

     \bInput\p                            \bOutput\p

     AH = 18h                         If function successful
     CH = Number of cylinders           Carry flag: clear
     CL = Sectors per track             AH = 00h
     DL = Drive                         ES:DI = segment:offset of disk
        = 00h-7Fh floppy disk                   parameter table for
                                                media type

                                      If function unsuccessful
                                        Carry flag: set
                                        AH = Status
                                             See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.18h.des
.freeze 3
.topic Int 13h Function 18h
 \i\p\aSummary\v@13h.18h\v\i\p                                   \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     A floppy disk must be present in the drive.

     This function should be called prior to formatting a disk with Int
     13h Function 05h so that the ROM BIOS can set the correct data
     rate for the media.

     If the change line is active for the specified drive, it is reset.
.context @13h.19h
.context @13h.19h.des
.freeze 3
.topic Int 13h Function 19h
                                             \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   19h

  \bTitle:\p       Park Heads

  \bDescription:\p                                                    [PS/2]

     Moves the read/write arm to a track that is not used for data
     storage, so that data will not be damaged when the drive is turned
     off. This function is defined for PS/2 fixed disks only.

     \bInput\p                           \bOutput\p

     AH = 19h                        If function successful
     DL = Drive                        Carry flag: clear
        = 80h-FFh fixed disk
                                     If function unsuccessful
                                       Carry flag: set
                                       AH = Status
                                            See: \aInt 13h Function 01h\v@13h.01h\v
.context @13h.1Ah
.freeze 3
.topic Int 13h Function 1Ah
 \i\p\aDetail\v@13h.1Ah.des\v\i\p                                    \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   13h     \bFunction:\p   1Ah

  \bTitle:\p       Format ESDI Drive

  \bSee also:\p    \aFormat ESDI Drive Periodic Interrupt\v@15h.0Fh\v

  \bDescription:\p                                                    [PS/2]

     Initializes disk sector and track address fields on a drive
     attached to the ESDI Fixed Disk Drive Adapter/A.

     \bInput\p                             \bOutput\p

     AH = 1Ah                          If function successful
     AL = Relative block address         Carry flag: clear
          (RBA) defect table count       AH = 00h
        = 0 (if no RBA table)
        = >0 (if RBA table used)       If function unsuccessful
     CL = Format modifier bits           Carry flag: set
                                         AH = Status
                                              See: \aInt 13h Function 01h\v@13h.01h\v
          \bBits\p   \bSignificance (if set)\p

          0      Ignore primary
                 defect map
          1      Ignore secondary
                 defect map
          2      Update secondary
                 defect map
          3      Perform extended
                 surface analysis
          4      Generate periodic
                 interrupt
          5-7    Reserved (must be 0)

     DL = Drive
        = 80h-FFh fixed disk
     ES:BX = segment:offset of RBA table
.context @13h.1Ah.des
.freeze 3
.topic Int 13h Function 1Ah
 \i\p\aSummary\v@13h.1Ah\v\i\p                                   \i\p\aUp\v@13h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This operation is sometimes called a "low-level format" and
     prepares the disk for physical read/write operations at the sector
     level. The drive must be subsequently partitioned with the FDISK
     command and then given a "high-level format" with the FORMAT
     command to install a file system.

     If bit 4 of register CL is set, Int 15h is called with AH = 0Fh
     and AL = phase code after each cylinder is formatted or analyzed.
     The phase code is defined as follows: 0 = Reserved, 1 = Surface
     analysis, 2 = Formatting.

     If bit 2 of register CL is set, the drive's secondary defect map
     is updated to reflect errors found during surface analysis. If
     both bit 2 and bit 1 are set, the secondary defect map is
     replaced.

     For an extended surface analysis, the disk should first be
     formatted by calling this function with bit 3 cleared and then
     analyzed by calling this function with bit 3 set.
.context @14h
.context 14h
.context 014h
.context 20
..index COM port interrupts, Int 14h
..index Int 14h functions, COM Port Interrupts
.freeze 3
.topic Int 14h
                                             \i\p\aUp\v@BIOSCalls\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   14h

  \bTitle:\p       COM Port Interrupts

  \bSee also:\p    \aParallel and Serial Polling\v@MiscMem\v

  \bFunction\p     \bName\p

  \a00h          Initialize Communications Port\v@14h.00h\v
  \a01h          Write Character to Communications Port\v@14h.01h\v
  \a02h          Read Character from Communications Port\v@14h.02h\v
  \a03h          Get Communications Port Status\v@14h.03h\v
  \a04h          Extended Initialize Communications Port\v@14h.04h\v
  \a05h          Extended Communications Port Control\v@14h.05h\v
.context @14h.00h
.freeze 3
.topic Int 14h Function 00h
 \i\p\aDetail\v@14h.00h.des\v\i\p                                    \i\p\aUp\v@14h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   14h     \bFunction:\p   00h

  \bTitle:\p       Initialize Communications Port

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Initializes a serial communications port to a desired baud rate,
     parity, word length, and number of stop bits.

     \bInput\p                        \bOutput\p

     AH = 00h                     AH = Port status
     AL = Initialization
          parameter               \bBits\p   \bSignificance (if set)\p
     DX = Communications
          port number             7      Timed-out
          (0 = COM1,              6      Transmit shift
          1 = COM2,...)                  Register empty
                                  5      Transmit holding
                                         Register empty
                                  4      Break detected
                                  3      Framing error detected
                                  2      Parity error detected
                                  1      Overrun error detected
                                  0      Receive data ready

                                  AL = Modem status

                                  \bBits\p   \bSignificance (if set)\p

                                  7      Receive line signal
                                         detect
                                  6      Ring indicator
                                  5      Data-set-ready
                                  4      Clear-to-send
                                  3      Change in receive line
                                         signal detect
                                  2      Trailing edge ring
                                         indicator
                                  1      Change in
                                         data-set-ready status
                                  0      Change in
                                         clear-to-send status
.context @14h.00h.des
.freeze 3
.topic Int 14h Function 00h
 \i\p\aSummary\v@14h.00h\v\i\p                                   \i\p\aUp\v@14h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The initialization parameter byte is defined as follows:

     \b7 6 5\p           \b4 3\p           \b2\p               \b1 0\p
     \bBaud Rate\p       \bParity\p        \bStop Bits\p       \bWord Length\p

     000 = 110       X0 = None     0 = 1 bit       10 = 7 bits
     001 = 150       01 = Odd      1 = 2 bits      11 = 8 bits
     010 = 300       11 = Even
     011 = 600
     100 = 1200
     101 = 2400
     110 = 4800
     111 = 9600

     To initialize the serial port for data rates greater than 9600
     baud on PS/2 machines, see Int 14h Functions 04h and 05h.
.context @14h.01h
.freeze 3
.topic Int 14h Function 01h
                                             \i\p\aUp\v@14h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   14h     \bFunction:\p   01h

  \bTitle:\p       Write Character to Communications Port

  \bSee also:\p    \aAuxiliary Output\v@21h.04h\v

  \bDescription:\p                                          [PC] [AT] [PS/2]


     Writes a character to the specified serial communications port,
     returning the current status of the port.

     \bInput\p                               \bOutput\p

     AH = 01h                            If function successful
     AL = Character                        AH bit 7 = 0
     DX = Communications port              AH bits 0-6 = Port status
          number (0 = COM1,
          1 = COM2,...)                    \bBits\p   \bSignificance (if set)\p

                                           6      Transmit shift
                                                  register empty
                                           5      Transmit holding
                                                  register empty
                                           4      Break detected
                                           3      Framing error
                                                  detected
                                           2      Parity error detected
                                           1      Overrun error
                                                  detected
                                           0      Receive data ready

                                           AL = Character (unchanged)

                                         If function unsuccessful
                                         (timed-out)
                                           AH bit 7 = 1
                                           AL = Character (unchanged)
.context @14h.02h
.freeze 3
.topic Int 14h Function 02h
                                            \i\p\aUp\v@14h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   14h     \bFunction:\p   02h

  \bTitle:\p       Read Character from Communications Port

  \bSee also:\p    \aAuxiliary Input\v@21h.03h\v

  \bDescription:\p                                          [PC] [AT] [PS/2]


     Reads a character from the specific serial communications port,
     and also returns the port's status.

     \bInput\p                               \bOutput\p

     AH = 02h                            If function successful
     DX = Communications port              AH bit 7 = 0
          number (0 = COM1,                AH bits 0-6 = Status
          1 = COM2,...)
                                           \bBits\p   \bSignificance (if set)\p

                                           4      Break detected
                                           3      Framing error detected
                                           2      Parity error detected
                                           1      Overrun error detected

                                           AL = Character

                                         If function unsuccessful
                                         (timed-out)
                                           AH bit 7 = 1
.context @14h.03h
.freeze 3
.topic Int 14h Function 03h
                                             \i\p\aUp\v@14h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   14h     \bFunction:\p   03h

  \bTitle:\p       Get Communications Port Status

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Returns the status of the specified serial communications port.

     \bInput\p                               \bOutput\p

     AH = 03h                            AH = Port status
     DX = Communications port number          See: \aInt 14h Function 00h\v@14h.00h\v
          (0 = COM1, 1 = COM2,...)       AL = Modem status
                                              See: \aInt 14h Function 00h\v@14h.00h\v

.context @14h.04h
.freeze 3
.topic Int 14h Function 04h
                                             \i\p\aUp\v@14h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   14h     \bFunction:\p   04h

  \bTitle:\p       Extended Initialize Communications Port

  \bDescription:\p                                                      [PS/2]

     Initializes a serial communications port to a desired baud rate,
     parity, word length, and number of stop bits. Provides a superset
     of Int 14h Function 00h capabilities for PS/2 machines.

     \bInput\p                                   \bOutput\p

     AH = 04h                                AH = Port status
     AL = Break flag                              See: \aInt 14h Function 00h\v@14h.00h\v
        = 00h     No break                   AL = Modem status
        = 01h     Break                           See: \aInt 14h Function 00h\v@14h.00h\v
     BH = Parity
        = 00h     None
        = 01h     Odd
        = 02h     Even
        = 03h     Stick parity odd
        = 04h     Stick parity even
     BL = Stop bits
        = 00h     1 stop bit
        = 01h     2 stop bits if
                  word length = 6-8 bits
        = 01h     1.5 stop bits if
                  word length = 5 bits
     CH = Word length
        = 00h     5 bits
        = 01h     6 bits
        = 02h     7 bits
        = 03h     8 bits
     CL = Baud rate
        = 00h     110 baud
        = 01h     150 baud
        = 02h     300 baud
        = 03h     600 baud
        = 04h     1200 baud
        = 05h     2400 baud
        = 06h     4800 baud
        = 07h     9600 baud
        = 08h     19,200 baud
     DX = Communications port number
          (0 = COM1, 1 = COM2,...)
.context @14h.05h
.freeze 3
.topic Int 14h Function 05h
                                             \i\p\aUp\v@14h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   14h     \bFunction:\p   05h

  \bTitle:\p       Extended Communications Port Control

  \bDescription:\p                                                    [PS/2]

     Reads or sets the modem control register (MCR) for the specified
     serial communications port.

     \bInput\p                             \bOutput\p

     AH = 05h                          If called with AL = 00h
     AL = Subfunction                    BL = Modem control register
        = 00h Read modem                      contents
              control register
        = 01h Write modem              If called with AL = 01h
              control register           AH = Port status
     BL = Modem control register              See: \aInt 14h Function 00h\v@14h.00h\v
          contents (if AL = 01h)         AL = Modem status
                                              See: \aInt 14h Function 00h\v@14h.00h\v
          \bBits\p     \bSignificance\p

          0        Data-terminal ready
          1        Request-to-send
          2        Out1
          3        Out2
          4        Loop (for testing)
          5-7      Reserved

     DX = Communications port number
          (0 = COM1, 1 = COM2,...)
.context @15h
.context 15h
.context 015h
.context 21
..index I/O subsystem interrupts, Int 15h
..index Int 15h functions, I/O Subsystem Interrupts
.freeze 3
.topic Int 15h
                                             \i\p\aUp\v@BIOSCalls\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h

  \bTitle:\p       I/O Subsystem Interrupts

  \bFunction\p     \bName\p

  \a00h          Turn On Cassette Motor\v@15h.00h\v
  \a01h          Turn Off Cassette Motor\v@15h.01h\v
  \a02h          Read Cassette\v@15h.02h\v
  \a03h          Write Cassette\v@15h.03h\v
  \a0Fh          Format ESDI Drive Periodic Interrupt\v@15h.0Fh\v
  \a21h          Read/Write POST Error Log\v@15h.21h.00h\v
  \a4Fh          Keyboard Intercept\v@15h.4Fh\v
  \a80h          Device Open\v@15h.80h\v
  \a81h          Device Close\v@15h.81h\v
  \a82h          Process Termination\v@15h.82h\v
  \a83h          Event Wait\v@15h.83h\v
  \a84h          Read Joystick\v@15h.84h\v
  \a85h          SysReq Key\v@15h.85h\v
  \a86h          Delay\v@15h.86h\v
  \a87h          Move Extended Memory Block\v@15h.87h\v
  \a88h          Get Extended Memory Size\v@15h.88h\v
  \a89h          Enter Protected Mode\v@15h.89h\v
  \a90h          Device Wait\v@15h.90h\v
  \a91h          Device Post\v@15h.91h\v
  \aC0h          Get System Environment\v@15h.C0h\v
  \aC1h          Get Address of Extended BIOS Data Area\v@15h.C1h\v
  \aC2h          Mouse Pointer\v@15h.C2h\v
  \aC3h          Set Watchdog Time-Out\v@15h.C3h\v
  \aC4h          Programmable Option Select\v@15h.C4h\v
.context @15h.00h
.context @15h.00h.des
.freeze 3
.topic Int 15h Function 00h
                                             \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   00h

  \bTitle:\p       Turn On Cassette Motor

  \bDescription:\p                                                      [PC]

     Turns on the motor of the cassette tape drive. This function is
     available only on the PC and the PCjr. It is not supported on the
     PC/XT and all subsequent models.

     \bInput\p        \bOutput\p

     AH = 00h     If function successful
                    Carry flag: clear

                  If function unsuccessful
                    Carry flag: set
                    AH = Status (86h if cassette not present)
.context @15h.01h
.context @15h.01h.des
.freeze 3
.topic Int 15h Function 01h
                                             \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   01h

  \bTitle:\p       Turn Off Cassette Motor

  \bDescription:\p                                                      [PC]

     Turns off the motor of the cassette tape drive. This function is
     available only on the PC and the PCjr. It is not supported on the
     PC/XT and all subsequent models.

     \bInput\p        \bOutput\p

     AH = 01h     If function successful
                    Carry flag: clear

                  If function unsuccessful
                    Carry flag: set
                    AH = Status (86h if cassette not present)
.context @15h.02h
.context @15h.02h.des
.freeze 3
.topic Int 15h Function 02h
                                             \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   02h

  \bTitle:\p       Read Cassette

  \bDescription:\p                                                      [PC]

     Reads one or more 256-byte blocks of data from the cassette tape
     drive to memory. This function is available only on the PC and
     the PCjr. It is not supported on the PC/XT and all subsequent
     models.

     \bInput\p                                \bOutput\p

     AH = 02h                             If function successful
     CX = Number of bytes to read           Carry flag: clear
     ES:BX = segment:offset of buffer       DX = Number of bytes
                                                 actually read
                                            ES:BX = segment:offset + 1
                                                    of last byte read

                                          If function unsuccessful
                                            Carry flag: set
                                            AH = Status
                                               = 01h (if CRC error)
                                               = 02h (if bit signals
                                                     scrambled)
                                               = 04h (if no data
                                                     found)
                                               = 80h (if invalid
                                                     command)
                                               = 86h (if cassette
                                                     not present)
.context @15h.03h
.context @15h.03h.des
.freeze 3
.topic Int 15h Function 03h
                                             \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   03h

  \bTitle:\p       Write Cassette

  \bDescription:\p                                                      [PC]

     Writes one or more 256-byte blocks of data from memory to the
     cassette tape drive. This function is available only on the PC
     and the PCjr. It is not supported on the PC/XT and all subsequent
     models.

     \bInput\p                                \bOutput\p

     AH = 03h                             If function successful
     CX = Number of bytes to write          Carry flag: clear
     ES:BX = segment:offset of buffer       CX = 00h
                                            ES:BX = segment:offset + 1 of
                                                    last byte written

                                          If function unsuccessful
                                            Carry flag: set
                                            AH = Status
                                               = 80h (if invalid command)
                                               = 86h (if cassette not
                                                     present)
.context @15h.0Fh
.freeze 3
.topic Int 15h Function 0Fh
 \i\p\aDetail\v@15h.0Fh.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   0Fh

  \bTitle:\p       Format ESDI Drive Periodic Interrupt

  \bDescription:\p                                                    [PS/2]

     Invoked by the ROM BIOS on the ESDI Fixed Disk Drive Adapter/A
     during a format or surface analysis operation after each cylinder
     is completed.

     \bInput\p                         \bOutput\p

     AH = 0Fh                      If formatting or analysis should
     AL = Phase code               continue
          0 = Reserved               Carry flag: clear
          1 = Surface analysis
          2 = Formatting           If formatting or analysis should
                                   be terminated
                                     Carry flag: set
.context @15h.0Fh.des
.freeze 3
.topic Int 15h Function 0Fh
 \i\p\aSummary\v@15h.0Fh\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function call can be captured by a program so that it will be
     notified as each cylinder is formatted or analyzed. The program
     can count interrupts for each phase to determine the current
     cylinder number.

     The ROM BIOS default handler for this function returns with the
     carry flag set.
.context @15h.21h.00h
.context @15h.21h.00h.des
.freeze 3
.topic Int 15h Function 21h Subfunction 00h
                                             \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   21h     \bSubfunction:\p   00h

  \bTitle:\p       Read POST Error Log

  \bSee also:\p    \aWrite POST Error Log\v@15h.21h.01h\v

  \bDescription:\p                                                    [PS/2]

     Returns error information that was accumulated during the most
     recent power-on self-test (POST). The error log consists of
     single-word entries. The first byte of an entry is the device
     error code; the second is the device identifier.

     This function is not available on the PS/2 Models 25 and 30.

     \bInput\p        \bOutput\p

     AH = 21h     If function successful
     AL = 00h       Carry flag: clear
                    AH = 00h
                    BX = Number of POST error codes stored
                    ES:DI = segment:offset of POST error log

                  If function unsuccessful
                    Carry flag: set
                    AH = Status
                         80h = Invalid command
                         86h = Function not supported
.context @15h.21h.01h
.context @15h.21h.01h.des
.freeze 3
.topic Int 15h Function 21h Subfunction 01h
                                             \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   21h     \bSubfunction:\p   01h

  \bTitle:\p       Write POST Error Log

  \bSee also:\p    \aRead POST Error Log\v@15h.21h.00h\v

  \bDescription:\p                                                    [PS/2]

     Adds an entry to the power-on self-test (POST) error log. This
     function is not available on the PS/2 Models 25 and 30.

     \bInput\p                      \bOutput\p

     AH = 21h                   If function successful
     AL = 01h                     Carry flag: clear
     BH = Device identifier       AH = 00h
     BL = Device error code
                                If function unsuccessful
                                  Carry flag: set
                                  AH = Status
                                       01h = Error list full
                                       80h = Invalid command
                                       86h = Function not supported
.context @15h.4Fh
.freeze 3
.topic Int 15h Function 4Fh
 \i\p\aDetail\v@15h.4Fh.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   4Fh

  \bTitle:\p       Keyboard Intercept

  \bSee also:\p    \aKeyboard I/O\v@9h\v, \aKeyboard Interrupts\v@16h\v, \aKey Scan Chart\v@KeyChart101\v,
               \aExtended Key Codes\v@XKeyChart\v, \aKeyboard Data Memory\v@Keydata\v

  \bDescription:\p                                                    [PS/2]

     Invoked for each keystroke by the ROM BIOS's Int 09h keyboard
     interrupt handler.

     \bInput\p              \bOutput\p

     AH = 4Fh           If scan code consumed
     AL = Scan code       Carry flag: clear

                        If scan code not consumed
                          Carry flag: set
                          AL = Unchanged or new scan code

.context @15h.4Fh.des
.freeze 3
.topic Int 15h Function 4Fh
 \i\p\aSummary\v@15h.4Fh\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     An operating system or a resident utility can capture this
     function to filter the raw keyboard data stream. The new handler
     can substitute a new scan code, return the same scan code, or
     return the carry flag clear, causing the keystroke to be discarded.
     The ROM BIOS default routine simply returns the scan code
     unchanged.

     A program can call Int 15h Function C0h to determine whether the
     host machine's ROM BIOS supports this keyboard intercept.
.context @15h.80h
.freeze 3
.topic Int 15h Function 80h
 \i\p\aDetail\v@15h.80h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   80h

  \bTitle:\p       Device Open

  \bSee also:\p    \aDevice Close\v@15h.81h\v

  \bDescription:\p                                               [AT] [PS/2]

     Acquires ownership of a logical device for a process.

     \bInput\p               \bOutput\p

     AH = 80h            If function successful
     BX = Device ID        Carry flag: clear
     CX = Process ID       AH = 00h

                         If function unsuccessful
                           Carry flag: set
                           AH = Status
.context @15h.80h.des
.freeze 3
.topic Int 15h Function 80h
 \i\p\aSummary\v@15h.80h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function call, along with Int 15h Functions 81h and 82h,
     defines a simple protocol that can be used to arbitrate use of
     devices by multiple processes. A multitasking program manager
     would be expected to capture Int 15h and provide the appropriate
     service. The default BIOS routine for this function simply returns
     with the carry flag clear and AH = 00h.
.context @15h.81h
.freeze 3
.topic Int 15h Function 81h
 \i\p\aDetail\v@15h.81h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   81h

  \bTitle:\p       Device Close

  \bSee also:\p    \aDevice Open\v@15h.80h\v, \aProcess Termination\v@15h.82h\v

  \bDescription:\p                                               [AT] [PS/2]

     Releases ownership of a logical device for a process.

     \bInput\p               \bOutput\p

     AH = 81h            If function successful
     BX = Device ID        Carry flag: clear
     CX = Process ID       AH = 00h

                         If function unsuccessful
                           Carry flag: set
                           AH = Status
.context @15h.81h.des
.freeze 3
.topic Int 15h Function 81h
 \i\p\aSummary\v@15h.81h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     A multitasking program manager would be expected to capture Int
     15h and provide the appropriate service. The ROM BIOS default
     routine for this function simply returns with the carry flag clear
     and AH = 00h.
.context @15h.82h
.freeze 3
.topic Int 15h Function 82h
 \i\p\aDetail\v@15h.82h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   82h

  \bTitle:\p       Process Termination

  \bSee also:\p    \aDevice Open\v@15h.80h\v, \aDevice Close\v@15h.81h\v

  \bDescription:\p                                               [AT] [PS/2]

     Releases ownership of all logical devices for a process that is
     about to terminate.

     \bInput\p               \bOutput\p

     AH = 82h            If function successful
     BX = Process ID       Carry flag: clear
                           AH = 00h

                         If function unsuccessful
                           Carry flag: set
                           AH = Status
.context @15h.82h.des
.freeze 3
.topic Int 15h Function 82h
 \i\p\aSummary\v@15h.82h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     A multitasking program manager would be expected to capture Int
     15h and provide the appropriate service. The ROM BIOS default
     routine for this function simply returns with the carry flag clear
     and AH = 00h.
.context @15h.83h
.freeze 3
.topic Int 15h Function 83h
 \i\p\aDetail\v@15h.83h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   83h

  \bTitle:\p       Event Wait

  \bSee also:\p    \aDelay\v@15h.86h\v

  \bDescription:\p                                               [AT] [PS/2]

     Requests setting of a semaphore after a specified interval or
     cancels a previous request.

     \bInput\p                          \bOutput\p

     If requesting event wait        If called with AL = 00h
       AH = 83h                      and function successful
       AL = 00h                        Carry flag: clear
       CX:DX = Microseconds
       ES:BX = segment:offset of     If called with AL = 00h and
               semaphore byte        function unsuccessful (Event Wait
                                     already active)
     If canceling event wait           Carry flag: set
       AH = 83h
       AL = 01h                      If called with AL = 01h
                                       None
.context @15h.83h.des
.freeze 3
.topic Int 15h Function 83h
 \i\p\aSummary\v@15h.83h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The function call returns immediately. If the function is
     successful, bit 7 of the semaphore byte is set when the specified
     interval has elapsed. The calling program is responsible for
     clearing the semaphore before requesting this function.

     The actual duration of an event wait is always an integral
     multiple of 976 microseconds. The CMOS date/clock chip interrupts
     are used to implement this function.

     Use of this function allows programmed, hardware-independent
     delays at a finer resolution than can be obtained through use of
     the MS-DOS Get Time function (Int 21h Function 2Ch) which returns
     time in hundredths of a second.

     This function is not supported on the PS/2 Models 25 and 30.
.context @15h.84h
.freeze 3
.topic Int 15h Function 84h
 \i\p\aDetail\v@15h.84h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h      \bFunction:\p   84h

  \bTitle:\p       Read Joystick

  \bDescription:\p                                               [AT] [PS/2]

     Returns the joystick switch settings and potentiometer values.

     \bInput\p                              \bOutput\p

     AH = 84h                           If function successful
     DX = Subfunction                     Carry flag: clear
        = 00h Read switch settings      And if called with DX = 00h
        = 01h Read resistive inputs       AL = Switch settings (bits 4-7)
                                        Or if called with DX = 01h
                                          AX = A(x) value
                                          BX = A(y) value
                                          CX = B(x) value
                                          DX = B(y) value

                                        If function unsuccessful
                                          Carry flag: set
.context @15h.84h.des
.freeze 3
.topic Int 15h Function 84h
 \i\p\aSummary\v@15h.84h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     An error condition is returned if DX does not contain a valid
     subfunction number.

     If no game adapter is installed, AL is returned as 00h for
     Subfunction 00h (all switches open); AX, BX, CX, and DX are
     returned containing 00h for Subfunction 01h.

     Using a 250K Ohm joystick, the potentiometer values usually lie
     within the range 0-416 (0000-01A0h).
.context @15h.85h
.freeze 3
.topic Int 15h Function 85h
 \i\p\aDetail\v@15h.85h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   85h

  \bTitle:\p       SysReq Key

  \bDescription:\p                                               [AT] [PS/2]

     Invoked by the ROM BIOS keyboard driver when the SysReq key is
     detected.

     \bInput\p                                 \bOutput\p

     AH = 85h                              If function successful
     AL = Key status                         Carry flag: clear
        = 00h (if key make (depression))     AH = 00h
        = 01h (if key break (release))
                                           If function unsuccessful
                                             Carry flag: set
                                             AH = Status
.context @15h.85h.des
.freeze 3
.topic Int 15h Function 85h
 \i\p\aSummary\v@15h.85h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The ROM BIOS handler for this function call is a dummy routine
     that always returns a success status unless called with an invalid
     subfunction number in AL. A multitasking program manager would be
     expected to capture Int 15h so that it can be notified when the
     user strikes the SysReq key.
.context @15h.86h
.freeze 3
.topic Int 15h Function 86h
 \i\p\aDetail\v@15h.86h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   86h

  \bTitle:\p       Delay

  \bSee also:\p    \aEvent Wait\v@15h.83h\v

  \bDescription:\p                                               [AT] [PS/2]

     Suspends the calling program for a specified interval in
     microseconds.

     \bInput\p                            \bOutput\p

     AH = 86h                         If function successful
     CX:DX = Microseconds to wait     (wait was performed)
                                        Carry flag: clear

                                      If function unsuccessful
                                      (wait was not performed)
                                        Carry flag: set
.context @15h.86h.des
.freeze 3
.topic Int 15h Function 86h
 \i\p\aSummary\v@15h.86h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The actual duration of the wait is always an integral multiple of
     976 microseconds.

     Use of this function allows programmed, hardware-independent
     delays at a finer resolution than can be obtained through use of
     the MS-DOS Get Time function (Int 21h Function 2Ch, which returns
     time in hundredths of a second).
.context @15h.87h
.freeze 3
.topic Int 15h Function 87h
 \i\p\aDetail\v@15h.87h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   87h

  \bTitle:\p       Move Extended Memory Block

  \bDescription:\p                                               [AT] [PS/2]

     Transfers data between conventional memory and extended memory.

     \bInput\p                                \bOutput\p

     AH = 87h                             If function successful
     CX = Number of words to move           Carry flag: clear
     ES:SI = segment:offset of Global       AH = 00h
             Descriptor Table (GDT)
                                          If function unsuccessful
                                            Carry flag: set
                                            AH = Status
                                               = 01h (if RAM parity
                                                      error)
                                               = 02h (if exception
                                                      interrupt error)
                                               = 03h (if gate address
                                                      line 20 failed)
.context @15h.87h.des
.freeze 3
.topic Int 15h Function 87h
 \i\p\aSummary\v@15h.87h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Conventional memory lies at addresses below the 640K boundary, and
     is used for the execution of MS-DOS and its application programs.
     Extended memory lies at addresses above 1 megabytes and can be
     accessed only by an 80286 or 80386 CPU running in protected mode. As
     many as 15 megabytes of extended memory can be installed in a
     PC/AT or compatible.

     The Global Descriptor Table (GDT) used by this function must be
     set up as follows:

     \bBytes\p       \bContents\p

     00h-0Fh     Reserved (should be 0)
     10h-11h     Segment length in bytes (2 * CX - 1 or greater)
     12h-14h     24-bit source address
     15h         Access rights byte (always 93h)
     16h-17h     Reserved (should be 0)
     18h-19h     Segment length in bytes (2 * CX - 1 or greater)
     1Ah-1Ch     24-bit destination address
     1Dh         Access rights byte (always 93h)
     1Eh-2Fh     Reserved (should be 0)

     The table is composed of six 8-byte descriptors to be used by the
     CPU in protected mode. The four descriptors in offsets 00h-0Fh and
     20h-2Fh are filled in by the ROM BIOS before the CPU mode switch.

     The addresses used in the descriptor table are linear (physical)
     24-bit addresses in the range 000000h-FFFFFFhÄÄnot segments and
     offsetsÄÄwith the least significant byte at the lowest address
     and the most significant byte at the highest address.

     The block move is performed with interrupts disabled; thus, use of
     this function may interfere with the operation of communications
     programs, network drivers, or other software that relies on prompt
     servicing of hardware interrupts.
.comment
.comment      Programs and drivers that access extended memory with this
.comment      function cannot be executed in the Compatibility Environment of
.comment      OS/2 systems.

     This function is not supported on the PS/2 Models 25 and 30.
.context @15h.88h
.freeze 3
.topic Int 15h Function 88h
 \i\p\aDetail\v@15h.88h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   88h

  \bTitle:\p       Get Extended Memory Size

  \bDescription:\p                                               [AT] [PS/2]

     Returns the amount of extended memory installed in the system.

     \bInput\p        \bOutput\p

     AH = 88h     AX = Amount of extended memory
                       (in kilobytes)
.context @15h.88h.des
.freeze 3
.topic Int 15h Function 88h
 \i\p\aSummary\v@15h.88h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Extended memory is memory at addresses above 1 megabyte, which can
     be accessed only by an 80286 or 80386 CPU running in protected
     mode. Because MS-DOS is a real-mode operating system, extended
     memory can be used for storage of volatile data but cannot be used
     for execution of programs.
.comment
.comment     Programs and drivers that use this function cannot be executed in
.comment     the Compatibility Environment of OS/2.

     This function is not supported on the PS/2 Models 25 and 30.
.context @15h.89h
.freeze 3
.topic Int 15h Function 89h
 \i\p\aDetail\v@15h.89h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   89h

  \bTitle:\p       Enter Protected Mode

  \bDescription:\p                                               [AT] [PS/2]

     Switches the CPU from real mode into protected mode.

     \bInput\p                                    \bOutput\p

     AH = 89h                                 If function successful
     BH = Interrupt number for IRQ0,          (CPU is in protected mode)
          written to ICW2 of 8259 PIC #1        Carry flag: clear
          (must be evenly divisible by 8,       AH = 00h
          determines IRQ0-IRQ7)                 CS = User-defined selector
     BL = Interrupt number for IRQ8,            DS = User-defined selector
          written to ICW2 of 8259 PIC #2        ES = User-defined selector
          (must be evenly divisible by 8,       SS = User-defined selector
          determines IRQ8-IRQ15)
     ES:SI = segment:offset of Global         If function unsuccessful
             Descriptor Table (GDT)           (CPU is in real mode)
                                                Carry flag: set
                                                AH = FFh
.context @15h.89h.des
.freeze 3
.topic Int 15h Function 89h
 \i\p\aSummary\v@15h.89h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The Global Descriptor Table must contain eight descriptors set up
     as follows:

     \bOffset\p     \bDescriptor use\p

     00h        Dummy descriptor (initialized to 0)
     08h        Global Descriptor Table (GDT)
     10h        Interrupt Descriptor Table (IDT)
     18h        User's data segment (DS)
     20h        User's extra segment (ES)
     28h        User's stack segment (SS)
     30h        User's code segment (CS)
     38h        BIOS code segment

     The user must initialize the first seven descriptors; the eighth
     is filled in by the ROM BIOS to allow it to be addressed in
     protected mode. The calling program may modify and use the eighth
     descriptor for any purpose after return from this function call.

     This function is not supported on the PS/2 Models 25 and 30.
.context @15h.90h
.freeze 3
.topic Int 15h Function 90h
 \i\p\aDetail\v@15h.90h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   90h

  \bTitle:\p       Device Wait

  \bDescription:\p                                                 [AT] [PS/2]

     Invoked by the ROM BIOS fixed disk, floppy disk, printer, network,
     and keyboard drivers prior to performing a programmed wait for I/O
     completion.

     \bInput\p                                 \bOutput\p

     AH = 90h                              If no wait (driver must
     AL = Device type                      perform its own time-out)
        = 00h-7Fh Serially reusable          Carry flag: clear
                  devices                    AH = 00h
        = 80h-BFh Reentrant devices
        = C0h-FFh Wait-only calls,         If wait was performed
                  no corresponding           Carry flag: set
                  Post function
     ES:BX = segment:offset of request
             block for device types
             80h-FFh
.context @15h.90h.des
.freeze 3
.topic Int 15h Function 90h
 \i\p\aSummary\v@15h.90h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Predefined device types are:

     00h     Disk (may time-out)
     01h     Floppy disk (may time-out)
     02h     Keyboard (no time-out)
     03h     Pointing device (PS/2, may time-out)
     80h     Network (no time-out)
     FCh     Fixed disk reset (PS/2, may time-out)
     FDh     Floppy disk drive motor start (may time-out)
     FEh     Printer (may time-out)

     For network adapters, ES:BX points to a network control block
     (NCB).

     A multitasking program manager would be expected to capture Int
     15h Function 90h so that it can dispatch other tasks while I/O is
     in progress. The default BIOS routine for this function simply
     returns with the carry flag clear and AH = 00h.
.context @15h.91h
.freeze 3
.topic Int 15h Function 91h
 \i\p\aDetail\v@15h.91h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   91h

  \bTitle:\p       Device Post

  \bDescription:\p                                               [AT] [PS/2]

     Invoked by the ROM BIOS fixed disk, floppy disk, network, and
     keyboard drivers to signal that I/O is complete and/or the device
     is ready.

     \bInput\p                                        \bOutput\p

     AH = 91h                                     AH = 00h
     AL = Device type
        = 00h-7Fh Serially reusable devices
        = 80h-BFh Reentrant devices
     ES:BX = segment:offset of request block
             for device types 80h-BFh
.context @15h.91h.des
.freeze 3
.topic Int 15h Function 91h
 \i\p\aSummary\v@15h.91h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Predefined device types that may use Device Post are:

     00h     Disk (may time-out)
     01h     Floppy disk (may time-out)
     02h     Keyboard (no time-out)
     03h     Pointing device (PS/2, may time-out)
     80h     Network (no time-out)

     The ROM BIOS printer routine does not invoke this function because
     printer output is not interrupt driven.

     A multitasking program manager would be expected to capture Int
     15h Function 91h so that it can be notified when I/O is completed
     and awaken the requesting task. The default BIOS routine for this
     function simply returns with the carry flag clear and AH = 00h.
.context @15h.C0h
.freeze 3
.topic Int 15h Function C0h
 \i\p\aDetail\v@15h.C0h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   C0h

  \bTitle:\p       Get System Environment

  \bSee also:\p    \aSystem Configuration ROM\v@ROMData\v

  \bDescription:\p                                               [AT] [PS/2]

     Returns a pointer to a table containing a variety of information
     about the system configuration.

     \bInput\p        \bOutput\p

     AH = C0h     ES:BX = segment:offset of
                          configuration table
.context @15h.C0h.des
.freeze 3
.topic Int 15h Function C0h
 \i\p\aSummary\v@15h.C0h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The format of the system configuration table is as follows:

     \bBytes\p       \bContents\p

     00h-01h     Length of table in bytes
     02h         System model
     03h         System submodel
     04h         BIOS revision level
     05h         Configuration flags

                 \bBits\p     \bSignificance (if set)\p

                 7        DMA channel 3 used
                 6        Slave 8259 present (cascaded IRQ2)
                 5        Real-time clock available
                 4        Keyboard intercept
                          (Int 15h Function 4Fh) available
                 3        Wait for External Event is available
                 2        Extended BIOS data area allocated
                 1        Micro Channel implemented
                 0        Reserved

     06h-09h     Reserved

     The system model and type bytes are assigned as follows:

     \bMachine\p                           \bModel Byte\p     \bSubmodel Byte\p

     PC                                FFh            ÄÄ
     PC/XT (11/08/82 BIOS)             FEh            ÄÄ
     PCjr                              FDh            ÄÄ
     PC/AT (6/10/85 BIOS)              FCh            00h
     PC/AT (11/15/85 BIOS)             FCh            01h
     PC/XT-286                         FCh            02h
     PS/2 Model 50[Z]                  FCh            04h
     PS/2 Model 60                     FCh            05h
     PC/XT (1/10/86 & 5/9/86 BIOS)     FBh            00h
     PS/2 Model 30                     FAh            00h
     PC Convertible                    F9h            00h
     PS/2 Model 80 (16MHz)             F8h            00h
     PS/2 Model 80 (20MHz)             F8h            01h
     PS/2 Model 70 (20MHz)             F8h            04h
     PS/2 Model 70 (16MHz)             F8h            09h
     PS/2 Model 55                     F8h            0Ch
     PS/2 Model 70 (25MHz)             F8h            0Dh

     These bytes should be used with care, as they do not reflect
     alternate processor cards (such as Microsoft MACH 20).
.context @15h.C1h
.freeze 3
.topic Int 15h Function C1h
 \i\p\aDetail\v@15h.C1h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   C1h

  \bTitle:\p       Get Address of Extended BIOS Data Area

  \bDescription:\p                                                   [PS/2]

     Returns the segment address of the base of the extended BIOS data
     area.

     \bInput\p               \bOutput\p

     AH = C1h            If function successful
                           Carry flag: clear
                           ES = Segment of extended BIOS data area

                         If function unsuccessful
                           Carry flag: set
.context @15h.C1h.des
.freeze 3
.topic Int 15h Function C1h
 \i\p\aSummary\v@15h.C1h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The extended BIOS data area is allocated at the high end of
     conventional memory during the POST (Power-On Self-Test) sequence.
     The word at 0040:0013h (memory size) is updated to reflect the
     reduced amount of memory available for MS-DOS and application
     programs. The first byte in the extended BIOS data area is
     initialized to its length in kilobytes.

     A program can determine whether the extended BIOS data area exists
     with Int 15h Function C0h.
.context @15h.C2h
.freeze 3
.topic Interrupt 15h (Mouse Pointer)
                                             \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   C2h

  \bTitle:\p       Mouse Pointer Interrupts

  \bSubfunction\p     \bName\p

  \a00h             Enable/Disable Pointing Device\v@15h.C2h.00h\v
  \a01h             Reset Pointing Device\v@15h.C2h.01h\v
  \a02h             Set Sample Rate\v@15h.C2h.02h\v
  \a03h             Set Resolution\v@15h.C2h.03h\v
  \a04h             Get Pointing Device Type\v@15h.C2h.04h\v
  \a05h             Initialize Pointing Device Interface\v@15h.C2h.05h\v
  \a06h             Set Scaling or Get Status\v@15h.C2h.06h\v
  \a07h             Set Pointing Device Handler Address\v@15h.C2h.07h\v
.context @15h.C2h.00h
.freeze 3
.topic Int 15h Function C2h Subfunction 00h
                                             \i\p\aUp\v@15h.C2h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   C2h     \bSubfunction:\p   00h

  \bTitle:\p       Enable/Disable Pointing Device

  \bDescription:\p                                                    [PS/2]

     Enables or disables the system's mouse or other pointing device.

     \bInput\p                        \bOutput\p

     AH = C2h                     If function successful
     AL = 00h                       Carry flag: clear
     BH = Enable/disable flag       AH = 00h
          00h = Disable
          01h = Enable            If function unsuccessful
                                    Carry flag: set
                                    AH = Status
                                       = 01h (if invalid function call)
                                       = 02h (if invalid input)
                                       = 03h (if interface error)
                                       = 04h (if resend)
                                       = 05h (if no far call installed)
.context @15h.C2h.01h
.freeze 3
.topic Int 15h Function C2h Subfunction 01h
 \i\p\aDetail\v@15h.C2h.01h.des\v\i\p                                    \i\p\aUp\v@15h.C2h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   C2h     \bSubfunction:\p   01h

  \bTitle:\p       Reset Pointing Device

  \bDescription:\p                                                    [PS/2]

     Resets the system's mouse or other pointing device, setting the
     sample rate, resolution, and other characteristics to their
     default values.

     \bInput\p        \bOutput\p

     AH = C2h     If function successful
     AL = 01h       Carry flag: clear
                    AH = 00h
                    BH = Device ID

                  If function unsuccessful
                    Carry flag: set
                    AH = Status
                         See: \aInt 15h Function C2h\v@15h.c2h.00h\v
                              \aSubfunction 00h\v@15h.c2h.00h\v
.context @15h.C2h.01h.des
.freeze 3
.topic Int 15h Function C2h Subfunction 01h
 \i\p\aSummary\v@15h.C2h.01h\v\i\p                                   \i\p\aUp\v@15h.C2h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     After a reset operation, the state of the pointing device is as
     follows:

     ş   disabled
     ş   sample rate at 100 reports per second
     ş   resolution at 4 counts per millimeter
     ş   scaling at 1 to 1

     The data package size is unchanged by this function.

     The application can use the other Int 15h Function C2h
     subfunctions to initialize the pointing device to other sample
     rates, resolution, and scaling, and then enable the device with
     Int 15h Function C2h Subfunction 00h.

     See also Int 15h Function C2h Subfunction 05h, which incidentally
     resets the pointing device in a similar manner.
.context @15h.C2h.02h
.context @15h.C2h.02h.des
.freeze 3
.topic Int 15h Function C2h Subfunction 02h
                                             \i\p\aUp\v@15h.C2h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   C2h     \bSubfunction:\p   02h

  \bTitle:\p       Set Sample Rate

  \bDescription:\p                                                    [PS/2]

     Sets the sampling rate of the system's mouse or other pointing
     device. The default sample rate is 100 reports per second after
     a reset operation (Int 15h Function C2h Subfunction 01h).

     \bInput\p                                     \bOutput\p

     AH = C2h                                  If function successful
     AL = 02h                                    Carry flag: clear
     BH = Sample rate value                      AH = 00h
          00h = 10  reports per second
          01h = 20  reports per second         If function unsuccessful
          02h = 40  reports per second           Carry flag: set
          03h = 60  reports per second           AH = Status
          04h = 80  reports per second                See: \aInt 15h\v@15h.c2h.00h\v
          05h = 100 reports per second                     \aFunction C2h\v@15h.c2h.00h\v
          06h = 200 reports per second                     \aSubfunction 00h\v@15h.c2h.00h\v
.context @15h.C2h.03h
.context @15h.C2h.03h.des
.freeze 3
.topic Int 15h Function C2h Subfunction 03h
                                             \i\p\aUp\v@15h.C2h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   C2h     \bSubfunction:\p   03h

  \bTitle:\p       Set Resolution

  \bDescription:\p                                                    [PS/2]

     Sets the resolution of the system's mouse or other pointing
     device. The default resolution is 4 counts per millimeter after
     a reset operation (Int 15h Function C2h Subfunction 01h).

     \bInput\p                                  \bOutput\p

     AH = C2h                               If function successful
     AL = 03h                                 Carry flag: clear
     BH = Resolution value                    AH = 00h
          00h = 1 count per millimeter
          01h = 2 counts per millimeter     If function unsuccessful
          02h = 4 counts per millimeter       Carry flag: set
          03h = 8 counts per millimeter       AH = Status
                                                   See: \aInt 15h Function C2h\v@15h.c2h.00h\v
                                                        \aSubfunction 00h\v@15h.c2h.00h\v
.context @15h.C2h.04h
.freeze 3
.topic Int 15h Function C2h Subfunction 04h
                                             \i\p\aUp\v@15h.C2h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   C2h     \bSubfunction:\p   04h

  \bTitle:\p       Get Pointing Device Type

  \bDescription:\p                                                    [PS/2]

     Returns the identification code for the system's mouse or other
     pointing device.

     \bInput\p        \bOutput\p

     AH = C2h     If function successful
     AL = 04h       Carry flag: clear
                    AH = 00h
                    BH = Device ID

                  If function unsuccessful
                    Carry flag: set
                    AH = Status
                         See: \aInt 15h Function C2h\v@15h.c2h.00h\v
                              \aSubfunction 00h\v@15h.c2h.00h\v
.context @15h.C2h.05h
.freeze 3
.topic Int 15h Function C2h Subfunction 05h
 \i\p\aDetail\v@15h.C2h.05h.des\v\i\p                                    \i\p\aUp\v@15h.C2h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   C2h     \bSubfunction:\p   05h

  \bTitle:\p       Initialize Pointing Device Interface

  \bDescription:\p                                                    [PS/2]

     Sets the data package size for the system's mouse or other
     pointing device, and initializes the resolution, sampling rate,
     and scaling to their default values.

     \bInput\p                      \bOutput\p

     AH = C2h                   If function successful
     AL = 05h                     Carry flag: clear
     BH = Data package size       AH = 00h
          in bytes (1-8)
                                If function unsuccessful
                                  Carry flag: set
                                  AH = Status
                                       See: \aInt 15h Function C2h\v@15h.c2h.00h\v
                                            \aSubfunction 00h\v@15h.c2h.00h\v
.context @15h.C2h.05h.des
.freeze 3
.topic Int 15h Function C2h Subfunction 05h
 \i\p\aSummary\v@15h.C2h.05h\v\i\p                                   \i\p\aUp\v@15h.C2h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     After this operation, the state of the pointing device is as
     follows:

     ş   disabled
     ş   sample rate at 100 reports per second
     ş   resolution at 4 counts per millimeter
     ş   scaling at 1 to 1
.context @15h.C2h.06h
.freeze 3
.topic Int 15h Function C2h Subfunction 06h
                                             \i\p\aUp\v@15h.C2h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   C2h     \bSubfunction:\p   06h

  \bTitle:\p       Set Scaling or Get Status

  \bDescription:\p                                                    [PS/2]

     Returns the current status of the system's mouse or other pointing
     device or sets the device's scaling factor.

     \bInput\p                              \bOutput\p

     AH = C2h                            If function successful
     AL = 06h                              Carry flag: clear
     BH = Extended command                 AH = 00h
          00h = Return device status     And if called with BH = 00h
          01h = Set scaling at 1:1         BL = Status byte
          02h = Set scaling at 2:1
                                                \bBits\p   \bSignificance\p

                                                0     = 1 if right button
                                                        pressed
                                                1     = Reserved
                                                2     = 1 if left button
                                                        pressed
                                                3     = Reserved
                                                4     = 0 if 1:1 scaling
                                                      = 1 if 2:1 scaling
                                                5     = 0 if device
                                                        disabled
                                                      = 1 if device
                                                        enabled
                                                6     = 0 if stream mode
                                                      = 1 if remote mode
                                                7     = Reserved

                                           CL = Resolution
                                                00h = 1 count per
                                                      millimeter
                                                01h = 2 counts per
                                                      millimeter
                                                02h = 4 counts per
                                                      millimeter
                                                03h = 8 counts per
                                                      millimeter
                                           DL = Sample rate
                                                0AH = 10 reports
                                                      per second
                                                14h = 20 reports
                                                      per second
                                                28h = 40 reports
                                                      per second
                                                3CH = 60 reports
                                                      per second
                                                50h = 80 reports
                                                      per second
                                                64h = 100 reports
                                                      per second
                                                C8h = 200 reports
                                                      per second

                                          If function unsuccessful
                                            Carry flag: set
                                            AH = Status
                                                 See: \aInt 15h Function C2h\v@15h.c2h.00h\v
                                                      \aSubfunction 00h\v@15h.c2h.00h\v
.context @15h.C2h.07h
.freeze 3
.topic Int 15h Function C2h Subfunction 07h
 \i\p\aDetail\v@15h.C2h.07h.des\v\i\p                                    \i\p\aUp\v@15h.C2h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   C2h     \bSubfunction:\p   07h

  \bTitle:\p       Set Pointing Device Handler Address

  \bDescription:\p                                                    [PS/2]

     Notifies the ROM BIOS pointing device driver of the address for a
     routine to be called each time that pointing device data is available.

     \bInput\p                         \bOutput\p

     AH = C2h                      If function successful
     AL = 07h                        Carry flag: clear
     ES:BX = segment:offset of
             user routine          If function unsuccessful
                                     Carry flag: set
                                     AH = Status
                                          See: \aInt 15h Function C2h\v@15h.c2h.00h\v
                                               \aSubfunction 00h\v@15h.c2h.00h\v
.context @15h.C2h.07h.des
.freeze 3
.topic Int 15h Function C2h Subfunction 07h
 \i\p\aSummary\v@15h.C2h.07h\v\i\p                                   \i\p\aUp\v@15h.C2h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The user's handler for pointing device data is entered via a far
     call with four parameters on the stack:

       SS:SP+0Ah status
       SS:SP+08h x coordinate
       SS:SP+06h y coordinate
       SS:SP+04h z coordinate (always 0)

     The handler must exit via a far return without removing the
     parameters from the stack.

     The status parameter passed to the user's handler is interpreted
     as follows:

     \bBits\p     \bSignificance (if set)\p

     0        Left button pressed
     1        Right button pressed
     2-3      Reserved
     4        Sign of x data is negative
     5        Sign of y data is negative
     6        x data has overflowed
     7        y data has overflowed
     8-15     Reserved

.context @15h.C3h
.context @15h.C3h.des
.freeze 3
.topic Int 15h Function C3h
                                             \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   C3h

  \bTitle:\p       Set Watchdog Time-Out

  \bDescription:\p                                                    [PS/2]

     Enables or disables a watchdog timer. The watchdog timer generates
     an NMI interrupt.

     This function is not available on the PS/2 Models 25 and 30.

     \bInput\p                                       \bOutput\p

     AH = C3h                                    If function successful
     AL = Subfunction                              Carry flag: clear
        = 00h Disable watchdog time-out
        = 01h Enable watchdog time-out           If function unsuccessful
     BX = Watchdog timer counter (if AL = 01h)     Carry flag: set
.context @15h.C4h
.freeze 3
.topic Int 15h Function C4h
 \i\p\aDetail\v@15h.C4h.des\v\i\p                                    \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   15h     \bFunction:\p   C4h

  \bTitle:\p       Programmable Option Select

  \bDescription:\p                                                    [PS/2]

     Returns the base Programmable Option Select register address,
     enables a slot for setup, or enables an adapter.

     \bInput\p                                \bOutput\p

     AH = C4h                             If function successful
     AL = Subfunction                       Carry flag: clear
        = 00h Return base POS adapter     And if called with AL = 00h
              register address              DX = Base POS adapter
        = 01h Enable slot                        register address
        = 02h Enable adapter
     BL = Slot number (if AL = 01h)       If function unsuccessful
                                            Carry flag: set
.context @15h.C4h.des
.freeze 3
.topic Int 15h Function C4h
 \i\p\aSummary\v@15h.C4h\v\i\p                                   \i\p\aUp\v@15h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function is available only on machines using the Micro
     Channel Architecture (MCA) bus.

     After a slot is enabled with Subfunction 01h, specific information
     can be obtained for the adapter in that slot by performing port
     input operations:

     \bPort\p     \bFunction\p

     100h     MCA ID (low byte)
     101h     MCA ID (high byte)
     102h     Option Select Byte 1
              (bit 0 = 1 if enabled, = 0 if disabled)
     103h     Option Select Byte 2
     104h     Option Select Byte 3
     105h     Option Select Byte 4
              (bits 6-7 = channel check indicators)
     106h     Subaddress Extension (low byte)
     107h     Subaddress Extension (high byte)
.context @16h
.context 16h
.context 016h
.context 22
..index keyboard interrupts, Int 16h
..index Int 16h functions, Keyboard Interrupts
.freeze 3
.topic Int 16h
                                             \i\p\aUp\v@BIOSCalls\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   16h

  \bTitle:\p       Keyboard Interrupts

  \bSee also:\p    \aKeyboard Scan Codes\v@KeyChart101\v, \aExtended Scan Codes\v@XKeyChart\v,
               \aKeyboard Data Memory\v@Keydata\v

  \bFunctions\p     \bName\p

  \a00h, 10h     Read Character from Keyboard\v@16h.00h\v
  \a01h, 11h     Get Keyboard Status\v@16h.01h\v
  \a02h, 12h     Get Keyboard Flags\v@16h.02h\v
  \a03h          Set Repeat Rate\v@16h.03h\v
  \a04h          Set Keyclick\v@16h.04h\v
  \a05h          Push Character and Scan Code\v@16h.05h\v
.context @16h.00h
.freeze 3
.topic Int 16h Functions 00h and 10h
 \i\p\aExample\v@GetKeyCl.asx\v\i\p                                   \i\p\aUp\v@16h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   16h     \bFunctions:\p  00h and 10h

  \bTitle:\p       Read Character from Keyboard

  \bSee also:\p    \aInt 16h Functions 01h and 11h\v@16h.01h\v, \aKeyboard Scan Codes\v@KeyChart101\v,
               \aASCII Chart\vpwb.hlp!ascii\v, \aCharacter Input\v@21h.01h\v, \aKeyboard Data Memory\v@Keydata\v

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Reads a character and scan code from the keyboard type-ahead
     buffer. Use Function 10h if the code must handle the additional
     keys of the enhanced keyboard (such as F11, F12, and cursor
     control keys).

     You can use the keyboard data byte at \a0000:0496h\v@ImpMem\v to
     determine if the extended keyboard is available.

     \bInput\p                                  \bOutput\p

     AH = 00h to read any keyboard          AH = Keyboard scan code
        = 10h to read extended keyboard     AL = ASCII character
.context @16h.01h
.context @16h.01h.des
.freeze 3
.topic Int 16h Functions 01h and 11h
 \i\p\aExample\v@GetKeyCl.asx\v\i\p                                   \i\p\aUp\v@16h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   16h     \bFunctions:\p  01h and 11h

  \bTitle:\p       Get Keyboard Status

  \bSee also:\p    \aInt 16h Functions 00h and 10h\v@16h.00h\v, \aKeyboard Scan Codes\v@KeyChart101\v,
               \aASCII Chart\vpwb.hlp!ascii\v, \aCheck Keyboard Status\v@21h.0Bh\v, \aKeyboard Data Memory\v@Keydata\v

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Determines whether a character is ready for input, returning a
     flag and also the character itself, if one is waiting. The
     character returned by this function when the zero flag is clear
     is not removed from the type-ahead buffer. The same character and
     scan code will be returned by the next call to Int 16h Function
     00h or 10h.

     Use Function 11h if the code must handle the additional keys of
     the enhanced keyboard (such as F11, F12, and cursor control
     keys). You can use the keyboard data byte at \a0000:0496h\v@ImpMem\v to
     determine if the extended keyboard is available.

     \bInput\p                                   \bOutput\p

     AH = 01h to check any keyboard          If key waiting to be input
        = 11h to check extended keyboard       Zero flag: clear
                                               AH = Keyboard scan code
                                               AL = Character

                                             If no key waiting
                                               Zero flag: set
.context @16h.02h
.context @16h.02h.des
.freeze 3
.topic Int 16h Functions 02h and 12h
 \i\p\aExample\v@GetShift.asx\v\i\p                                   \i\p\aUp\v@16h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   16h     \bFunctions:\p  02h and 12h

  \bTitle:\p       Get Keyboard Flags

  \bSee also:\p    \aKeyboard Data Memory\v@Keydata\v

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Returns flag data that describes the state of the various keyboard
     toggles and shift keys. Use Function 02h if the code must work
     with any keyboard. Use Function 12h if the code must handle the
     additional keys of the enhanced keyboard (such as right CTRL and
     ALT). You can use the keyboard data byte at \a0000:0496h\v@ImpMem\v to determine
     if the extended keyboard is available.

     The low byte returned by 02h and 12h is the same as the keyboard
     flags byte stored at \a0000:0417h\v@ImpMem\v. The high byte returned by
     Function 12h is similar to (but not exactly the same as) the byte
     stored at \a0000:0418h\v@ImpMem\v.

     \bInput\p                       \bOutput\p

     AH = 02h for shift flags    AL = Flags (both 02h and 12h)
        = 12h for extended
          shift flags             7 6 5 4 3 2 1 0
                                 ÚÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄ¿
                                 ³ ³ ³ ³ ³ ³ ³ ³ ³
                                 ÀÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÙ
                                  ³ ³ ³ ³ ³ ³ ³ ³
                                  ³ ³ ³ ³ ³ ³ ³ ÀÄ Right SHIFT key is down
                                  ³ ³ ³ ³ ³ ³ ÀÄÄÄ Left SHIFT key is down
                                  ³ ³ ³ ³ ³ ÀÄÄÄÄÄ CTRL key is down
                                  ³ ³ ³ ³ ÀÄÄÄÄÄÄÄ ALT key is down
                                  ³ ³ ³ ÀÄÄÄÄÄÄÄÄÄ SCROLL LOCK on
                                  ³ ³ ÀÄÄÄÄÄÄÄÄÄÄÄ NUM LOCK on
                                  ³ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄ CAPS LOCK on
                                  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ INS on

                                 AH = Extended flags (12h only)

                                  7 6 5 4 3 2 1 0
                                 ÚÄÂÄÂÄÂÄÂÄÂÄÂÄÂÄ¿
                                 ³ ³ ³ ³ ³ ³ ³ ³ ³
                                 ÀÄÁÄÁÄÁÄÁÄÁÄÁÄÁÄÙ
                                  ³ ³ ³ ³ ³ ³ ³ ³
                                  ³ ³ ³ ³ ³ ³ ³ ÀÄ Left CTRL key is down
                                  ³ ³ ³ ³ ³ ³ ÀÄÄÄ Left ALT key is down
                                  ³ ³ ³ ³ ³ ÀÄÄÄÄÄ Right CTRL key is down
                                  ³ ³ ³ ³ ÀÄÄÄÄÄÄÄ Right ALT key is down
                                  ³ ³ ³ ÀÄÄÄÄÄÄÄÄÄ Scroll key is down
                                  ³ ³ ÀÄÄÄÄÄÄÄÄÄÄÄ NUM LOCK key is down
                                  ³ ÀÄÄÄÄÄÄÄÄÄÄÄÄÄ CAPS LOCK key is down
                                  ÀÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ SYSREQ key is down
.context @16h.03h
.freeze 3
.topic Int 16h Function 03h
 \i\p\aDetail\v@16h.03h.des\v\i\p                                    \i\p\aUp\v@16h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   16h     \bFunction:\p   03h

  \bTitle:\p       Set Repeat Rate

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Sets the ROM BIOS key repeat ("typematic") rate and delay.

     \bInput\p                                         \bOutput\p

     On the PC/AT and PS/2                         None
       AH = 03h
       AL = 05h
       BH = Repeat delay
       BL = Repeat rate

     On the PCjr
       AH = 03h
       AL = Subfunction
          = 00h Restore default rate and delay
          = 01h Increase initial delay
          = 02h Decrease repeat rate by one-half
          = 03h Increase delay and decrease
                repeat rate by one-half
          = 04h Turn off keyboard repeat
.context @16h.03h.des
.freeze 3
.topic Int 16h Function 03h
 \i\p\aSummary\v@16h.03h\v\i\p                                   \i\p\aUp\v@16h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Subfunctions 00h-04h are available on the PCjr but are not
     supported by the PC or PC/XT ROM BIOS. Subfunction 05h is
     available on PC/ATs with ROM BIOS dates 11/15/85 and later, and
     on the PS/2.

     On the PC/AT and PS/2, the value in BH controls the amount of
     delay before the first repeat key is generated, and is a multiple
     of 250 milliseconds:

     \bValue\p     \bDelay (milliseconds)\p

     00h       250
     01h       500
     02h       750
     03h       1000

     On the PC/AT and PS/2, the value for the repeat rate in characters
     per second can be chosen from the following table:

     \bValue\p     \bRepeat Rate\p

     00h       30.0
     01h       26.7
     02h       24.0
     03h       21.8
     04h       20.0
     05h       18.5
     06h       17.1
     07h       16.0
     08h       15.0
     09h       13.3
     0Ah       12.0
     0Bh       10.9
     0Ch       10.0
     0Dh       9.2
     0Eh       8.6
     0Fh       8.0
     10h       7.5
     11h       6.7
     12h       6.0
     13h       5.5
     14h       5.0
     15h       4.6
     16h       4.3
     17h       4.0
     18h       3.7
     19h       3.3
     1Ah       3.0
     1Bh       2.7
     1Ch       2.5
     1Dh       2.3
     1Eh       2.1
     1Fh       2.0
.context @16h.04h
.context @16h.04h.des
.freeze 3
.topic Int 16h Function 04h
                                             \i\p\aUp\v@16h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   16h     \bFunction:\p   04h

  \bTitle:\p       Set Keyclick

  \bDescription:\p                                                      [PC]

     Turns the keyboard click on or off. This function is supported by
     the PCjr BIOS only.

     \bInput\p                                \bOutput\p

     AH = 04h                             None
     AL = Subfunction
        = 00h Turn off keyboard click
        = 01h Turn on keyboard click
.context @16h.05h
.context @16h.05h.des
.freeze 3
.topic Int 16h Function 05h
                                             \i\p\aUp\v@16h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   16h     \bFunction:\p   05h

  \bTitle:\p       Push Character and Scan Code

  \bDescription:\p                                               [AT] [PS/2]

     Places a character and scan code in the keyboard type-ahead
     buffer. This function can be used by keyboard enhancers and other
     utilities to interpolate keys into the data stream seen by
     application programs.

     \bInput\p              \bOutput\p

     AH = 05h           If function successful
     CH = Scan code       Carry flag: clear
     CL = Character       AL = 00h

                        If function unsuccessful
                        (type-ahead buffer is full)
                          Carry flag: set
                          AL = 01h
.context @17h
.context 17h
.context 017h
.context 23
..index parallel printer ports, Int 17h
..index Int 17h functions, Parallel Printer Port Interrupts
.freeze 3
.topic Int 17h
                                             \i\p\aUp\v@BIOSCalls\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   17h

  \bTitle:\p       Parallel Printer Port Interrupts

  \bSee also:\p    \aParallel and Serial Polling\v@MiscMem\v

  \bFunction\p     \bName\p

  \a00h          Write Character to Printer\v@17h.00h\v
  \a01h          Initialize Printer Port\v@17h.01h\v
  \a02h          Get Printer Status\v@17h.02h\v
.context @17h.00h
.freeze 3
.topic Int 17h Function 00h
                                             \i\p\aUp\v@17h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   17h     \bFunction:\p   00h

  \bTitle:\p       Write Character to Printer

  \bSee also:\p    \aPrint Character\v@21h.05h\v

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Sends a character to the specified parallel printer interface port
     and returns the current status of the port.

     \bInput\p                             \bOutput\p

     AH = 00h                          AH = Status
     AL = Character
     DX = Printer number (0 = LPT1,         \bBits\p  \bSignificance (if set)\p
          1 = LPT2, 2 = LPT3)
                                            7     Printer not busy
                                            6     Printer acknowledge
                                            5     Out of paper
                                            4     Printer selected
                                            3     I/O error
                                            2     Unused
                                            1     Unused
                                            0     Printer timed-out
.context @17h.01h
.freeze 3
.topic Int 17h Function 01h
                                             \i\p\aUp\v@17h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   17h     \bFunction:\p   01h

  \bTitle:\p       Initialize Printer Port

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Initializes the specified parallel printer interface port and
     returns its status.

     \bInput\p                             \bOutput\p

     AH = 01h                          AH = Status
     DX = Printer number (0 = LPT1,         See: \aInt 17h Function 00h\v@17h.00h\v
          1 = LPT2, 2 = LPT3)
.context @17h.02h
.freeze 3
.topic Int 17h Function 02h
 \i\p\aExample\v@VeriPrin.asx\v\i\p                                   \i\p\aUp\v@17h\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   17h     \bFunction:\p   02h

  \bTitle:\p       Get Printer Status

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Returns the current status of the specified parallel printer
     interface port.

     \bInput\p                             \bOutput\p

     AH = 02h                          AH = Status
     DX = Printer number (0 = LPT1,         See: \aInt 17h Function 00h\v@17h.00h\v
          1 = LPT2, 2 = LPT3)
.context @18h
.context @18h.des
.context 18h
.context 018h
.context 24
.freeze 3
.topic Int 18h
                                             \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   18h

  \bTitle:\p       ROM BASIC

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Transfers control to ROM BASIC. This interrupt is invoked when
     the system is turned on or restarted if attempts to read a boot
     sector from the fixed disk or floppy disk drives are unsuccessful.

     \bInput\p       \bOutput\p

     None        None
.context @19h
.context 19h
.context 019h
.context 25
.freeze 3
.topic Int 19h
 \i\p\aDetail\v@19h.des\v\i\p                                    \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   19h

  \bTitle:\p       Reboot System

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Reboots the operating system from the floppy disk or fixed disk
     drive.

     \bInput\p       \bOutput\p

     None        None
.context @19h.des
.freeze 3
.topic Int 19h
 \i\p\aSummary\v@19h\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The bootstrap routine reads Sector 1, Track 0 into memory at
     location 0000:7C00h and transfers control to the same address. If
     attempts to read a boot sector from the floppy disk or fixed disk
     are unsuccessful, control is transferred to ROM BASIC by execution
     of an Int 18h.

     If location 0000:0472h does not contain the value 1234h, a memory
     test will be performed before reading the boot sector.
.context @1Ah
.context 1Ah
.context 01Ah
.context 26
..index clock interrupts, Int 1Ah
..index Int 1Ah functions, Clock Interrupts
.freeze 3
.topic Int 1Ah
                                             \i\p\aUp\v@BIOSCalls\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Ah

  \bTitle:\p       Clock Interrupts

  \bFunction\p     \bName\p

  \a00h          Get Tick Count\v@1Ah.00h\v
  \a01h          Set Tick Count\v@1Ah.01h\v
  \a02h          Get Time\v@1Ah.02h\v
  \a03h          Set Time\v@1Ah.03h\v
  \a04h          Get Date\v@1Ah.04h\v
  \a05h          Set Date\v@1Ah.05h\v
  \a06h          Set Alarm\v@1Ah.06h\v
  \a07h          Reset Alarm\v@1Ah.07h\v
  \a0Ah          Get Day Count\v@1Ah.0Ah\v
  \a0Bh          Set Day Count\v@1Ah.0Bh\v
  \a80h          Set Sound Source\v@1Ah.80h\v
.context @1Ah.00h
.freeze 3
.topic Int 1Ah Function 00h
 \i\p\aDetail\v@1Ah.00h.des\v\i\p \i\p\aExample\v@Pause.asx\v\i\p                          \i\p\aUp\v@1Ah\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Ah     \bFunction:\p   00h

  \bTitle:\p       Get Tick Count

  \bSee also:\p    \aTimer Data Memory\v@TimerData\v

  \bDescription:\p                                               [AT] [PS/2]

     Returns the contents of the clock tick counter.

     \bInput\p        \bOutput\p

     AH = 00h     AL = Rolled-over flag
                       00h   (if midnight not passed since last read)
                    <> 00h   (if midnight was passed since last read)
                  CX:DX = Tick count (high 16 bits in CX)
.context @1Ah.00h.des
.freeze 3
.topic Int 1Ah Function 00h
 \i\p\aSummary\v@1Ah.00h\v\i\p \i\p\aExample\v@Pause.asx\v\i\p                         \i\p\aUp\v@1Ah\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function is supported by the PC/XT and PCjr ROM BIOS, but is
     not present in the ROM BIOS for the original PC.

     The returned value is the cumulative number of clock ticks since
     midnight. There are 18.2 clock ticks per second. When the counter
     reaches 1,573,040, it is cleared to zero, and the rolled-over flag
     is set.

     The rolled-over flag is cleared by this function call, so the flag
     will only be returned nonzero once per day.

     Int 1Ah Function 01h can be used to set the clock tick counter to
     an arbitrary 32-bit value.
.context @1Ah.01h
.freeze 3
.topic Int 1Ah Function 01h
 \i\p\aDetail\v@1Ah.01h.des\v\i\p                                    \i\p\aUp\v@1Ah\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Ah     \bFunction:\p   01h

  \bTitle:\p       Set Tick Count

  \bSee also:\p    \aTimer Data Memory\v@TimerData\v

  \bDescription:\p                                               [AT] [PS/2]

     Stores a 32-bit value in the clock tick counter.

     \bInput\p                            \bOutput\p

     AH = 01h                         None
     CX:DX = Tick count
             (high 16-bits in CX)
.context @1Ah.01h.des
.freeze 3
.topic Int 1Ah Function 01h
 \i\p\aSummary\v@1Ah.01h\v\i\p                                   \i\p\aUp\v@1Ah\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This function is supported by the PC/XT and PCjr ROM BIOS, but is
     not present in the ROM BIOS for the original PC.

     Int 1Ah Function 00h is used to read the value of the clock tick
     counter.

     The rolled-over flag is cleared by this function call.
.context @1Ah.02h
.freeze 3
.topic Int 1Ah Function 02h
                                             \i\p\aUp\v@1Ah\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Ah     \bFunction:\p   02h

  \bTitle:\p       Get Time

  \bSee also:\p    \aDOS Get Time\v@21h.2Ch\v, \aSet Time\v@1Ah.03h\v

  \bDescription:\p                                               [AT] [PS/2]

     Reads the current time from the CMOS time/date chip.

     \bInput\p        \bOutput\p

     AH = 02h     CH = Hours in binary coded decimal (BCD)
                  CL = Minutes in BCD
                  DH = Seconds in BCD
                  DL = Daylight saving time code
                     = 00h (if standard time)
                     = 01h (if daylight saving time)
                  And if clock running
                    Carry flag: clear
                  Or if clock stopped
                    Carry flag: set
.context @1Ah.03h
.freeze 3
.topic Int 1Ah Function 03h
                                             \i\p\aUp\v@1Ah\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Ah     \bFunction:\p   03h

  \bTitle:\p       Set Time

  \bSee also:\p    \aDOS Set Time\v@21h.2Dh\v, \aGet Time\v@1Ah.02h\v

  \bDescription:\p                                               [AT] [PS/2]

     Sets the time in the CMOS time/date chip.

     \bInput\p                                        \bOutput\p

     AH = 03h                                     None
     CH = Hours in binary coded decimal (BCD)
     CL = Minutes in BCD
     DH = Seconds in BCD
     DL = Daylight saving time code
        = 00h (if standard time)
        = 01h (if daylight saving time)
.context @1Ah.04h
.freeze 3
.topic Int 1Ah Function 04h
                                             \i\p\aUp\v@1Ah\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Ah     \bFunction:\p   04h

  \bTitle:\p       Get Date

  \bSee also:\p    \aDOS Get Date\v@21h.2Ah\v, \aSet Date\v@1Ah.05h\v

  \bDescription:\p                                               [AT] [PS/2]

     Reads the current date from the CMOS time/date chip.

     \bInput\p        \bOutput\p

     AH = 04h     CH = Century (19 or 20) in binary
                       coded decimal (BCD)
                  CL = Year in BCD
                  DH = Month in BCD
                  DL = Day in BCD
                  And if clock running
                    Carry flag: clear
                  Or if clock stopped
                    Carry flag: set
.context @1Ah.05h
.freeze 3
.topic Int 1Ah Function 05h
                                             \i\p\aUp\v@1Ah\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Ah     \bFunction:\p   05h

  \bTitle:\p       Set Date

  \bSee also:\p    \aDOS Set Date\v@21h.2Bh\v, \aGet Date\v@1Ah.04h\v

  \bDescription:\p                                               [AT] [PS/2]

     Sets the date in the CMOS time/date chip.

     \bInput\p                                 \bOutput\p

     AH = 05h                              None
     CH = Century (19 or 20) in binary
          coded decimal (BCD)
     CL = Year in BCD
     DH = Month in BCD
     DL = Day in BCD
.context @1Ah.06h
.freeze 3
.topic Int 1Ah Function 06h
 \i\p\aDetail\v@1Ah.06h.des\v\i\p                                    \i\p\aUp\v@1Ah\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Ah     \bFunction:\p   06h

  \bTitle:\p       Set Alarm

  \bDescription:\p                                               [AT] [PS/2]

     Sets an alarm in the CMOS date/time chip.

     \bInput\p                                        \bOutput\p

     AH = 06h                                     If function successful
     CH = Hours in binary coded decimal (BCD)       Carry flag: clear
     CL = Minutes in BCD
     DH = Seconds in BCD                          If function unsuccessful
                                                  (alarm already set or
                                                  clock stopped)
                                                    Carry flag: set

.context @1Ah.06h.des
.freeze 3
.topic Int 1Ah Function 06h
 \i\p\aSummary\v@1Ah.06h\v\i\p                                   \i\p\aUp\v@1Ah\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     A side effect of this function is that the clock chip's interrupt
     level (IRQ8) is enabled.

     Only one alarm may be active at any given time. The alarm occurs
     every 24 hours at the specified time until it is reset with Int
     1Ah Function 07h.

     The program using this function must place the address of its
     interrupt handler for the alarm in the vector for Int 4Ah.
.context @1Ah.07h
.context @1Ah.07h.des
.freeze 3
.topic Int 1Ah Function 07h
                                             \i\p\aUp\v@1Ah\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Ah     \bFunction:\p   07h

  \bTitle:\p       Reset Alarm

  \bDescription:\p                                               [AT] [PS/2]

     Cancels any pending alarm request on the CMOS date/time chip. This
     function does not disable the clock chip's interrupt level (IRQ8).

     \bInput\p        \bOutput\p

     AH = 07h     None
.context @1Ah.0Ah
.freeze 3
.topic Int 1Ah Function 0Ah
                                             \i\p\aUp\v@1Ah\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Ah     \bFunction:\p   0Ah

  \bTitle:\p       Get Day Count

  \bDescription:\p                                                    [PS/2]

     Returns the contents of the system's day counter.

     \bInput\p        \bOutput\p

     AH = 0Ah     If function successful
                    Carry flag: clear
                    CX = Count of days since 1-1-1980

                  If function unsuccessful
                    Carry flag: set
.context @1Ah.0Bh
.freeze 3
.topic Int 1Ah Function 0Bh
                                             \i\p\aUp\v@1Ah\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Ah     \bFunction:\p   0Bh

  \bTitle:\p       Set Day Count

  \bDescription:\p                                                    [PS/2]

     Stores an arbitrary value in the system's day counter.

     \bInput\p                        \bOutput\p

     AH = 0Bh                     If function successful
     CX = Count of days since       Carry flag: clear
          1-1-1980
                                  If function unsuccessful
                                    Carry flag: set
.context @1Ah.80h
.context @1Ah.80h.des
.freeze 3
.topic Int 1Ah Function 80h
                                             \i\p\aUp\v@1Ah\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Ah     \bFunction:\p   80h

  \bTitle:\p       Set Sound Source

  \bDescription:\p                                                      [PC]

     Sets up the source for tones that will appear on the PCjr's "Audio
     Out" or RF modulator. This function is supported on the PCjr only.

     \bInput\p                                     \bOutput\p

     AH = 80h                                  None
     AL = Sound source
        = 00h (if 8253 programmable timer,
              channel 2)
        = 01h (if cassette input)
        = 02h (if "Audio In" line on I/O
              channel)
        = 03h (if sound generator chip)
.context @1Bh
.context @1Bh.des
.context 1Bh
.context 01Bh
.context 27
..index Int 1Bh functions, CTRL+BREAK Interrupt
.freeze 3
.topic Int 1Bh
                                             \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Bh

  \bTitle:\p       CTRL+BREAK Handler

  \bSee also:\p    \aCTRL+C Handler\v@23h\v, \aKeyboard Data Memory\v@Keydata\v

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Invoked by Int 09h (keyboard) when it detects CTRL and BREAK keys
     pressed simultaneously. Usually terminates current process.

     To trap Int 1Bh calls, a program must set up a handler routine to
     gain control when the interrupt occurs. TSR programs that accept
     keyboard input should trap Int 1Bh calls with a handler to prevent
     the existing handler from responding to the keypress.

     \bInput\p     \bOutput\p

     None      None
.context @1Ch
.context 1Ch
.context 01Ch
.context 28
..index interrupt return (IRET), User Timer Interrupt
..index Int 1Ch, User Timer Interrupt
.freeze 3
.topic Int 1Ch
 \i\p\aDetail\v@1Ch.des\v\i\p                                    \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Ch

  \bTitle:\p       User Timer Service

  \bSee also:\p    \aTimer Tick\v@8h\v

  \bDescription:\p                                          [PC] [AT] [PS/2]

     Invoked from Int 08h each time it executes.

     Default service is interrupt return (IRET). To trap Int 1Ch calls,
     a program must set up a handler routine to gain control when the
     interrupt occurs.

     \bInput\p     \bOutput\p

     None      None
.context @1Ch.des
.freeze 3
.topic User Timer Interrupt
 \i\p\aSummary\v@1Ch\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     This interrupt provides an alternative means for a program to gain
     periodic control through an interrupt handler. It is suitable only
     for tasks of short duration, because when it executes the timer
     interrupt has not been completely serviced. If a handler must hold
     control for a long periodÄÄto invoke a TSR, for exampleÄÄit should
     chain to Int 08h instead and allow BIOS to completely process the
     interrupt first.

     Int 1Ch should be called directly only from an Int 08h handler
     that does not pass control to the original BIOS Int 08h service
     routine.
.context @1Dh
.context 1Dh
.context 01Dh
.context 29
..index video parameter table, Int 1Dh
..index Int 1Dh functions, Video Parameter Table Pointer
.freeze 3
.topic Int 1Dh
 \i\p\aDetail\v@1Dh.des\v\i\p                                    \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Dh

  \bTitle:\p       Pointer to Video Parameter Table

  \bDescription:\p                                               [MDA] [CGA]

     Vector points to a table of data used by BIOS Int 10h routine to
     initialize CRT controller during Set Video Mode operation
     (Function 00h). Useful only for MDA and CGA, but maintained by
     other video systems for compatibility.

     Vector does not point to a valid routine and must not be called
     with an INT instruction. Access this with Int 21h Function 35h
     (Get Interrupt Vector).
.context @1Dh.des
.freeze 3
.topic Video Parameter Table Pointer
 \i\p\aSummary\v@1Dh\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The following describes the Video Parameter Table format:

     \bOffset\p     \bType\p      \bDescription\p

     00h        array     Register values (modes 0 and 1)
     10h        array     Register values (modes 2 and 3)
     20h        array     Register values (modes 4, 5, and 6)
     30h        array     Register values (mode 7)
     40h        word      Buffer page length (modes 0 and 1)
     42h        word      Buffer page length (modes 2 and 3)
     44h        word      Buffer length (modes 4 and 5)
     46h        word      Buffer length (mode 6)
     48h        array     Number of display columns (modes 0-7)
     50h        array     Values for Display Control Register
                          (modes 0-7)
.context @1Eh
.context 1Eh
.context 01Eh
.context 30
..index disk drive parameter table, Int 1Eh
..index Int 1Eh functions, Disk Drive Parameter Table Pointer
.freeze 3
.topic Int 1Eh
 \i\p\aDetail\v@1Eh.des\v\i\p                                    \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Eh

  \bTitle:\p       Pointer to Disk Drive Parameter Table

  \bSee also:\p    \aDisk I/O Interrupts\v@13h\v

  \bDescription:\p                                          [PC] [AT] [PS/2]


     Vector points to an 11-byte data structure used by BIOS Int
     13h routine.

     Vector does not point to a valid routine and must not be called
     with an INT instruction. Access this with Int 21h Function 35h
     (Get Interrupt Vector).
.context @1Eh.des
.freeze 3
.topic Disk Drive Parameter Table Pointer
 \i\p\aSummary\v@1Eh\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     The following describes the Diskette Parameter Table format:

     \bOffset\p     \bDescription\p

     00h        High nibble = step-rate time, low nibble = head-unload
                time
     01h        High nibble = head-load time, low nibble = DMA mode
     02h        Elapse time to turn off diskette motor (37 clock ticks)
     03h        Bytes/sector key (0 = 128, 1 = 256, 2 = 512, 3 = 1,024)
     04h        Number of last sector on track
     05h        Gap size between sectors for read/write
     06h        Data transfer length (0FFh)
     07h        Gap size between sectors for format
     08h        Fill character between formatted sectors (0F6h)
     09h        Head-settle time (milliseconds)
     0Ah        Motor start time (1/8 seconds)

     \bSee also:\p \aDiskette Data memory\v@DiskData\v
.context @1Fh
.context 1Fh
.context 01Fh
.context 31
..index graphics character pattern table, Int 1Fh
..index Int 1Fh, Graphics Character Pattern Table Pointer
.freeze 3
.topic Int 1Fh
 \i\p\aDetail\v@1Fh.des\v\i\p                                    \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

  \bInterrupt:\p   1Fh

  \bTitle:\p       Pointer to Graphics Character Pattern Table

  \bSee also:\p    \aSet Int 1Fh Font Pointer\v@10h.11h.20h\v

  \bDescription:\p                                                     [CGA]

     When initialized, vector points to the table of bit patterns for
     ASCII characters 128 through 255. BIOS Int 10h uses this table
     when displaying high-numbered characters in CGA graphics modes. At
     system startup, vector is null. To display high-numbered
     characters, the program must provide table and set 1Fh vector to
     point to it.

     Vector does not point to a valid routine and must not be called
     with an INT instruction.

     Access with \aInt 21h Function 35h (Get Interrupt Vector)\v@21h.35h\v.

     Set new vector with \aInt 21h Function 25h (Set Interrupt Vector)\v@21h.25h\v.
.context @1Fh.des
.freeze 3
.topic Graphics Character Pattern Table Pointer
 \i\p\aSummary\v@1Fh\v\i\p                                   \i\p\aUp\v@bios.misc\v\i\p \i\p\aContents\vpwb.hlp!hv\v\i\p \i\p\aIndex\vpwb.hlp!vx\v\i\p \i\p\aBack\v!B\v\i\p
ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

     Each of the 128 patterns in the table consists of eight bytes,
     allowing patterns of 8x8 bits. The first set of eight bytes forms
     character 128; the second set forms character 129.

     Beginning with version 3.1, DOS provides the utility GRAFTABL to
     install a pattern table in memory and point the 1Fh vector to it.
     GRAFTABL forms characters matching those used in alphanumeric
     modes.
